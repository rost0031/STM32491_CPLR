<?xml version="1.0" encoding="UTF-8"?>
<model version="3.2.2">
 <documentation>/**
 * Main processor that runs the entire client
 */</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="ExitEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event type for exiting from MainMgr with an error code.
 */</documentation>
   <attribute name="errorCode" type="ClientError_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Error code that indicates the status of exit from this AO. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="MainMgr" superclass="qpc::QActive">
   <documentation>/**
 * @brief Active Object (AO) &quot;class&quot; that manages the all the processing.
 *
 * This AO manages the all the communications and message transactions between the
 * client and the Coupler Board. See MainMgr.qm for diagram and model.
 */</documentation>
   <attribute name="exitTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Used for timing out the actual exit for cleanup */</documentation>
   </attribute>
   <attribute name="errorCode" type="ClientError_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of last error and that will be returned or sent back to caller */</documentation>
   </attribute>
   <attribute name="m_pLog" type="LogStub*" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Local pointer to the logger instance */</documentation>
   </attribute>
   <attribute name="m_pComm" type="Comm*" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Local pointer to the Comm instance */</documentation>
   </attribute>
   <attribute name="msgTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Used for timing out waiting for responses (Ack, Prog, Done) to a Req msg */</documentation>
   </attribute>
   <statechart>
    <initial target="../1">
     <action>QS_OBJ_DICTIONARY(&amp;l_MainMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;l_MainMgr_initial);
QS_FUN_DICTIONARY(&amp;l_MainMgr_Active);

QActive_subscribe((QActive *)me, EXIT_SIG);
QActive_subscribe((QActive *)me, MSG_RECEIVED_SIG);
QActive_subscribe((QActive *)me, MSG_SEND_OUT_SIG);

DBG_printf(me-&gt;m_pLog,&quot;Started MainMgr AO&quot;);</action>
     <initial_glyph conn="1,2,4,3,11,2">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * @brief Catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and 
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Post and disarm all the timer events so they can be rearmed at any time */
QTimeEvt_postIn(
    &amp;me-&gt;exitTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( MAINMGR_MAX_TIME_SEC_EXIT_DELAY )
);
QTimeEvt_disarm(&amp;me-&gt;exitTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;msgTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( MAINMGR_MAX_TIME_SEC_EXIT_DELAY )
);
QTimeEvt_disarm(&amp;me-&gt;msgTimerEvt);

DBG_printf(me-&gt;m_pLog,&quot;Entered Active state in MainMgr AO&quot;);</entry>
     <tran trig="MSG_TIMEOUT_EXIT">
      <action>DBG_printf(me-&gt;m_pLog,&quot;Timed out while waiting for a response for a sent message.  Exiting.&quot;);
EXIT(me-&gt;errorCode);</action>
      <tran_glyph conn="114,69,5,-1,-18">
       <action box="-14,-2,14,2"/>
      </tran_glyph>
     </tran>
     <tran trig="EXIT" target="../4">
      <action>me-&gt;errorCode = ((ExitEvt *)e)-&gt;errorCode;
DBG_printf(me-&gt;m_pLog,&quot;Received exit&quot;);</action>
      <tran_glyph conn="3,70,3,3,17">
       <action box="0,-2,6,2"/>
      </tran_glyph>
     </tran>
     <tran trig="TEST_JOB">
      <action>DBG_printf(me-&gt;m_pLog,&quot;Received TEST_JOB, posting response to the raw queue&quot;);
QEvt* evt = Q_NEW(QEvt, TEST_JOB_DONE_SIG);
QEQueue_postFIFO(&amp;cliQueue, (QEvt *)evt);</action>
      <tran_glyph conn="3,62,3,-1,18">
       <action box="0,-2,10,2"/>
      </tran_glyph>
     </tran>
     <tran trig="MSG_SEND_OUT" target="../5/2">
      <action>DBG_printf(me-&gt;m_pLog,&quot;Got SEND_MSG, sending msg...&quot;);

me-&gt;m_pComm-&gt;write_some(
    (char *)((LrgDataEvt const *)e)-&gt;dataBuf,
    ((LrgDataEvt const *)e)-&gt;dataLen
);

char tmp[1000];
uint16_t tmpStrLen;
ClientError_t convertStatus = MSG_hexToStr(
    ((LrgDataEvt const *)e)-&gt;dataBuf,
    ((LrgDataEvt const *)e)-&gt;dataLen,
    tmp,
    1000,
    &amp;tmpStrLen,
    0,
    '-',
    true
);

DBG_printf(me-&gt;m_pLog,&quot;ConStatus: 0x%x, sending a buffer with: %s&quot;, convertStatus, tmp);

DBG_printf(me-&gt;m_pLog,&quot;Sent msg, waiting for Ack...&quot;);</action>
      <tran_glyph conn="3,19,3,3,25">
       <action box="0,-2,12,2"/>
      </tran_glyph>
     </tran>
     <state name="CleanupBeforeExit">
      <documentation>/**
 * @brief Wait state before exit.
 *
 * This state is a wait state that pauses long enough to let logging finish
 * before exiting..
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Arm the first time for a long time.  */
QTimeEvt_postIn(
    &amp;me-&gt;exitTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( MAINMGR_MAX_TIME_SEC_EXIT_DELAY )
);</entry>
      <tran trig="EXIT">
       <action>//exit( me-&gt;exit_code );
DBG_printf(me-&gt;m_pLog,&quot;Calling QActive_stop&quot;);
QActive_stop(AO_MainMgr);
QF_stop();</action>
       <tran_glyph conn="20,74,3,-1,16">
        <action box="0,-2,6,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="20,68,23,8">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state name="WaitingForJobDone">
      <exit>QTimeEvt_disarm(&amp;me-&gt;msgTimerEvt);</exit>
      <tran trig="MSG_RESP_TIMEOUT" target="../..">
       <action>ERR_printf(me-&gt;m_pLog, &quot;Got MSG_RESP_TIMEOUT. Aborting.&quot;);

QEvt* evt = Q_NEW(QEvt, MSG_DONE_TIMED_OUT_SIG);
QEQueue_postFIFO(&amp;cliQueue, (QEvt *)evt);
</action>
       <tran_glyph conn="24,24,3,3,-21">
        <action box="-17,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state name="WaitForDone">
       <documentation>/**
 * @brief Wait for Done from a message.
 * This state just waits for an Done response for a sent message.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;msgTimerEvt,
    SEC_TO_TICKS( MAINMGR_MAX_TOUT_SEC_DONE_WAIT )
);
</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;msgTimerEvt);</exit>
       <tran trig="MSG_RECEIVED">
        <action>DBG_printf(me-&gt;m_pLog,&quot;Got MSG_RECEIVED, parsing to see if it's Prog or Done...&quot;);

struct CBBasicMsg basicMsg;
memset(&amp;basicMsg, 0, sizeof(basicMsg));
CBBasicMsg_read_delimited_from(
    (void*)((LrgDataEvt const *) e)-&gt;dataBuf,
    &amp;basicMsg,
    0
);</action>
        <choice>
         <guard brief="Prog?">_CB_Prog == basicMsg._msgType</guard>
         <action>/* Since this is a progres msg, rearm the timer for longer */
QTimeEvt_rearm(
    &amp;me-&gt;msgTimerEvt,
    SEC_TO_TICKS( MAINMGR_MAX_TOUT_SEC_DONE_WAIT )
);


DBG_printf(me-&gt;m_pLog,&quot;Msg parsed as Prog, continuing...&quot;);

/* Post an MSG_PROG_RECVD_SIG to the queue so the caller can decide what 
 * to do (if anything) with this information. */

/* Changed only the signal associated with event and repost it directly to the queue*/
((LrgDataEvt *) e)-&gt;super.sig = MSG_PROG_RECVD_SIG;
QEQueue_postFIFO(&amp;cliQueue, (QEvt *)e);</action>
         <choice_glyph conn="92,18,4,-1,4,8">
          <action box="1,2,6,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../..">
         <guard brief="Done?">_CB_Done == basicMsg._msgType</guard>
         <action>DBG_printf(me-&gt;m_pLog,&quot;Msg parsed as Done, finishing...&quot;);

/* Post an MSG_DONE_RECVD_SIG to the queue so the caller can decide what 
 * to do (if anything) with this information. */

/* Changed only the signal associated with event and repost it directly to the queue*/
((LrgDataEvt *) e)-&gt;super.sig = MSG_DONE_RECVD_SIG;
QEQueue_postFIFO(&amp;cliQueue, (QEvt *)e);</action>
         <choice_glyph conn="92,18,5,1,22">
          <action box="1,-2,6,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="78,18,1,-1,14">
         <action box="0,-2,13,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="63,15,15,10">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitForAck">
       <documentation>/**
 * @brief Wait for Ack from a message.
 * This state just waits for an Ack response for a sent message.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>/* Post a timer on entry */
QTimeEvt_rearm(
    &amp;me-&gt;msgTimerEvt,
    SEC_TO_TICKS( MAINMGR_MAX_TOUT_SEC_ACK_WAIT )
);
</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;msgTimerEvt);</exit>
       <tran trig="MSG_RECEIVED">
        <action>DBG_printf(me-&gt;m_pLog,&quot;Got MSG_RECEIVED, parsing to see if it's an Ack...&quot;);
struct CBBasicMsg basicMsg;
memset(&amp;basicMsg, 0, sizeof(basicMsg));
CBBasicMsg_read_delimited_from(
    (void*)((LrgDataEvt const *) e)-&gt;dataBuf,
    &amp;basicMsg,
    0
);

</action>
        <choice target="../../../..">
         <guard>else</guard>
         <action>ERR_printf(
    me-&gt;m_pLog,
    &quot;While expecting an Ack, got invalid msgType %d. Aborting.&quot;,
    basicMsg._msgType
);

QEvt* evt = Q_NEW(QEvt, MSG_ACK_TIMED_OUT_SIG);
QEQueue_postFIFO(&amp;cliQueue, (QEvt *)evt);</action>
         <choice_glyph conn="55,18,4,3,9,-52">
          <action box="0,2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../1">
         <guard brief="Ack?">_CB_Ack == basicMsg._msgType</guard>
         <action>DBG_printf(me-&gt;m_pLog,&quot;Msg parsed as Ack, continuing...&quot;);

/* Post an MSG_ACK_RECVD_SIG to the queue so the caller can decide what 
 * to do (if anything) with this information. */

/* Changed only the signal associated with event and repost it directly to the queue*/
((LrgDataEvt *) e)-&gt;super.sig = MSG_ACK_RECVD_SIG;
QEQueue_postFIFO(&amp;cliQueue, (QEvt *)e);
</action>
         <choice_glyph conn="55,18,5,3,8">
          <action box="1,-2,6,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="42,18,1,-1,13">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="28,15,14,10">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="24,8,82,32">
       <exit box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,2,111,76">
      <entry box="1,2,6,2"/>
     </state_glyph>
    </state>
    <state_diagram size="142,80"/>
   </statechart>
  </class>
  <attribute name="AO_MainMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="MainMgr_setConn" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief Sets a new connection.
 * This globally accesible function sets a new connection for MainMgr AO to use.
 * @param [in] *comm: comm pointer to a new connection object.
 * @retval: none
 */</documentation>
   <parameter name="comm" type="Comm*"/>
   <code>delete[] l_MainMgr.m_pComm; /* Remove old connection */
l_MainMgr.m_pComm = comm;  /* Set new connection */
DBG_printf(l_MainMgr.m_pLog,&quot;Set new connection&quot;);
</code>
  </operation>
  <operation name="MainMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for MainMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param [in]: *log: LogStub pointer to a logging object.
 * @retval: none
 */</documentation>
   <parameter name="log" type="LogStub*"/>
   <code>MainMgr *me = &amp;l_MainMgr;
me-&gt;m_pLog = log;
DBG_printf(me-&gt;m_pLog,&quot;Logging setup successful&quot;);
QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;MainMgr_initial);
QTimeEvt_ctor(&amp;me-&gt;exitTimerEvt, EXIT_SIG);
QTimeEvt_ctor(&amp;me-&gt;msgTimerEvt, MSG_RESP_TIMEOUT_SIG);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="MainMgr_gen.h">
   <text>/**
 * @file    MainMgr.h
 * Definitions for functions for the MainMgr AO.  This file is heavily
 * based on the code auto-generated using MainMgr.qm model.  Please update
 * the model to reflect any manual changes to the code.
 *
 * Note: If editing this file, please make sure to update the MainMgr.qm
 * model.  The generated code from that model should be very similar to the code
 * in this file.
 *
 * @date    03/20/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupClient
 * @{
 */
#ifndef MAINMGR_H_
#define MAINMGR_H_

using namespace std;

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;ClientShared.h&quot;
#include &quot;LogStub.h&quot;
#include &quot;comm.h&quot;
#include &quot;MainMgrDefs.h&quot;

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
extern QEQueue cliQueue;      /**&lt; raw queue to talk between ClientApi and AO */

/* Exported functions --------------------------------------------------------*/
$declare(AOs::MainMgr_ctor)
$declare(AOs::MainMgr_setConn)
$declare(AOs::AO_MainMgr)

/**
 * @} end addtogroup groupClient
 */
#endif                                                          /* MAINMGR_H_ */
/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
</text>
  </file>
  <file name="MainMgr_gen.cpp">
   <text>/**
 * @file    MainMgr.cpp
 * Definitions for functions for the MainMgr AO.  This file is heavily
 * based on the code auto-generated using MainMgr.qm model.  Please update
 * the model to reflect any manual changes to the code.
 *
 * Note: If editing this file, please make sure to update the MainMgr.qm
 * model.  The generated code from that model should be very similar to the code
 * in this file.
 *
 * @date    03/20/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupClient
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;MainMgr.h&quot;
#include &quot;LogHelper.h&quot;
#include &lt;cstring&gt;
#include &quot;ClientShared.h&quot;
#include &quot;msg_utils.h&quot;

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;
MODULE_NAME( MODULE_MGR );

/* All timeouts should be defined in CBTimeouts.h as part of the
 * CBCommAPI that should be visible to the client/coupler */
#define EXIT(error_code)                              \
do {                                                  \
        ExitEvt *exEv = Q_NEW(ExitEvt, EXIT_SIG);     \
        exEv-&gt;errorCode = error_code;                 \
        QF_PUBLISH((QEvent *)exEv, AO_MainMgr);       \
   } while (0)

/* Private typedefs ----------------------------------------------------------*/
/**&lt; Active object class */
$declare(AOs::MainMgr)

/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static MainMgr l_MainMgr;            /* the single instance of the MainMgr AO */
QEQueue cliQueue;        /**&lt; raw queue to talk between ClientApi and AO */

/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_MainMgr = (QActive *)&amp;l_MainMgr;    /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::MainMgr_ctor)
$define(AOs::MainMgr_setConn)
$define(AOs::MainMgr)

/**
 * @} end addtogroup groupClient
 */
/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
