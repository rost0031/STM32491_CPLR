/*****************************************************************************
* Model: MainMgr.qm
* File:  ./MainMgr_gen.cpp
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::MainMgr_gen.cpp} ....................................................*/
/**
 * @file    MainMgr.cpp
 * Definitions for functions for the MainMgr AO.  This file is heavily
 * based on the code auto-generated using MainMgr.qm model.  Please update
 * the model to reflect any manual changes to the code.
 *
 * Note: If editing this file, please make sure to update the MainMgr.qm
 * model.  The generated code from that model should be very similar to the code
 * in this file.
 *
 * @date    03/20/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupClient
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "MainMgr.h"
#include "LogHelper.h"
#include <cstring>
#include "ClientShared.h"
#include "msg_utils.h"

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;
MODULE_NAME( MODULE_MGR );

/* All timeouts should be defined in CBTimeouts.h as part of the
 * CBCommAPI that should be visible to the client/coupler */
#define EXIT(error_code)                              \
do {                                                  \
        ExitEvt *exEv = Q_NEW(ExitEvt, EXIT_SIG);     \
        exEv->errorCode = error_code;                 \
        QF_PUBLISH((QEvent *)exEv, AO_MainMgr);       \
   } while (0)

/* Private typedefs ----------------------------------------------------------*/
/**< Active object class */

/**
 * @brief Active Object (AO) "class" that manages the all the processing.
 *
 * This AO manages the all the communications and message transactions between the
 * client and the Coupler Board. See MainMgr.qm for diagram and model.
 */
/*${AOs::MainMgr} ..........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Used for timing out the actual exit for cleanup */
    QTimeEvt exitTimerEvt;

    /**< Keep track of last error and that will be returned or sent back to caller */
    ClientError_t errorCode;

    /**< Local pointer to the logger instance */
    LogStub* m_pLog;

    /**< Local pointer to the Comm instance */
    Comm* m_pComm;

    /**< Used for timing out waiting for responses (Ack, Prog, Done) to a Req msg */
    QTimeEvt msgTimerEvt;
} MainMgr;

/* protected: */
static QState MainMgr_initial(MainMgr * const me, QEvt const * const e);

/**
 * @brief Catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState MainMgr_Active(MainMgr * const me, QEvt const * const e);
static QState MainMgr_WaitingForJobDone(MainMgr * const me, QEvt const * const e);

/**
 * @brief Wait for Done from a message.
 * This state just waits for an Done response for a sent message.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState MainMgr_WaitForDone(MainMgr * const me, QEvt const * const e);

/**
 * @brief Wait for Ack from a message.
 * This state just waits for an Ack response for a sent message.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState MainMgr_WaitForAck(MainMgr * const me, QEvt const * const e);

/**
 * @brief Wait for the next CBFlashMsg to be sent from ClientApi
 * This state just waits for the next CBFlash Req msg to be sent from ClientApi.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
static QState MainMgr_WaitForNextFlashCmd(MainMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static MainMgr l_MainMgr;            /* the single instance of the MainMgr AO */
QEQueue cliQueue;        /**< raw queue to talk between ClientApi and AO */

/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_MainMgr = (QActive *)&l_MainMgr;    /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for MainMgr "class".
 * Initializes all the timers and queues used by the AO, sets up a deferral
 * queue, and sets of the first state.
 * @param [in]: *log: LogStub pointer to a logging object.
 * @retval: none
 */
/*${AOs::MainMgr_ctor} .....................................................*/
void MainMgr_ctor(LogStub* log) {
    MainMgr *me = &l_MainMgr;
    me->m_pLog = log;
    DBG_printf(me->m_pLog,"Logging setup successful");
    QActive_ctor(&me->super, (QStateHandler)&MainMgr_initial);
    QTimeEvt_ctor(&me->exitTimerEvt, EXIT_SIG);
    QTimeEvt_ctor(&me->msgTimerEvt, MSG_RESP_TIMEOUT_SIG);
}

/**
 * @brief Sets a new connection.
 * This globally accesible function sets a new connection for MainMgr AO to use.
 * @param [in] *comm: comm pointer to a new connection object.
 * @retval: none
 */
/*${AOs::MainMgr_setConn} ..................................................*/
void MainMgr_setConn(Comm* comm) {
    delete[] l_MainMgr.m_pComm; /* Remove old connection */
    l_MainMgr.m_pComm = comm;  /* Set new connection */
    DBG_printf(l_MainMgr.m_pLog,"Set new connection");

}

/**
 * @brief Active Object (AO) "class" that manages the all the processing.
 *
 * This AO manages the all the communications and message transactions between the
 * client and the Coupler Board. See MainMgr.qm for diagram and model.
 */
/*${AOs::MainMgr} ..........................................................*/
/*${AOs::MainMgr::SM} ......................................................*/
static QState MainMgr_initial(MainMgr * const me, QEvt const * const e) {
    /* ${AOs::MainMgr::SM::initial} */
    QS_OBJ_DICTIONARY(&l_MainMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&l_MainMgr_initial);
    QS_FUN_DICTIONARY(&l_MainMgr_Active);

    QActive_subscribe((QActive *)me, EXIT_SIG);
    QActive_subscribe((QActive *)me, MSG_RECEIVED_SIG);
    QActive_subscribe((QActive *)me, MSG_SEND_OUT_SIG);

    DBG_printf(me->m_pLog,"Started MainMgr AO");
    return Q_TRAN(&MainMgr_Active);
}

/**
 * @brief Catch-all Active state.
 * If any signals need to be handled that do not cause state transitions and
 * are common to the entire AO, they should be handled here.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::MainMgr::SM::Active} ..............................................*/
static QState MainMgr_Active(MainMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::MainMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Post and disarm all the timer events so they can be rearmed at any time */
            QTimeEvt_postIn(
                &me->exitTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( MAINMGR_MAX_TIME_SEC_EXIT_DELAY )
            );
            QTimeEvt_disarm(&me->exitTimerEvt);

            QTimeEvt_postIn(
                &me->msgTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( MAINMGR_MAX_TIME_SEC_EXIT_DELAY )
            );
            QTimeEvt_disarm(&me->msgTimerEvt);

            DBG_printf(me->m_pLog,"Entered Active state in MainMgr AO");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::MSG_TIMEOUT_EXIT} */
        case MSG_TIMEOUT_EXIT_SIG: {
            DBG_printf(me->m_pLog,"Timed out while waiting for a response for a sent message.  Exiting.");
            EXIT(me->errorCode);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::TEST_JOB} */
        case TEST_JOB_SIG: {
            DBG_printf(me->m_pLog,"Received TEST_JOB, posting response to the raw queue");
            QEvt* evt = Q_NEW(QEvt, TEST_JOB_DONE_SIG);
            QEQueue_postFIFO(&cliQueue, (QEvt *)evt);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::MSG_SEND_OUT} */
        case MSG_SEND_OUT_SIG: {
            DBG_printf(me->m_pLog,"Got SEND_MSG, sending msg...");

            me->m_pComm->write_some(
                (char *)((LrgDataEvt const *)e)->dataBuf,
                ((LrgDataEvt const *)e)->dataLen
            );

            char tmp[1000];
            uint16_t tmpStrLen;
            ClientError_t convertStatus = MSG_hexToStr(
                ((LrgDataEvt const *)e)->dataBuf,
                ((LrgDataEvt const *)e)->dataLen,
                tmp,
                1000,
                &tmpStrLen,
                0,
                '-',
                true
            );

            DBG_printf(me->m_pLog,"ConStatus: 0x%x, sending a buffer with: %s", convertStatus, tmp);

            DBG_printf(me->m_pLog,"Sent msg, waiting for Ack...");
            status_ = Q_TRAN(&MainMgr_WaitForAck);
            break;
        }
        /* ${AOs::MainMgr::SM::Active::EXIT} */
        case EXIT_SIG: {
            //exit( me->exit_code );
            DBG_printf(me->m_pLog,"Calling QActive_stop");
            QActive_stop(AO_MainMgr);
            QF_stop();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::MainMgr::SM::Active::WaitingForJobDon~} ...........................*/
static QState MainMgr_WaitingForJobDone(MainMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->msgTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::MSG_RESP_TIMEOUT} */
        case MSG_RESP_TIMEOUT_SIG: {
            ERR_printf(me->m_pLog, "Got MSG_RESP_TIMEOUT. Aborting.");

            QEvt* evt = Q_NEW(QEvt, MSG_DONE_TIMED_OUT_SIG);
            QEQueue_postFIFO(&cliQueue, (QEvt *)evt);

            status_ = Q_TRAN(&MainMgr_Active);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief Wait for Done from a message.
 * This state just waits for an Done response for a sent message.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone} ..............*/
static QState MainMgr_WaitForDone(MainMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone} */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->msgTimerEvt,
                SEC_TO_TICKS( MAINMGR_MAX_TOUT_SEC_DONE_WAIT )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->msgTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone::MSG_RECEIVED} */
        case MSG_RECEIVED_SIG: {
            DBG_printf(me->m_pLog,"Got MSG_RECEIVED, parsing to see if it's Prog or Done...");

            struct CBBasicMsg basicMsg;
            memset(&basicMsg, 0, sizeof(basicMsg));
            CBBasicMsg_read_delimited_from(
                (void*)((LrgDataEvt const *) e)->dataBuf,
                &basicMsg,
                0
            );
            /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone::MSG_RECEIVED::[Prog?]} */
            if (_CB_Prog == basicMsg._msgType) {
                /* Since this is a progres msg, rearm the timer for longer */
                QTimeEvt_rearm(
                    &me->msgTimerEvt,
                    SEC_TO_TICKS( MAINMGR_MAX_TOUT_SEC_DONE_WAIT )
                );


                DBG_printf(me->m_pLog,"Msg parsed as Prog, continuing...");

                /* Post an MSG_PROG_RECVD_SIG to the queue so the caller can decide what
                 * to do (if anything) with this information. */

                /* Changed only the signal associated with event and repost it directly to the queue*/
                ((LrgDataEvt *) e)->super.sig = MSG_PROG_RECVD_SIG;
                QEQueue_postFIFO(&cliQueue, (QEvt *)e);
                /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone::MSG_RECEIVED::[Prog?]::[CBFlashMsg?]} */
                if (_CBFlashMsg == basicMsg._msgName) {
                    status_ = Q_TRAN(&MainMgr_WaitForNextFlashCmd);
                }
                /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone::MSG_RECEIVED::[Prog?]::[else]} */
                else {
                    status_ = Q_TRAN(&MainMgr_WaitForDone);
                }
            }
            /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForDone::MSG_RECEIVED::[Done?]} */
            else if (_CB_Done == basicMsg._msgType) {
                DBG_printf(me->m_pLog,"Msg parsed as Done, finishing...");

                /* Post an MSG_DONE_RECVD_SIG to the queue so the caller can decide what
                 * to do (if anything) with this information. */

                /* Changed only the signal associated with event and repost it directly to the queue*/
                ((LrgDataEvt *) e)->super.sig = MSG_DONE_RECVD_SIG;
                QEQueue_postFIFO(&cliQueue, (QEvt *)e);
                status_ = Q_TRAN(&MainMgr_Active);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&MainMgr_WaitingForJobDone);
            break;
        }
    }
    return status_;
}

/**
 * @brief Wait for Ack from a message.
 * This state just waits for an Ack response for a sent message.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForAck} ...............*/
static QState MainMgr_WaitForAck(MainMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForAck} */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->msgTimerEvt,
                SEC_TO_TICKS( MAINMGR_MAX_TOUT_SEC_ACK_WAIT )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForAck} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->msgTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForAck::MSG_RECEIVED} */
        case MSG_RECEIVED_SIG: {
            DBG_printf(me->m_pLog,"Got MSG_RECEIVED, parsing to see if it's an Ack...");
            struct CBBasicMsg basicMsg;
            memset(&basicMsg, 0, sizeof(basicMsg));
            CBBasicMsg_read_delimited_from(
                (void*)((LrgDataEvt const *) e)->dataBuf,
                &basicMsg,
                0
            );


            /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForAck::MSG_RECEIVED::[Ack?]} */
            if (_CB_Ack == basicMsg._msgType) {
                DBG_printf(me->m_pLog,"Msg parsed as Ack, continuing...");

                /* Post an MSG_ACK_RECVD_SIG to the queue so the caller can decide what
                 * to do (if anything) with this information. */

                /* Changed only the signal associated with event and repost it directly to the queue*/
                ((LrgDataEvt *) e)->super.sig = MSG_ACK_RECVD_SIG;
                QEQueue_postFIFO(&cliQueue, (QEvt *)e);

                status_ = Q_TRAN(&MainMgr_WaitForDone);
            }
            /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForAck::MSG_RECEIVED::[else]} */
            else {
                ERR_printf(
                    me->m_pLog,
                    "While expecting an Ack, got invalid msgType %d. Aborting.",
                    basicMsg._msgType
                );

                QEvt* evt = Q_NEW(QEvt, MSG_ACK_TIMED_OUT_SIG);
                QEQueue_postFIFO(&cliQueue, (QEvt *)evt);
                status_ = Q_TRAN(&MainMgr_Active);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&MainMgr_WaitingForJobDone);
            break;
        }
    }
    return status_;
}

/**
 * @brief Wait for the next CBFlashMsg to be sent from ClientApi
 * This state just waits for the next CBFlash Req msg to be sent from ClientApi.
 *
 * @param  [in,out] me: Pointer to the state machine
 * @param  [in,out] e:  Pointer to the event being processed.
 * @return status_: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForNextFlash~} ........*/
static QState MainMgr_WaitForNextFlashCmd(MainMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForNextFlash~} */
        case Q_ENTRY_SIG: {
            /* Post a timer on entry */
            QTimeEvt_rearm(
                &me->msgTimerEvt,
                SEC_TO_TICKS( MAINMGR_MAX_TOUT_SEC_DONE_WAIT )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForNextFlash~} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->msgTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::MainMgr::SM::Active::WaitingForJobDon~::WaitForNextFlash~::MSG_SEND_OUT} */
        case MSG_SEND_OUT_SIG: {
            DBG_printf(me->m_pLog,"Got SEND_MSG, sending msg...");

            me->m_pComm->write_some(
                (char *)((LrgDataEvt const *)e)->dataBuf,
                ((LrgDataEvt const *)e)->dataLen
            );
            /*
            char tmp[1000];
            uint16_t tmpStrLen;
            ClientError_t convertStatus = MSG_hexToStr(
                ((LrgDataEvt const *)e)->dataBuf,
                ((LrgDataEvt const *)e)->dataLen,
                tmp,
                1000,
                &tmpStrLen,
                0,
                '-',
                true
            );

            DBG_printf(me->m_pLog,"ConStatus: 0x%x, sending a buffer with: %s", convertStatus, tmp);
            */
            DBG_printf(me->m_pLog,"Sent msg, waiting for Ack...");
            status_ = Q_TRAN(&MainMgr_WaitForAck);
            break;
        }
        default: {
            status_ = Q_SUPER(&MainMgr_WaitingForJobDone);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupClient
 */
/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
