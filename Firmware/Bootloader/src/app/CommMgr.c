/*****************************************************************************
* Model: CommMgr.qm
* File:  ./CommMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::CommMgr_gen.c} ......................................................*/
/**
 * @file    CommMgr.c
 * Declarations for functions for the CommMgr AO.  This state
 * machine handles all incoming messages and their distribution for the
 * bootloader.
 *
 * Note: If editing this file, please make sure to update the CommMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/27/2014
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2014 Datacard. All rights reserved.
 *
 * @addtogroup groupComm
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "CommMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp_defs.h"                         /* For time to ticks conversion */
#include "serial.h"                               /* For serial functionality */

#include "I2C1DevMgr.h"                                  /* For I2C Evt types */
#include "LWIPMgr.h"                        /* For UDP ethernet functionality */
#include "SerialMgr.h"
#include "SysMgr.h"
#include "FlashMgr.h"

#include "base64_wrapper.h"                            /* For base64 encoding */
#include "flash.h"
#include "crc32compat.h"
#include "version.h"
#include "i2c_dev.h"

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_COMM );/* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
typedef void (*pFunction)(void);


/**
 * \brief CommMgr "class"
 */
/*${AOs::CommMgr} ..........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Local buffer to store incoming msgs */
    uint8_t* dataBuf[DC3_MAX_MSG_LEN];

    /**< Common struct for DC3BasicMsg.  This can be re-used in most cases since once the
     * request has been unwrapped, all the data from that struct has been stored locally */
    struct DC3BasicMsg basicMsg;

    /**< Keeps track of how far into the dataBuf basicMsg was.  Sometimes, there are
     * additional payload msgs after the BasicMsg in the buffer and this variable allows
     * the next deserialization step to know where to find them */
    uint16_t basicMsgOffset;

    /**< Keeps track of where the message came from */
    DC3MsgRoute msgRoute;

    /**< Keep track of the ID of the msg */
    uint32_t msgId;

    /**< Keep track of whether Prog responses were requested by the sender of the msg */
    bool msgReqProg;

    /**< Keep track of the CLI_RECEIVED_SIG event source in order to send it back the
     * same comm channel */
    DC3MsgRoute cliEvtSrc;

    /**< Keep track of the CLI_RECEIVED_SIG event destination.
     * TODO: This isn't currently used but hold on to it just in case. Figure out if
     * this is even needed.*/
    DC3MsgRoute cliEvtDst;

    /**< Keep track of errors that may occur in the AO */
    DC3Error_t errorCode;

    /**< Keep track of what the payload msg is supposed to be upon reception.  This is
     * necessary because basicMsg struct gets modified to send an Ack and this variable
     * will be used to extract the rest of the payload from the data buffer where it's
     * still being stored. */
    DC3MsgName msgPayloadName;

    /**< Union of all the possible payload msgs.  This gets populated by the recieved msg
     * processing and later reused to send Prog and Done msgs. */
    DC3PayloadMsgUnion_t payloadMsgUnion;

    /**< Timer for timing out the Busy state of CommMgr Ao. */
    QTimeEvt commMgrTimerEvt;

    /**< Timer for timing out the individual operations in CommMgr AO. */
    QTimeEvt commOpTimerEvt;
} CommMgr;

/* protected: */
static QState CommMgr_initial(CommMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState CommMgr_Active(CommMgr * const me, QEvt const * const e);

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState CommMgr_Idle(CommMgr * const me, QEvt const * const e);

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState CommMgr_Busy(CommMgr * const me, QEvt const * const e);

/**
 * @brief    State that waits for a response from FlashMgr AO.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState CommMgr_WaitForRespFromFlashMgr(CommMgr * const me, QEvt const * const e);

/**
 * @brief	State that ensures the system stays in the Busy state while processing.
 * This state just self-posts an event to start the msg processing. Its primary
 * reason for existance is to make sure that the state machine ends up inside the
 * busy state for proper error handling (if any occur).
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState CommMgr_ValidateMsg(CommMgr * const me, QEvt const * const e);

/**
 * @brief    State that waits for a response from I2C1DevMgr AO.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState CommMgr_WaitForRespFromI2C(CommMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
#define LWIP_ALLOWED

/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
pFunction Jump_To_Application;
uint32_t JumpAddress;

static CommMgr l_CommMgr; /* the single instance of the Interstage active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_CommMgr = (QActive *)&l_CommMgr;  /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for CommMgr "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::CommMgr_ctor} .....................................................*/
void CommMgr_ctor(void) {
    CommMgr *me = &l_CommMgr;
    QActive_ctor(&me->super, (QStateHandler)&CommMgr_initial);
    QTimeEvt_ctor(&me->commMgrTimerEvt, COMM_MGR_TIMEOUT_SIG);
    QTimeEvt_ctor(&me->commOpTimerEvt, COMM_OP_TIMEOUT_SIG);
}

/**
 * @brief	Wrapper around serial and UDP send data function.
 * This function acts as a simple wrapper around serial and UDP ethernet send data
 * functions to allow easy posting of events to send out data over those interfaces.
 * @param [in] *evt: LrgDataEvt pointer to event to send.
 * @return: DC3Error_t indicating status of operation.
 */
/*${AOs::Comm_sendToClien~} ................................................*/
DC3Error_t Comm_sendToClient(LrgDataEvt* evt) {
    DC3Error_t status = ERR_NONE;
    if ( _DC3_Serial == evt->dst ) {
        uint8_t encDataBuf[DC3_MAX_MSG_LEN];
        memset(encDataBuf, 0, sizeof(encDataBuf));
        uint16_t encDataLen = base64_encode(
              (char *)(evt->dataBuf),
              evt->dataLen,
              (char *)encDataBuf,
              DC3_MAX_MSG_LEN
        );

        if(encDataLen < 1) {
            status = ERR_SERIAL_MSG_BASE64_ENC_FAILED;
            ERR_printf(
                "Base64 encoding ran out of space, error: 0x%08x\n",
                status
            );
            /* Set so we don't error out copying.  Client should know how to
             * to properly handle this */
            encDataLen = 1;
        }

        /* Modify the contents of the event with the new encoded data and send
         * it regardless of whether we*/
        evt->dataLen = encDataLen;
        MEMCPY( evt->dataBuf, encDataBuf, evt->dataLen);
        evt->dst = _DC3_Serial;
        evt->src = _DC3_Serial;

        /* Directly post to the LWIPMgr AO. */
        QACTIVE_POST( AO_SerialMgr, (QEvt *)(evt), 0 );

    } else { /* Always attempt to send over UDP to prevent leaking the event */
        /* No modifications needed to the UDP send so just post it directly to that AO.*/
        /* Directly post to the LWIPMgr AO. */
        QACTIVE_POST( AO_LWIPMgr, (QEvt *)(evt), 0 );
    }

    /* If we got here, src or dst was not set up properly. */
    return status;
}

/**
 * \brief CommMgr "class"
 */
/*${AOs::CommMgr} ..........................................................*/
/*${AOs::CommMgr::SM} ......................................................*/
static QState CommMgr_initial(CommMgr * const me, QEvt const * const e) {
    /* ${AOs::CommMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_CommMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&CommMgr_initial);
    QS_FUN_DICTIONARY(&CommMgr_Active);

    QActive_subscribe((QActive *)me, SER_RECEIVED_SIG);
    QActive_subscribe((QActive *)me, CLI_RECEIVED_SIG);
    QActive_subscribe((QActive *)me, I2C1_DEV_READ_DONE_SIG);
    QActive_subscribe((QActive *)me, I2C1_DEV_WRITE_DONE_SIG);
    return Q_TRAN(&CommMgr_Idle);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::CommMgr::SM::Active} ..............................................*/
static QState CommMgr_Active(CommMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::CommMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Arm and disarm*/
            QTimeEvt_postIn(
                &me->commMgrTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_MSG_PROCESS )
            );
            QTimeEvt_disarm(&me->commMgrTimerEvt);

            QTimeEvt_postIn(
                &me->commOpTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_MSG_PROCESS )
            );
            QTimeEvt_disarm(&me->commOpTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::BOOT_APPL} */
        case BOOT_APPL_SIG: {
            /* This slow log statement has to be here because it flushes the serial output. If
             * this is removed, there will be crashing here - HR */
            log_slow_printf("Got BOOT_APPL sig. Booting Application...\n");

            /* If we made it here, no errors have been encountered and we
             * can safely proceed to boot the Application FW image */

            /* Disable the Systick ISR */
            SysTick->CTRL &= ~(SysTick_CTRL_TICKINT_Msk   | SysTick_CTRL_ENABLE_Msk);

            /* Jump to user application */
            JumpAddress = *(__IO uint32_t*) (FLASH_APPL_START_ADDR + 4);
            Jump_To_Application = (pFunction) JumpAddress;

            /* Initialize user application's Stack Pointer */
            __set_MSP(*(__IO uint32_t*) FLASH_APPL_START_ADDR);

            /* After this call, we are running the Application FW image */
            Jump_To_Application();
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::CommMgr::SM::Active::Idle} ........................................*/
static QState CommMgr_Idle(CommMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::CommMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* Clear out all the variables on entry to Idle state.  By this point, any error
             * feedback should have already happened. */
            me->errorCode       = ERR_NONE;
            me->msgId           = 0;
            me->cliEvtSrc       = _DC3_NoRoute;
            me->cliEvtDst       = _DC3_NoRoute;
            me->msgRoute        = _DC3_NoRoute;
            me->msgPayloadName  = _DC3NoMsg;
            me->msgReqProg      = false;

            memset(&me->basicMsg, 0, sizeof(me->basicMsg));
            memset(&me->payloadMsgUnion, 0, sizeof(me->payloadMsgUnion));
            memset(me->dataBuf, 0, sizeof(me->dataBuf));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Idle::SER_RECEIVED} */
        case SER_RECEIVED_SIG: {
            LrgDataEvt *cliEvt = Q_NEW(LrgDataEvt, CLI_RECEIVED_SIG);
            cliEvt->dataLen = base64_decode(
                (char *)((LrgDataEvt const *) e)->dataBuf,
                ((LrgDataEvt const *) e)->dataLen,
                (char *)cliEvt->dataBuf,
                DC3_MAX_MSG_LEN
            );

            cliEvt->src = ((LrgDataEvt const *) e)->src;
            cliEvt->dst = ((LrgDataEvt const *) e)->dst;

            QACTIVE_POST(
                AO_CommMgr,
                (QEvt *)(cliEvt),
                AO_CommMgr
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Idle::CLI_RECEIVED} */
        case CLI_RECEIVED_SIG: {
            /* Extract the basicMsg first */
            memset(&(me->basicMsg), 0, sizeof(me->basicMsg));
            me->basicMsgOffset = DC3BasicMsg_read_delimited_from(
                (void*)((LrgDataEvt const *) e)->dataBuf,
                &(me->basicMsg),
                0
            );

            /* Store the event source and destination before entering a new state where that
             * information will be lost. */
            me->cliEvtSrc = ((LrgDataEvt const *) e)->src;
            me->cliEvtDst = ((LrgDataEvt const *) e)->dst;

            /* Store the basic msg elements locally since they are needed to send back all the
             * ack, prog, and done replies. */
            me->msgRoute   = me->basicMsg._msgRoute;
            me->msgId      = me->basicMsg._msgID;
            me->msgReqProg = (bool)(me->basicMsg._msgReqProg);
            me->msgPayloadName = me->basicMsg._msgPayload; // save this since Ack will overwrite it

            /* Extract the payload (if exists) since this buffer is going away the moment we get
             * into a state.  We'll figure out later if it's valid, right before we send an Ack */
            switch( me->msgPayloadName ) {
                case _DC3NoMsg:
                    DBG_printf("No payload detected\n");
                    break;
                case _DC3StatusPayloadMsg:
                    WRN_printf("Status payload detected, this is probably an error\n");
                    break;
                case _DC3VersionPayloadMsg:
                    WRN_printf("Version payload detected, this is probably an error\n");
                    break;
                case _DC3BootModePayloadMsg:
                    DBG_printf("BootMode payload detected\n");
                    DC3BootModePayloadMsg_read_delimited_from(
                        ((LrgDataEvt *) e)->dataBuf,
                        &(me->payloadMsgUnion.bootmodePayload),
                        me->basicMsgOffset
                    );
                    break;
                case _DC3FlashMetaPayloadMsg:
                    DC3FlashMetaPayloadMsg_read_delimited_from(
                        ((LrgDataEvt *) e)->dataBuf,
                        &(me->payloadMsgUnion.flashMetaPayload),
                        me->basicMsgOffset
                    );
                    break;
                case _DC3FlashDataPayloadMsg:
                    DC3FlashDataPayloadMsg_read_delimited_from(
                        ((LrgDataEvt *) e)->dataBuf,
                        &(me->payloadMsgUnion.flashDataPayload),
                        me->basicMsgOffset
                    );
                    break;
                case _DC3I2CDataPayloadMsg:
                    DC3I2CDataPayloadMsg_read_delimited_from(
                        ((LrgDataEvt *) e)->dataBuf,
                        &(me->payloadMsgUnion.i2cDataPayload),
                        me->basicMsgOffset
                    );
                    break;
                default:
                    WRN_printf(
                        "Unknown payload detected: %d, this is probably an error\n",
                        me->msgPayloadName
                    );
                    break;
            }
            status_ = Q_TRAN(&CommMgr_ValidateMsg);
            break;
        }
        default: {
            status_ = Q_SUPER(&CommMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::CommMgr::SM::Active::Busy} ........................................*/
static QState CommMgr_Busy(CommMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::CommMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Arm the timer so if the message can't be processed for some reason, we can get
             * back to idle state.  This timer may be re-armed if some messages require more
             * time to process than others. */
            QTimeEvt_rearm(
                &me->commMgrTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_MSG_PROCESS )
            );

            /* Compose and send Ack response.  We can re-use the current structure since only
             * one non-essential field changes. */
            me->basicMsg._msgType    = _DC3_Ack;
            me->basicMsg._msgPayload = _DC3NoMsg; // This was saved earlier
            /* The rest of the fields are the same */

            /* Serialize the msg into a buffer of a fresh event. This event will be passed to
             * a function which will post it directly to the correct AO. */
            LrgDataEvt *evt = Q_NEW(LrgDataEvt, CLI_SEND_DATA_SIG);
            /* The src and dst are swapped on purpose since we have to tell the message to go
             * to where it originally came from. */
            evt->dst = me->cliEvtSrc;
            evt->src = me->cliEvtDst;
            evt->dataLen = DC3BasicMsg_write_delimited_to(&(me->basicMsg), evt->dataBuf, 0);
            me->errorCode = Comm_sendToClient( evt );
            if ( ERR_NONE != me->errorCode ) {
                WRN_printf("Possible error sending Ack, attempting to continue. Error: 0x%08x\n", me->errorCode);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->commMgrTimerEvt);                 /* Disarm timer on exit */

            /* Set the fields of the msg common for all Done msgs regardless of status or msg */
            me->basicMsg._msgType    = _DC3_Done;
            me->basicMsg._msgRoute   = me->msgRoute;
            me->basicMsg._msgID      = me->msgId;
            me->basicMsg._msgReqProg = (unsigned long)me->msgReqProg;

            /* The command specific fields should have already been set up by their respective
             * exit transitions */
            LrgDataEvt *evt = Q_NEW(LrgDataEvt, CLI_SEND_DATA_SIG);
            evt->dataLen = DC3BasicMsg_write_delimited_to(&me->basicMsg, evt->dataBuf, 0);
            /* The src and dst are swapped on purpose since we have to tell the message to go
             * to where it originally came from. */
            evt->dst = me->cliEvtSrc;
            evt->src = me->cliEvtDst;
            evt->dataLen = DC3BasicMsg_write_delimited_to(&(me->basicMsg), evt->dataBuf, 0);

            /* Append payload msg if needed */
            switch( me->msgPayloadName ) {
                case _DC3StatusPayloadMsg:
                    evt->dataLen = DC3StatusPayloadMsg_write_delimited_to(
                        (void*)&(me->payloadMsgUnion.statusPayload),
                        evt->dataBuf,
                        evt->dataLen
                    );
                    break;
                case _DC3VersionPayloadMsg:
                    DBG_printf("Sending version payload\n");
                    evt->dataLen = DC3VersionPayloadMsg_write_delimited_to(
                        (void*)&(me->payloadMsgUnion.versionPayload),
                        evt->dataBuf,
                        evt->dataLen
                    );
                    break;
                case _DC3BootModePayloadMsg:
                    DBG_printf("Sending bootMode payload\n");
                    evt->dataLen = DC3BootModePayloadMsg_write_delimited_to(
                        (void*)&(me->payloadMsgUnion.bootmodePayload),
                        evt->dataBuf,
                        evt->dataLen
                    );
                    break;
                case _DC3FlashMetaPayloadMsg:
                    DBG_printf("Sending FlashMeta payload\n");
                    evt->dataLen = DC3FlashMetaPayloadMsg_write_delimited_to(
                        (void*)&(me->payloadMsgUnion.flashMetaPayload),
                        evt->dataBuf,
                        evt->dataLen
                    );
                    break;
                case _DC3FlashDataPayloadMsg:
                    DBG_printf("Sending FlashData payload\n");
                    evt->dataLen = DC3FlashDataPayloadMsg_write_delimited_to(
                        (void*)&(me->payloadMsgUnion.flashDataPayload),
                        evt->dataBuf,
                        evt->dataLen
                    );
                    break;
                case _DC3I2CDataPayloadMsg:
                    DBG_printf("Sending I2CData payload\n");
                    evt->dataLen = DC3I2CDataPayloadMsg_write_delimited_to(
                        (void*)&(me->payloadMsgUnion.i2cDataPayload),
                        evt->dataBuf,
                        evt->dataLen
                    );
                    break;
                case _DC3RamTestPayloadMsg:
                    DBG_printf("Sending RamTest payload\n");
                    evt->dataLen = DC3RamTestPayloadMsg_write_delimited_to(
                        (void*)&(me->payloadMsgUnion.ramTestPayload),
                        evt->dataBuf,
                        evt->dataLen
                    );
                    break;
                case _DC3NoMsg:
                    WRN_printf("Not sending payload as part of Done msg.\n");
                    break;
                default:
                    WRN_printf("Unknown payload detected %d, this is probably an error\n",
                        me->msgPayloadName
                    );
                    break;
            }

            /* Send the Done msg buffer to the client */
            me->errorCode = Comm_sendToClient( evt );
            if ( ERR_NONE != me->errorCode ) {
                WRN_printf("Possible error sending Done, attempting to continue. Error: 0x%08x\n", me->errorCode);
            }

            if ( ERR_NONE != me->errorCode ) {
                WRN_printf("Send Done msg with status: 0x%08x\n", me->errorCode);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::COMM_MGR_TIMEOUT} */
        case COMM_MGR_TIMEOUT_SIG: {
            ERR_printf("COMM_MGR_TIMEOUT trying to process %d basic msg, error: 0x%08x\n",
                me->basicMsg._msgName, me->errorCode);
            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&CommMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief    State that waits for a response from FlashMgr AO.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::CommMgr::SM::Active::Busy::WaitForRespFromF~} .....................*/
static QState CommMgr_WaitForRespFromFlashMgr(CommMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromF~} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->commOpTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_COMM_MSG_FLASH_OP )
            );

            me->errorCode = ERR_COMM_FLASHMGR_TIMEOUT; /* Set the error in case we timeout */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromF~} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->commOpTimerEvt);                  /* Disarm timer on exit */

            if ( ERR_NONE != me->errorCode ) {
                ERR_printf("Leaving state with error: 0x%08x\n", me->errorCode);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromF~::FLASH_OP_DONE} */
        case FLASH_OP_DONE_SIG: {
            me->errorCode = ((FlashStatusEvt const *)e)->errorCode;
            me->payloadMsgUnion.statusPayload._errorCode = me->errorCode;
            if ( ERR_NONE != me->errorCode ) {
                WRN_printf("Got FLASH_OP_DONE with status: 0x%08x\n", me->errorCode);
            }
            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromF~::FLASH_FW_DONE} */
        case FLASH_FW_DONE_SIG: {
            me->errorCode = ((FWMetaEvt const *)e)->errorCode;

            /* Overwrite the done response since the FW flashing is complete; we have to send the
             * metadata back so the client can be happy that we did things correctly.  We can
             * re-use the current structure and it will be used by the exit action of the parent
             * state to send the msg.  Here, we only set up fields that are specific to this
             * response. We can also destructively change the payload name since we are sending
             * a response right after this. */
            me->msgPayloadName = _DC3FlashMetaPayloadMsg;
            me->basicMsg._msgPayload = me->msgPayloadName;

            /* Set up the payload msg here */
            me->payloadMsgUnion.flashMetaPayload._errorCode = me->errorCode;
            me->payloadMsgUnion.flashMetaPayload._imageCrc  = ((FWMetaEvt const *)e)->imageCRC;
            me->payloadMsgUnion.flashMetaPayload._imageMaj  = ((FWMetaEvt const *)e)->imageMaj;
            me->payloadMsgUnion.flashMetaPayload._imageMin  = ((FWMetaEvt const *)e)->imageMin;
            me->payloadMsgUnion.flashMetaPayload._imageSize = ((FWMetaEvt const *)e)->imageSize;
            me->payloadMsgUnion.flashMetaPayload._imageType = ((FWMetaEvt const *)e)->imageType;
            MEMCPY(
                me->payloadMsgUnion.flashMetaPayload._imageDatetime,
                ((FWMetaEvt const *)e)->imageDatetime,
                DC3_DATETIME_LEN
            );

            DBG_printf("Setting flash meta payload with error code: %d\n", me->payloadMsgUnion.flashMetaPayload._errorCode);

            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromF~::COMM_OP_TIMEOUT} */
        case COMM_OP_TIMEOUT_SIG: {
            ERR_printf("COMM_OP_TIMEOUT trying to process %d basic msg, error: 0x%08x\n",
                me->basicMsg._msgName, me->errorCode);
            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromF~::RAM_TEST_DONE} */
        case RAM_TEST_DONE_SIG: {
            me->errorCode = ((RamStatusEvt const *)e)->errorCode;
            me->payloadMsgUnion.ramTestPayload._errorCode = me->errorCode;
            me->payloadMsgUnion.ramTestPayload._test = ((RamStatusEvt const *)e)->test;
            me->payloadMsgUnion.ramTestPayload._addr = ((RamStatusEvt const *)e)->addr;
            if ( ERR_NONE != me->errorCode ) {
                ERR_printf("Got RAM_TEST_DONE with status: 0x%08x\n", me->errorCode);
            }
            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&CommMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief	State that ensures the system stays in the Busy state while processing.
 * This state just self-posts an event to start the msg processing. Its primary
 * reason for existance is to make sure that the state machine ends up inside the
 * busy state for proper error handling (if any occur).
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::CommMgr::SM::Active::Busy::ValidateMsg} ...........................*/
static QState CommMgr_ValidateMsg(CommMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->commOpTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_COMM_MSG_VALIDATE_MSG_OP )
            );

            /* Post to self to leave the state and continue processing the rest of the msg */
            QEvt *evt = Q_NEW(QEvt, MSG_PROCESS_SIG);
            QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_CommMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->commOpTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS} */
        case MSG_PROCESS_SIG: {
            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[GetBootMode?]} */
            if (_DC3GetBootModeMsg == me->basicMsg._msgName) {
                me->errorCode = ERR_NONE;

                DBG_printf("_DC3GetBootModeMsg decoded, attempting to decode payload (if exists)\n");

                /* Compose Done response.  We can re-use the current structure and it will be used by
                 * the exit action of the parent state to send the msg.  Here, we only set up fields
                 * that are specific to this response. We can also destructively change the payload
                 * name since we are sending a response right after this. */
                me->msgPayloadName = _DC3BootModePayloadMsg;

                /* Don't change the basicMsg name since it should be the same in all cases. */
                me->basicMsg._msgPayload = me->msgPayloadName;
                me->payloadMsgUnion.bootmodePayload._errorCode = me->errorCode;
                me->payloadMsgUnion.bootmodePayload._bootMode  = _DC3_Bootloader; // This is the bootloader
                DBG_printf("Setting bootMode payload with bootmode: %d\n", me->payloadMsgUnion.bootmodePayload._bootMode);
                status_ = Q_TRAN(&CommMgr_Idle);
            }
            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]} */
            else if (_DC3SetBootModeMsg == me->basicMsg._msgName) {
                DBG_printf("_DC3SetBootModeMsg decoded, attempting to decode payload (if exists)\n");

                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]} */
                if (_DC3BootModePayloadMsg == me->msgPayloadName) {
                    /* Has to be set after checking for a valid payload */
                    me->msgPayloadName = _DC3StatusPayloadMsg;
                    me->basicMsg._msgPayload = me->msgPayloadName;
                    /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Application?]} */
                    if (_DC3_Application == me->payloadMsgUnion.bootmodePayload._bootMode) {
                        /* Read the application CRC */
                        uint32_t storedCRC = FLASH_readApplCRC();
                        DBG_printf("Stored CRC: 0x%08x\n", storedCRC);
                        /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Application?]::[ValidCRC?]} */
                        if (storedCRC != 0xFFFFFFFF && storedCRC != 0x00000000) {
                            /* Read the application size */
                            uint32_t storedSize = FLASH_readApplSize();
                            DBG_printf("Stored size: 0x%08x\n", storedSize);
                            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Application?]::[ValidCRC?]::[ValidSize?]} */
                            if (storedSize != 0xFFFFFFFF && storedSize != 0x00000000) {
                                CRC_ResetDR();
                                uint32_t crcCheck = CRC32_Calc(
                                    (uint8_t *)FLASH_APPL_START_ADDR,
                                    storedSize
                                );
                                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Application?]::[ValidCRC?]::[ValidSize?]::[CRCmatch?]} */
                                if (crcCheck == storedCRC) {
                                    me->errorCode = ERR_NONE;
                                    LOG_printf("CRC check passed, booting to Application FW image\n");

                                    /* Post to self to boot to application but still have enough time to send a Done */
                                    QEvt *evt = Q_NEW(QEvt, BOOT_APPL_SIG);
                                    QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_CommMgr);
                                    status_ = Q_TRAN(&CommMgr_Idle);
                                }
                                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Application?]::[ValidCRC?]::[ValidSize?]::[else]} */
                                else {
                                    me->errorCode = ERR_COMM_INVALID_APPL_CRC_MISMATCH;
                                    ERR_printf(
                                        "Stored Application CRC (0x%08x) doesn't match calculated (0x%08x). Reflash the Application FW image. Error: 0x%08x\n",
                                        storedCRC, crcCheck, me->errorCode
                                    );
                                    status_ = Q_TRAN(&CommMgr_Idle);
                                }
                            }
                            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Application?]::[ValidCRC?]::[else]} */
                            else {
                                me->errorCode = ERR_COMM_INVALID_APPL_SIZE;
                                ERR_printf("Invalid stored Application FW image size: 0x%08x. Error: 0x%08x\n",
                                    storedSize, me->errorCode);
                                status_ = Q_TRAN(&CommMgr_Idle);
                            }
                        }
                        /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Application?]::[else]} */
                        else {
                            me->errorCode = ERR_COMM_INVALID_APPL_CRC;
                            me->payloadMsgUnion.statusPayload._errorCode = me->errorCode;
                            ERR_printf("Invalid stored Application FW image CRC: 0x%08x. Error: 0x%08x\n", storedCRC, me->errorCode);
                            status_ = Q_TRAN(&CommMgr_Idle);
                        }
                    }
                    /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[Bootloader?]} */
                    else if (_DC3_Bootloader == me->payloadMsgUnion.bootmodePayload._bootMode) {
                        me->errorCode = ERR_NONE;
                        DBG_printf("Already in bootloader mode\n");
                        status_ = Q_TRAN(&CommMgr_Idle);
                    }
                    /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[ValidPayload?]::[else]} */
                    else {
                        me->errorCode = ERR_COMM_INVALID_BOOTMODE_REQUESTED;
                        ERR_printf("Unsupported bootmode requested (%d). Error: 0x%08x\n",
                            me->payloadMsgUnion.bootmodePayload._bootMode, me->errorCode
                        );
                        status_ = Q_TRAN(&CommMgr_Idle);
                    }
                }
                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[SetBootMode?]::[else]} */
                else {
                    /* Has to be set after checking for a valid payload */
                    me->msgPayloadName = _DC3StatusPayloadMsg;
                    me->basicMsg._msgPayload = me->msgPayloadName;

                    me->errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
                    ERR_printf(
                        "Invalid payload for SetBootMode.  Expected BootmodePayload (%d), got (%d). Error: 0x%08x\n",
                        _DC3BootModePayloadMsg, me->msgPayloadName, me->errorCode
                    );

                    status_ = Q_TRAN(&CommMgr_Idle);
                }
            }
            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[Flash?]} */
            else if (_DC3FlashMsg == me->basicMsg._msgName) {
                me->errorCode = ERR_NONE;

                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[Flash?]::[FlashMetaPayloa~} */
                if (_DC3FlashMetaPayloadMsg == me->msgPayloadName) {
                    /* The flash meta payload is the start of the FW update.  The meta payload contains
                     * all the information about the coming fw data.  We need to store this so it can be
                     * used to keep track of the FW flash process. */

                    /* 1. Create a FWMetaEvt and send it along to FlashMgr AO to prep the flash */
                    FWMetaEvt *evt = Q_NEW(FWMetaEvt, FLASH_OP_START_SIG);
                    evt->imageCRC  = me->payloadMsgUnion.flashMetaPayload._imageCrc;
                    evt->imageMaj  = me->payloadMsgUnion.flashMetaPayload._imageMaj;
                    evt->imageMin  = me->payloadMsgUnion.flashMetaPayload._imageMin;
                    evt->imageSize = me->payloadMsgUnion.flashMetaPayload._imageSize;
                    evt->imageType = me->payloadMsgUnion.flashMetaPayload._imageType;
                    evt->imageNumPackets = me->payloadMsgUnion.flashMetaPayload._imageNumPackets;

                    evt->imageDatetimeLen = me->payloadMsgUnion.flashMetaPayload._imageDatetime_len;
                    MEMCPY(
                        evt->imageDatetime,
                        me->payloadMsgUnion.flashMetaPayload._imageDatetime,
                        evt->imageDatetimeLen
                    );
                    QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_CommMgr);

                    /* Compose Done response.  We can re-use the current structure and it will be used by
                     * the exit action of the parent state to send the msg.  Here, we only set up fields
                     * that are specific to this response. We can also destructively change the payload
                     * name since we are sending a response right after this. */
                    me->msgPayloadName = _DC3StatusPayloadMsg;

                    /* Don't change the basicMsg name since it should be the same in all cases. */
                    me->basicMsg._msgPayload = me->msgPayloadName;
                    status_ = Q_TRAN(&CommMgr_WaitForRespFromFlashMgr);
                }
                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[Flash?]::[FlashDataPayloa~} */
                else if (_DC3FlashDataPayloadMsg == me->msgPayloadName) {
                    /* The flash data payload is used to transfer the FW data packets to FlashMgr AO. */

                    /* 1. Create a FWMetaEvt and send it along to FlashMgr AO to prep the flash */
                    FWDataEvt *evt = Q_NEW(FWDataEvt, FLASH_DATA_SIG);
                    evt->dataCRC  = me->payloadMsgUnion.flashDataPayload._dataCrc;
                    evt->dataLen  = me->payloadMsgUnion.flashDataPayload._dataBuf_len;
                    evt->seqCurr  = me->payloadMsgUnion.flashDataPayload._seqCurr;
                    MEMCPY(
                        evt->dataBuf,
                        me->payloadMsgUnion.flashDataPayload._dataBuf,
                        evt->dataLen
                    );
                    QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_CommMgr);

                    /* Compose Done response.  We can re-use the current structure and it will be used by
                     * the exit action of the parent state to send the msg.  Here, we only set up fields
                     * that are specific to this response. We can also destructively change the payload
                     * name since we are sending a response right after this. */
                    me->msgPayloadName = _DC3StatusPayloadMsg;

                    /* Don't change the basicMsg name since it should be the same in all cases. */
                    me->basicMsg._msgPayload = me->msgPayloadName;
                    status_ = Q_TRAN(&CommMgr_WaitForRespFromFlashMgr);
                }
                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[Flash?]::[else]} */
                else {
                    me->errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
                    WRN_printf("Unexpected payload %d for FlashMsg. Error: 0x%08x\n",
                        me->msgPayloadName, me->errorCode);
                    status_ = Q_TRAN(&CommMgr_Idle);
                }
            }
            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[I2CRead?]} */
            else if (_DC3I2CReadMsg == me->basicMsg._msgName) {
                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[I2CRead?]::[ValidPayload?]} */
                if (_DC3I2CDataPayloadMsg == me->msgPayloadName) {
                    /* Has to be set after checking for a valid payload */
                    me->msgPayloadName = _DC3I2CDataPayloadMsg;
                    me->basicMsg._msgPayload = me->msgPayloadName;

                    /* Create the event and directly post it to the right AO. */
                    I2CReadReqEvt *i2cReadReqEvt  = Q_NEW(I2CReadReqEvt, I2C1_DEV_RAW_MEM_READ_SIG);
                    i2cReadReqEvt->i2cDev         = me->payloadMsgUnion.i2cDataPayload._i2cDev;
                    i2cReadReqEvt->addr           = I2C_getMemAddr( i2cReadReqEvt->i2cDev ) + me->payloadMsgUnion.i2cDataPayload._start;
                    i2cReadReqEvt->bytes          = me->payloadMsgUnion.i2cDataPayload._nBytes;
                    i2cReadReqEvt->accessType     = me->payloadMsgUnion.i2cDataPayload._accType;
                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cReadReqEvt), me);
                    status_ = Q_TRAN(&CommMgr_WaitForRespFromI2C);
                }
                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[I2CRead?]::[else]} */
                else {
                    me->errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
                    WRN_printf("Unexpected payload %d for I2CReadMsg. Error: 0x%08x\n",
                        me->msgPayloadName, me->errorCode);
                    status_ = Q_TRAN(&CommMgr_Idle);
                }
            }
            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[I2CWrite?]} */
            else if (_DC3I2CWriteMsg == me->basicMsg._msgName) {
                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[I2CWrite?]::[ValidPayload?]} */
                if (_DC3I2CDataPayloadMsg == me->msgPayloadName) {
                    /* Has to be set after checking for a valid payload */
                    me->msgPayloadName = _DC3StatusPayloadMsg;
                    me->basicMsg._msgPayload = me->msgPayloadName;

                    /* Create the event and directly post it to the right AO. */
                    I2CWriteReqEvt *i2cWriteReqEvt  = Q_NEW(I2CWriteReqEvt, I2C1_DEV_RAW_MEM_WRITE_SIG);
                    i2cWriteReqEvt->i2cDev         = me->payloadMsgUnion.i2cDataPayload._i2cDev;
                    i2cWriteReqEvt->addr           = I2C_getMemAddr( i2cWriteReqEvt->i2cDev ) + me->payloadMsgUnion.i2cDataPayload._start;
                    i2cWriteReqEvt->accessType     = me->payloadMsgUnion.i2cDataPayload._accType;
                    i2cWriteReqEvt->bytes          = me->payloadMsgUnion.i2cDataPayload._nBytes;
                    MEMCPY(
                        i2cWriteReqEvt->dataBuf,
                        me->payloadMsgUnion.i2cDataPayload._dataBuf,
                        me->payloadMsgUnion.i2cDataPayload._dataBuf_len
                    );

                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cWriteReqEvt), me);

                    status_ = Q_TRAN(&CommMgr_WaitForRespFromI2C);
                }
                /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[I2CWrite?]::[else]} */
                else {
                    /* Has to be set after checking for a valid payload */
                    me->msgPayloadName = _DC3StatusPayloadMsg;
                    me->basicMsg._msgPayload = me->msgPayloadName;

                    me->errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
                    WRN_printf("Unexpected payload %d for I2CWriteMsg. Error: 0x%08x\n",
                        me->msgPayloadName, me->errorCode);
                    status_ = Q_TRAN(&CommMgr_Idle);
                }
            }
            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[RamTest?]} */
            else if (_DC3RamTestMsg == me->basicMsg._msgName) {
                me->errorCode = ERR_NONE;

                DBG_printf("_DC3RamTestMsg decoded, not expecting any payload\n");

                /* Compose Done response.  We can re-use the current structure and it will be used by
                 * the exit action of the parent state to send the msg.  Here, we only set up fields
                 * that are specific to this response. We can also destructively change the payload
                 * name since we are sending a response right after this. */
                me->msgPayloadName = _DC3RamTestPayloadMsg;

                /* Don't change the basicMsg name since it should be the same in all cases. */
                me->basicMsg._msgPayload = me->msgPayloadName;
                //me->payloadMsgUnion.ramTestPayload._errorCode = me->errorCode;

                QEvt *evt = Q_NEW(QEvt, RAM_TEST_START_SIG);
                QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_CommMgr);

                status_ = Q_TRAN(&CommMgr_WaitForRespFromFlashMgr);
            }
            /* ${AOs::CommMgr::SM::Active::Busy::ValidateMsg::MSG_PROCESS::[else]} */
            else {
                me->errorCode = ERR_MSG_UNKNOWN_BASIC;
                ERR_printf(
                    "Unknown msg (%d) with msgId=%d. Sending back error: 0x%08x\n",
                    me->basicMsg._msgName, me->msgId, me->errorCode);

                /* Compose Done response.  We can re-use the current structure and it will be used by
                 * the exit action of the parent state to send the msg.  Here, we only set up fields
                 * that are specific to this response. We can also destructively change the payload
                 * name since we are sending a response right after this. */
                me->msgPayloadName = _DC3StatusPayloadMsg;

                /* Don't change the basicMsg name since we don't actually know what it is but add a
                 * status payload msg to let the user know the error. */
                me->basicMsg._msgPayload = me->msgPayloadName;
                me->payloadMsgUnion.statusPayload._errorCode = me->errorCode;



                status_ = Q_TRAN(&CommMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&CommMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    State that waits for a response from I2C1DevMgr AO.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::CommMgr::SM::Active::Busy::WaitForRespFromI~} .....................*/
static QState CommMgr_WaitForRespFromI2C(CommMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromI~} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->commOpTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_CLI_WAIT_FOR_SIMPLE_MSG_DONE )
            );

            me->errorCode = ERR_COMM_I2C_READ_CMD_TIMEOUT; /* Set the error in case we timeout */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromI~} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->commOpTimerEvt);                  /* Disarm timer on exit */

            if ( ERR_NONE != me->errorCode ) {
                ERR_printf("Leaving state with error: 0x%08x\n", me->errorCode);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromI~::COMM_OP_TIMEOUT} */
        case COMM_OP_TIMEOUT_SIG: {
            ERR_printf("COMM_OP_TIMEOUT trying to process %d basic msg, error: 0x%08x\n",
                me->basicMsg._msgName, me->errorCode);
            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromI~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                DBG_printf("Got I2C1_DEV_READ_DONE with %d bytes\n", ((I2CReadDoneEvt const *) e)->bytes);
                me->payloadMsgUnion.i2cDataPayload._dataBuf_len = ((I2CReadDoneEvt const *) e)->bytes;
                MEMCPY(
                    me->payloadMsgUnion.i2cDataPayload._dataBuf,
                    ((I2CReadDoneEvt const *) e)->dataBuf,
                    me->payloadMsgUnion.i2cDataPayload._dataBuf_len
                );
            }

            me->payloadMsgUnion.i2cDataPayload._errorCode = me->errorCode;
            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        /* ${AOs::CommMgr::SM::Active::Busy::WaitForRespFromI~::I2C1_DEV_WRITE_D~} */
        case I2C1_DEV_WRITE_DONE_SIG: {
            me->errorCode = ((I2CWriteDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                DBG_printf("Got I2C1_DEV_WRITE_DONE with %d bytes\n", ((I2CWriteDoneEvt const *) e)->bytes);
            }

            me->payloadMsgUnion.statusPayload._errorCode = me->errorCode;
            status_ = Q_TRAN(&CommMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&CommMgr_Busy);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupComm
 */

/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/
