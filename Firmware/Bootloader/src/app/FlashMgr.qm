<?xml version="1.0" encoding="UTF-8"?>
<model version="3.2.2">
 <documentation>/**
 * CommStackMgr Active Object which.  This AO handles all communications work.
 */</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="FWDataEvt" superclass="qpc::QEvt">
   <documentation>/**&lt; Event type that allows transport of FW data */</documentation>
   <attribute name="dataCRC" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW Data packet CRC */</documentation>
   </attribute>
   <attribute name="dataLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data buffer */</documentation>
   </attribute>
   <attribute name="dataBuf[DC3_MAX_MSG_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Data buffer */</documentation>
   </attribute>
   <attribute name="seqCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW data packet sequence number */</documentation>
   </attribute>
  </class>
  <class name="FWMetaEvt" superclass="qpc::QEvt">
   <documentation>/**&lt; Event type that transports metadata about the FW upgrade */</documentation>
   <attribute name="imageCRC" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image CRC */</documentation>
   </attribute>
   <attribute name="imageSize" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image size */</documentation>
   </attribute>
   <attribute name="imageType" type="DC3BootMode_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image type */</documentation>
   </attribute>
   <attribute name="imageMaj" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image major version number */</documentation>
   </attribute>
   <attribute name="imageMin" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image minor version number */</documentation>
   </attribute>
   <attribute name="imageDatetime[DC3_DATETIME_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image datetime */</documentation>
   </attribute>
   <attribute name="imageDatetimeLen" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image datetime length */</documentation>
   </attribute>
   <attribute name="errorCode" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the FW flash completion.  Only used when sending back from FlashMgr */</documentation>
   </attribute>
   <attribute name="imageNumPackets" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Total number of FW data packets expected */</documentation>
   </attribute>
  </class>
  <class name="FlashStatusEvt" superclass="qpc::QEvt">
   <documentation>/**&lt; Event type that transports metadata about the FW upgrade */</documentation>
   <attribute name="errorCode" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the FlashMgr operation completion. */</documentation>
   </attribute>
  </class>
  <class name="RamStatusEvt" superclass="qpc::QEvt">
   <documentation>/**&lt; Event type that transports data about the RAM test */</documentation>
   <attribute name="errorCode" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the RAM operation. */</documentation>
   </attribute>
   <attribute name="test" type="DC3RamTest_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which test is running if no error or failed if error. */</documentation>
   </attribute>
   <attribute name="addr" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Address where the test is running if no error or failed at if error. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="FlashMgr" superclass="qpc::QActive">
   <documentation>/**
 * \brief FlashMgr &quot;class&quot;
 */</documentation>
   <attribute name="msgRoute" type="DC3MsgRoute_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keeps track of where the message came from */</documentation>
   </attribute>
   <attribute name="reqProg" type="bool" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of whether Prog responses were requested by the sender of the msg */</documentation>
   </attribute>
   <attribute name="errorCode" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of errors that may occur in the AO */</documentation>
   </attribute>
   <attribute name="fwFlashMetadata" type="struct DC3FlashMetaPayloadMsg" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Common struct for DC3BasicMsg.  This can be re-used in most cases since once the
 * request has been unwrapped, all the data from that struct has been stored locally */</documentation>
   </attribute>
   <attribute name="fwPacketExp" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; How many total FW data packets to expect */</documentation>
   </attribute>
   <attribute name="fwPacketCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; How many total FW data packets to expect */</documentation>
   </attribute>
   <attribute name="flashAddrCurr" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the current flash address */</documentation>
   </attribute>
   <attribute name="retryCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Counter for retries */</documentation>
   </attribute>
   <attribute name="flashSectorsToErase[ADDR_FLASH_SECTORS]" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW flash sectors to erase */</documentation>
   </attribute>
   <attribute name="flashSectorsToEraseNum" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; How many flash sectors to erase (how many are in the flashSectorsToErase array) */</documentation>
   </attribute>
   <attribute name="flashSectorsToEraseIndex" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Index into the flashSectorsToErase array for when we are erasing flash */</documentation>
   </attribute>
   <attribute name="flashTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Used for timing out the entire FW upgrade process in FlashMgr object. */</documentation>
   </attribute>
   <attribute name="flashOpTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Used for timing out individual operations on flash in FlashMgr object. */</documentation>
   </attribute>
   <attribute name="fwDataToFlash[112]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer with FW data to flash */</documentation>
   </attribute>
   <attribute name="fwDataToFlashLen" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in fwDataToFlash buffer */</documentation>
   </attribute>
   <attribute name="ramTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Used for timing out the Ram test in case it gets stuck for some reason. */</documentation>
   </attribute>
   <attribute name="currRamTest" type="DC3RamTest_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Which test is running. */</documentation>
   </attribute>
   <attribute name="currRamAddr" type="__IO uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Address where the test is running if no error or failed at if error. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/0">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_CommMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;CommMgr_initial);
QS_FUN_DICTIONARY(&amp;CommMgr_Active);

QS_FUN_DICTIONARY(&amp;CommMgr_Idle);
QS_FUN_DICTIONARY(&amp;CommMgr_Busy);
QS_FUN_DICTIONARY(&amp;CommMgr_PrepFlash);
QS_FUN_DICTIONARY(&amp;CommMgr_WaitingForFWData);
QS_FUN_DICTIONARY(&amp;CommMgr_WritingFlash);
QS_FUN_DICTIONARY(&amp;CommMgr_FinalizingFlash);

QActive_subscribe((QActive *)me, FLASH_OP_START_SIG);
QActive_subscribe((QActive *)me, FLASH_DATA_SIG);
QActive_subscribe((QActive *)me, FLASH_DONE_SIG);
QActive_subscribe((QActive *)me, FLASH_ERROR_SIG);
QActive_subscribe((QActive *)me, FLASH_TIMEOUT_SIG);</action>
     <initial_glyph conn="1,2,4,3,9,5">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Arm and disarm*/
QTimeEvt_postIn(
    &amp;me-&gt;flashTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
);
QTimeEvt_disarm(&amp;me-&gt;flashTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;flashOpTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
);
QTimeEvt_disarm(&amp;me-&gt;flashOpTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;ramTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
);
QTimeEvt_disarm(&amp;me-&gt;ramTimerEvt);</entry>
     <state name="Idle">
      <documentation>/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Clear out all the variables on entry to Idle state.  By this point, any error
 * feedback should have already happened. */
me-&gt;errorCode       = ERR_NONE;
me-&gt;msgRoute        = _DC3_NoRoute;
me-&gt;reqProg         = false;

memset(&amp;me-&gt;fwFlashMetadata, 0, sizeof(me-&gt;fwFlashMetadata));
me-&gt;currRamTest = _DC3_RAM_TEST_NONE;
me-&gt;currRamAddr = 0;</entry>
      <tran trig="FLASH_OP_START" target="../../1/2">
       <action>DBG_printf(&quot;FLASH_OP_START\n&quot;);

/* Get the metadata and record it.  Ignore the status  */
me-&gt;fwFlashMetadata._imageCrc  = ((FWMetaEvt const *)e)-&gt;imageCRC;
me-&gt;fwFlashMetadata._imageMaj  = ((FWMetaEvt const *)e)-&gt;imageMaj;
me-&gt;fwFlashMetadata._imageMin  = ((FWMetaEvt const *)e)-&gt;imageMin;
me-&gt;fwFlashMetadata._imageSize = ((FWMetaEvt const *)e)-&gt;imageSize;
me-&gt;fwFlashMetadata._imageType = ((FWMetaEvt const *)e)-&gt;imageType;
me-&gt;fwFlashMetadata._imageNumPackets = ((FWMetaEvt const *)e)-&gt;imageNumPackets;
me-&gt;fwFlashMetadata._imageDatetime_len = ((FWMetaEvt const *)e)-&gt;imageDatetimeLen;
MEMCPY(
    me-&gt;fwFlashMetadata._imageDatetime,
    ((FWMetaEvt const *)e)-&gt;imageDatetime,
    me-&gt;fwFlashMetadata._imageDatetime_len
);
</action>
       <tran_glyph conn="6,16,3,3,40">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <tran trig="RAM_TEST_START" target="../../2/3">
       <tran_glyph conn="6,106,3,3,40">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="6,8,15,114">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="BusyFlash">
      <documentation>/**
 * @brief	Busy state for flash operation processing.
 * This state handles flash operation processing and indicates that the system 
 * is busy and cannot process another req at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Arm the timer so if the message can't be processed for some reason, we can get
 * back to idle state.  This timer may be re-armed if some messages require more 
 * time to process than others. */
QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;flashTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
);

FLASH_Unlock();/* Always unlock the flash on entry since we'll be doing stuff to it */

/* Reset all the variables that keep track of FW upgrades on entry so they are 
 * guaranteed to be cleared when we start any new operation */
memset( me-&gt;flashSectorsToErase, 0, sizeof(me-&gt;flashSectorsToErase) );
me-&gt;flashSectorsToEraseIndex = 0;
me-&gt;flashSectorsToEraseNum = 0;
me-&gt;fwPacketCurr = 0;
me-&gt;fwPacketExp  = 0;
me-&gt;retryCurr    = 0;</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;flashTimerEvt); /* Disarm timer on exit */

FLASH_Lock();     /* Always lock the flash on exit */

/* Always send a flash status event to the CommMgr AO with the current error code */
FlashStatusEvt *evt = Q_NEW(FlashStatusEvt, FLASH_OP_DONE_SIG);
evt-&gt;errorCode = me-&gt;errorCode;
QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_FlashMgr);</exit>
      <tran trig="FLASH_TIMEOUT" target="../../0">
       <action>ERR_printf(&quot;Timeout trying to process flash request, error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
       <tran_glyph conn="42,86,3,1,-21">
        <action box="-14,-2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="FLASH_ERROR" target="../../0">
       <action>ERR_printf(&quot;Unable to to process flash request. Error: 0x%08x\n&quot;, me-&gt;errorCode);
</action>
       <tran_glyph conn="42,83,3,1,-21">
        <action box="-14,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state name="PrepFlash">
       <documentation>/**
 * @brief    Prepares flash memory for flashing
 * This state is responsible for erasing the appropriate sections of the Flash.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>/* Self post an event to keep going.  The reason this is done is so that we can use
 * common error handling of the parent state to report errors back to CommMgr instead
 * of having to manually port events whenever an error occurs.*/
QEvt *evt = Q_NEW(QEvt, FLASH_NEXT_STEP_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
</entry>
       <tran trig="FLASH_NEXT_STEP">
        <action>DBG_printf(&quot;FLASH_NEXT_STEP\n&quot;);

LOG_printf(&quot;Extracted FW image metadata:\n&quot;);
LOG_printf(&quot;CRC: 0x%08x\n&quot;, me-&gt;fwFlashMetadata._imageCrc);
LOG_printf(&quot;Maj: %02d\n&quot;, me-&gt;fwFlashMetadata._imageMaj);
LOG_printf(&quot;Min: %02d\n&quot;, me-&gt;fwFlashMetadata._imageMin);
LOG_printf(&quot;Size: %d\n&quot;, me-&gt;fwFlashMetadata._imageSize);
LOG_printf(&quot;Type: %d\n&quot;, me-&gt;fwFlashMetadata._imageType);
LOG_printf(&quot;Datetime: %s\n&quot;, me-&gt;fwFlashMetadata._imageDatetime);
LOG_printf(&quot;Number of packets: %d\n&quot;, me-&gt;fwFlashMetadata._imageNumPackets);

/* Do some sanity checking on the FW image metadata */
me-&gt;errorCode = FLASH_validateMetadata(&amp;(me-&gt;fwFlashMetadata));</action>
        <choice>
         <guard brief="MetadataValid?">ERR_NONE == me-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Finding flash sectors to erase.\n&quot;);

me-&gt;errorCode = FLASH_getSectorsToErase(
    me-&gt;flashSectorsToErase,
    &amp;(me-&gt;flashSectorsToEraseNum),
    ADDR_FLASH_SECTORS,
    me-&gt;fwFlashMetadata._imageType,
    me-&gt;fwFlashMetadata._imageSize
);

/* Set the start address which will get used later when the fw packets start coming in*/
if (me-&gt;fwFlashMetadata._imageType == _DC3_Application ) {
    me-&gt;flashAddrCurr = FLASH_APPL_START_ADDR;
    me-&gt;fwPacketExp   = me-&gt;fwFlashMetadata._imageNumPackets;
    DBG_printf(&quot;Expecting %d FW data packets\n&quot;, me-&gt;fwPacketExp);
} else {
    me-&gt;errorCode = ERR_FLASH_IMAGE_TYPE_INVALID;
    ERR_printf(&quot;FW image type %d currently not supported for FW upgrades, error: 0x%08x\n&quot;,
        me-&gt;fwFlashMetadata._imageType, me-&gt;errorCode);
}</action>
         <choice target="../../../2">
          <guard brief="SectorsValid?">ERR_NONE == me-&gt;errorCode &amp;&amp; me-&gt;flashSectorsToEraseNum &gt; 1</guard>
          <action>LOG_printf(&quot;List of %d sectors (by address) to erase:\n&quot;, me-&gt;flashSectorsToEraseNum);
for( uint8_t i=0; i &lt; me-&gt;flashSectorsToEraseNum; i++ ) {
    LOG_printf(&quot;Sector at address at 0x%08x\n&quot;, me-&gt;flashSectorsToErase[i]);
}</action>
          <choice_glyph conn="77,19,5,0,17,2">
           <action box="1,-2,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <action>ERR_printf(&quot;Unable to get a list of sectors to erase. Error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
          <choice_glyph conn="77,19,4,1,5,-56">
           <action box="-7,3,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="64,19,5,-1,13">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard>else</guard>
         <action>ERR_printf(&quot;FW image metadata failed validation with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
         <choice_glyph conn="64,19,4,1,3,-43">
          <action box="-6,3,5,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="46,19,3,-1,18">
         <action box="1,-2,14,2"/>
        </tran_glyph>
       </tran>
       <tran trig="FLASH_OP_TIMEOUT" target="../../../0">
        <action>/* Override whatever error since the timeout interrupted whatever was happening. */
me-&gt;errorCode = ERR_FLASH_ERASE_TIMEOUT;
ERR_printf(&quot;Timed out while preparing flash for FW update. Error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
        <tran_glyph conn="46,27,3,1,-25">
         <action box="-21,-2,16,2"/>
        </tran_glyph>
       </tran>
       <state name="ErasingSector">
        <documentation>/**
 * @brief    Waits while a sector of flash is erased
 * This state is responsible for initializing the erasure of a sector and waiting
 * until the operation is complete.  A timeout may occur during this time and an 
 * error will be reported.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;flashOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_SECTOR_ERASE )
);

DBG_printf(&quot;Attempting to erase sector addr 0x%08x\n&quot;,
    me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]);

/* Use a separate status variable so if a timeout occurs, the timeout error won't get
 * overwritten */
me-&gt;errorCode = FLASH_eraseSector(
    me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]
);

/* Post event to move to the next step only AFTER the blocking call to 
 * FLASH_eraseSector() returns */
QEvt *evt = Q_NEW(QEvt, FLASH_NEXT_STEP_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;flashOpTimerEvt); /* Disarm timer on exit */</exit>
        <tran trig="FLASH_NEXT_STEP">
         <choice>
          <guard brief="EraseOK?">ERR_NONE == me-&gt;errorCode</guard>
          <action>DBG_printf(&quot;Successfully erased sector addr 0x%08x\n&quot;,
    me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]);

me-&gt;flashSectorsToEraseIndex += 1; /* increment the index into the erase array */
</action>
          <choice target="../../..">
           <guard brief="MoreToErase?">me-&gt;flashSectorsToEraseIndex &lt; me-&gt;flashSectorsToEraseNum</guard>
           <choice_glyph conn="97,39,5,1,11,-13,-4">
            <action box="1,0,10,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../3">
           <guard>else</guard>
           <choice_glyph conn="97,39,5,0,-42,8">
            <action box="-8,-2,5,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="97,33,4,-1,6">
           <action box="0,1,10,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard>else</guard>
          <action>WRN_printf(&quot;Failed to erase flash sector 0x%08x\n&quot;, me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]);</action>
          <choice target="../../..">
           <guard brief="retry?">me-&gt;retryCurr &lt; MAX_FLASH_RETRIES</guard>
           <action>me-&gt;retryCurr += 1; /* Increment retry counter */
WRN_printf(&quot;Attempting operation again (retry %d out of %d)...\n&quot;, me-&gt;retryCurr, MAX_FLASH_RETRIES);</action>
           <choice_glyph conn="73,33,4,3,-7,10">
            <action box="0,-4,7,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../0">
           <guard>else</guard>
           <action>ERR_printf(&quot;No more retries, aborting with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
           <choice_glyph conn="73,33,5,1,-52">
            <action box="-8,0,6,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="97,33,5,-1,-24">
           <action box="-9,-2,5,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="83,29,3,-1,14,4">
          <action box="0,-2,14,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="83,21,21,9">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="46,13,66,29">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitingForFWData">
       <documentation>/**
 * @brief    Requests and waits for FW data packets
 * This state is responsible for:
 * 1. Requesting a FW data packet from CommMgr.
 * 2. Waiting (with a timeout) to receive the packet.
 * 3. Validating the packet
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>/* Ok, we are ready to receive FW data and start flashing. Post an event letting
 * CommMgr know we are ready for a data packet. */
FlashStatusEvt *evt = Q_NEW(FlashStatusEvt, FLASH_OP_DONE_SIG);
evt-&gt;errorCode = me-&gt;errorCode;
QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_FlashMgr);

me-&gt;errorCode = ERR_FLASH_WAIT_FOR_DATA_TIMEOUT; /* Set the timeout error code*/

QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;flashOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_WAIT_FOR_DATA )
);

</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;flashOpTimerEvt); /* Disarm timer on exit */</exit>
       <tran trig="FLASH_DATA">
        <choice>
         <guard brief="ValidSeq?">me-&gt;fwPacketCurr + 1 == ((FWDataEvt const *)e)-&gt;seqCurr</guard>
         <action>/* Calculate packet data CRC and make sure it matches the one sent over */
CRC_ResetDR();
uint32_t CRCValue = CRC32_Calc(((FWDataEvt const *)e)-&gt;dataBuf, ((FWDataEvt const *)e)-&gt;dataLen);</action>
         <choice target="../../../../4">
          <guard brief="ValidCRC?">CRCValue == ((FWDataEvt const *)e)-&gt;dataCRC</guard>
          <action>me-&gt;fwDataToFlashLen = ((FWDataEvt const *)e)-&gt;dataLen;
MEMCPY(
    me-&gt;fwDataToFlash,
    ((FWDataEvt const *)e)-&gt;dataBuf,
    me-&gt;fwDataToFlashLen
);</action>
          <choice_glyph conn="58,64,5,3,19,-14,9">
           <action box="1,0,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_FLASH_INVALID_FW_PACKET_CRC;
ERR_printf(
    &quot;Sent CRC (0x%08x) doesn't match calculated (0x%08x) for fw packet: %d. Error: 0x%08x\n&quot;,
    CRCValue, ((FWDataEvt const *)e)-&gt;dataCRC, ((FWDataEvt const *)e)-&gt;seqCurr, me-&gt;errorCode);
</action>
          <choice_glyph conn="58,64,5,1,-37">
           <action box="-7,-2,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="58,59,4,-1,5">
          <action box="0,1,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard>else</guard>
         <action>ERR_printf(&quot;Invalid fw packet sequence number. Expecting: %d, got %d\n&quot;, me-&gt;fwPacketCurr + 1, ((FWDataEvt const *)e)-&gt;seqCurr);</action>
         <choice_glyph conn="58,59,5,1,-37">
          <action box="-7,-2,5,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="46,55,3,-1,12,4">
         <action box="0,-2,11,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="46,47,26,9">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WritingFlash">
       <documentation>/**
 * @brief    Writes and verifies received flash data packet to Flash memory.
 * This state is responsible for:
 * 1. Writing the data packet to flash memory at the location necessary.
 * 2. Reading back the flash memory and verifying it was written correctly.
 * 3. Checking if more packets are needed.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>me-&gt;errorCode = ERR_FLASH_WRITE_TIMEOUT; /* Set the timeout error code*/
if ( (me-&gt;fwPacketCurr + 1) % 100 == 0 ) {
    DBG_printf(&quot;Writing FW data packet %d of %d total.\n&quot;, me-&gt;fwPacketCurr + 1, me-&gt;fwFlashMetadata._imageNumPackets);
}

QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;flashOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_DATA_WRITE )
);

uint16_t bytesWritten = 0;
DC3Error_t err = FLASH_writeBuffer(
      me-&gt;flashAddrCurr,
      me-&gt;fwDataToFlash,
      me-&gt;fwDataToFlashLen,
      &amp;bytesWritten
);

me-&gt;errorCode = err;

if( ERR_NONE != err || bytesWritten != me-&gt;fwDataToFlashLen) { /* Error occurred */
    WRN_printf(&quot;Error flashing data: 0x%08x\n&quot;, me-&gt;errorCode);
    QEvt *evt = Q_NEW(QEvt, FLASH_ERROR_SIG);
    QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
} else {                                                            /* No errors */
    /* Increment addr and counters */
    me-&gt;flashAddrCurr += bytesWritten;
    me-&gt;fwPacketCurr += 1;
    QEvt *evt = Q_NEW(QEvt, FLASH_DONE_SIG);
    QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
}</entry>
       <tran trig="FLASH_DONE">
        <choice target="../../../3">
         <guard brief="MorePackets?">me-&gt;fwPacketCurr != me-&gt;fwPacketExp</guard>
         <choice_glyph conn="116,54,4,0,-9,-52,2">
          <action box="0,-5,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard>else</guard>
         <action>DBG_printf(&quot;No more fw packets expected\n&quot;);
/* Do a check of the FW image and compare all the CRCs and sizes */
CRC_ResetDR();
uint32_t crcCheck = CRC32_Calc(
    (uint8_t *)FLASH_APPL_START_ADDR,
    me-&gt;fwFlashMetadata._imageSize
);</action>
         <choice>
          <guard brief="CRCMatch?">me-&gt;fwFlashMetadata._imageCrc == crcCheck</guard>
          <action>DBG_printf(&quot;CRCs of the FW image match, writing metadata...\n&quot;);
me-&gt;errorCode = FLASH_writeApplSize( me-&gt;fwFlashMetadata._imageSize );</action>
          <choice>
           <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
           <action>me-&gt;errorCode = FLASH_writeApplCRC( me-&gt;fwFlashMetadata._imageCrc );</action>
           <choice>
            <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
            <action>me-&gt;errorCode = FLASH_writeApplMajVer( me-&gt;fwFlashMetadata._imageMaj );</action>
            <choice target="../../../../../../../../0">
             <guard>else</guard>
             <action>ERR_printf(&quot;Unable to write image Major Version after flashing. Error: 0x%08x.\n&quot;, me-&gt;errorCode);</action>
             <choice_glyph conn="116,82,5,1,-9,-9,-86">
              <action box="-5,-2,5,2"/>
             </choice_glyph>
            </choice>
            <choice>
             <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
             <action>me-&gt;errorCode = FLASH_writeApplMinVer( me-&gt;fwFlashMetadata._imageMin );</action>
             <choice target="../../../../../../../../../0">
              <guard>else</guard>
              <action>ERR_printf(&quot;Unable to write image Minor Version after flashing. Error: 0x%08x.\n&quot;, me-&gt;errorCode);</action>
              <choice_glyph conn="116,86,5,1,-10,-12,-85">
               <action box="-5,-2,5,2"/>
              </choice_glyph>
             </choice>
             <choice>
              <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
              <action>me-&gt;errorCode = FLASH_writeApplBuildDatetime(
    (uint8_t *)me-&gt;fwFlashMetadata._imageDatetime,
    me-&gt;fwFlashMetadata._imageDatetime_len
);</action>
              <choice target="../../../../../../../../../../0">
               <guard>else</guard>
               <action>ERR_printf(&quot;Unable to write image build datetime after flashing. Error: 0x%08x.\n&quot;, me-&gt;errorCode);</action>
               <choice_glyph conn="116,90,5,1,-11,-15,-84">
                <action box="-5,-2,5,2"/>
               </choice_glyph>
              </choice>
              <choice target="../../../../../../../../../../0">
               <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
               <action>LOG_printf(&quot;Successfully finished upgrading FW!\n&quot;);</action>
               <choice_glyph conn="116,90,4,1,4,-14,-16,-81">
                <action box="0,0,10,2"/>
               </choice_glyph>
              </choice>
              <choice_glyph conn="116,86,4,-1,4">
               <action box="0,0,7,2"/>
              </choice_glyph>
             </choice>
             <choice_glyph conn="116,82,4,-1,4">
              <action box="0,0,7,2"/>
             </choice_glyph>
            </choice>
            <choice_glyph conn="116,78,4,-1,4">
             <action box="0,0,7,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../0">
            <guard>else</guard>
            <action>ERR_printf(&quot;Unable to write image CRC after flashing. Error: 0x%08x.\n&quot;, me-&gt;errorCode);</action>
            <choice_glyph conn="116,78,5,1,-8,-6,-87">
             <action box="-5,-2,5,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="116,74,4,-1,4">
            <action box="0,0,8,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../0">
           <guard>else</guard>
           <action>ERR_printf(&quot;Unable to write image size after flashing. Error: 0x%08x.\n&quot;, me-&gt;errorCode);</action>
           <choice_glyph conn="116,74,5,1,-7,-3,-88">
            <action box="-5,-2,5,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="116,70,4,-1,4">
           <action box="0,0,8,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_FLASH_INVALID_IMAGE_CRC_AFTER_FLASH;
ERR_printf(&quot;CRC check failed after flash. Error: 0x%08x.\n&quot;, me-&gt;errorCode);
ERR_printf(&quot;Expected  : 0x%08x\n&quot;, me-&gt;fwFlashMetadata._imageCrc);
ERR_printf(&quot;Calculated: 0x%08x\n&quot;, crcCheck);</action>
          <choice_glyph conn="116,70,5,1,-95">
           <action box="-5,-2,5,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="116,54,4,-1,16">
          <action box="0,2,5,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="86,54,3,-1,30">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="FLASH_ERROR">
        <action>WRN_printf(&quot;FLASH_ERROR\n&quot;);</action>
        <choice target="../..">
         <guard brief="RetriesLeft?">me-&gt;retryCurr &lt; MAX_FLASH_RETRIES</guard>
         <action>LOG_printf(&quot;Retrying to flash packet, retry %d out of %d max\n&quot;, me-&gt;retryCurr, MAX_FLASH_RETRIES);</action>
         <choice_glyph conn="98,67,5,2,10,-9">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard>else</guard>
         <action>ERR_printf(&quot;No more retries\n&quot;);</action>
         <choice_glyph conn="98,67,5,1,-77">
          <action box="-9,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="86,57,3,-1,12,10">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="86,47,26,11">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="42,8,84,87">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state name="BusyRam">
      <documentation>/**
 * @brief    Busy state for RAM test operation processing.
 * This state handles RAM test processing and indicates that the system is busy and
 * cannot process another req at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Arm the timer so if the message can't be processed for some reason, we can get
 * back to idle state.  This timer may be re-armed if some messages require more 
 * time to process than others. */
QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;ramTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_CLI_WAIT_FOR_RAM_TEST )
);
</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;ramTimerEvt); /* Disarm timer on exit */

/* Always send a flash status event to the CommMgr AO with the current error code */
RamStatusEvt *evt = Q_NEW(RamStatusEvt, RAM_TEST_DONE_SIG);
evt-&gt;errorCode = me-&gt;errorCode;
evt-&gt;test = me-&gt;currRamTest;
evt-&gt;addr = me-&gt;currRamAddr;
QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_FlashMgr);</exit>
      <tran trig="RAM_TIMEOUT" target="../../0">
       <action>ERR_printf(
    &quot;Timeout trying to process RAM test request during RAM test %d, error: 0x%08x\n&quot;,
    me-&gt;currRamTest, me-&gt;errorCode
);</action>
       <tran_glyph conn="42,120,3,1,-21">
        <action box="-14,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state name="AddrBusTest">
       <documentation>/**
 * @brief    Perform a RAM address bus test
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>me-&gt;currRamTest = _DC3_RAM_TEST_ADDR_BUS;
me-&gt;currRamAddr = 0;
me-&gt;errorCode = ERR_SDRAM_ADDR_BUS_TEST_TIMEOUT;

QEvt *evt = Q_NEW(QEvt, RAM_OP_START_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
</entry>
       <tran trig="RAM_OP_START">
        <action>me-&gt;currRamAddr = SDRAM_testAddrBus( 0,  RAM_TEST_BLOCK_SIZE );</action>
        <choice target="../../../2">
         <guard>else</guard>
         <action>DBG_printf(&quot;No RAM Addr bus error found.\n&quot;);</action>
         <choice_glyph conn="85,109,4,3,-3,5">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard brief="Error?">0 != me-&gt;currRamAddr</guard>
         <action>me-&gt;errorCode = ERR_SDRAM_ADDR_BUS;
ERR_printf(
    &quot;RAM addr bus test failed at addr: 0x%08x. Error: 0x%08x\n&quot;,
    me-&gt;currRamAddr, me-&gt;errorCode
);</action>
         <choice_glyph conn="85,109,4,1,5,-64">
          <action box="-6,3,7,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="68,109,3,-1,17">
         <action box="1,-2,12,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="68,103,15,8">
        <entry box="1,2,4,2"/>
       </state_glyph>
      </state>
      <state name="DeviceTest">
       <documentation>/**
 * @brief    Perform a RAM device bus test.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>me-&gt;currRamTest = _DC3_RAM_TEST_DEV_INT;
me-&gt;currRamAddr = 0;
me-&gt;errorCode = ERR_SDRAM_DEVICE_INTEGRITY_TEST_TIMEOUT;

QEvt *evt = Q_NEW(QEvt, RAM_OP_START_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
</entry>
       <tran trig="RAM_OP_START">
        <action>me-&gt;currRamAddr = SDRAM_testDevice(0, RAM_TEST_BLOCK_SIZE );</action>
        <choice target="../../../../0">
         <guard>else</guard>
         <action>me-&gt;errorCode = ERR_NONE;
DBG_printf(&quot;No RAM device errors found.\n&quot;);</action>
         <choice_glyph conn="107,115,4,1,2,-86">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard brief="Error?">0 != me-&gt;currRamAddr</guard>
         <action>me-&gt;errorCode = ERR_SDRAM_DEVICE_INTEGRITY;
ERR_printf(
    &quot;RAM device bus test failed at addr: 0x%08x. Error: 0x%08x\n&quot;,
    me-&gt;currRamAddr, me-&gt;errorCode
);</action>
         <choice_glyph conn="107,115,5,1,-86">
          <action box="-8,-2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="90,109,3,-1,17,6">
         <action box="1,-2,12,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="90,103,15,8">
        <entry box="1,2,4,2"/>
       </state_glyph>
      </state>
      <state name="DataBusTest">
       <documentation>/**
 * @brief    Perform a RAM data bus test on a single address
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>me-&gt;currRamTest = _DC3_RAM_TEST_DATA_BUS;
me-&gt;currRamAddr = 0;
me-&gt;errorCode = ERR_SDRAM_DATA_BUS_TEST_TIMEOUT;

QEvt *evt = Q_NEW(QEvt, RAM_OP_START_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
</entry>
       <tran trig="RAM_OP_START">
        <action>me-&gt;currRamTest = _DC3_RAM_TEST_DATA_BUS;
me-&gt;currRamAddr = SDRAM_testDataBus( 0 );</action>
        <choice target="../../../1">
         <guard>else</guard>
         <action>DBG_printf(&quot;No RAM Data bus error found.\n&quot;);</action>
         <choice_glyph conn="64,109,4,3,-3,4">
          <action box="0,-6,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard brief="Error?">0 != me-&gt;currRamAddr</guard>
         <action>me-&gt;errorCode = ERR_SDRAM_DATA_BUS;
ERR_printf(
    &quot;RAM data bus test failed at addr: 0x%08x on pattern: 0x%08x. Error: 0x%08x\n&quot;,
    SDRAM_BANK_ADDR + 0, me-&gt;currRamAddr, me-&gt;errorCode 
);</action>
         <choice_glyph conn="64,109,4,1,4,-43">
          <action box="-6,2,7,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="46,109,3,-1,18">
         <action box="0,-2,12,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="46,103,15,8">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="42,99,71,23">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,3,130,123">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="137,127"/>
   </statechart>
  </class>
  <attribute name="AO_FlashMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="FlashMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for FlashMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */</documentation>
   <code>FlashMgr *me = &amp;l_FlashMgr;
QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;FlashMgr_initial);
QTimeEvt_ctor(&amp;me-&gt;flashTimerEvt, FLASH_TIMEOUT_SIG);
QTimeEvt_ctor(&amp;me-&gt;flashOpTimerEvt, FLASH_OP_TIMEOUT_SIG);
QTimeEvt_ctor(&amp;me-&gt;ramTimerEvt, RAM_TIMEOUT_SIG);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="FlashMgr_gen.c">
   <text>/**
 * @file    FlashMgr.c
 * Declarations for functions for the FlashMgr AO.  This state
 * machine handles all FW flashing operations
 *
 * Note: If editing this file, please make sure to update the FlashMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    04/29/2015
 * @author  Harry Rostovtsev
 * @email   rost0031@gmail.com
 * Copyright (C) 2015 Harry Rostovtsev. All rights reserved.
 *
 * @addtogroup groupBsp
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;FlashMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp_defs.h&quot;                         /* For time to ticks conversion */
#include &quot;flash.h&quot;
#include &quot;CommMgr.h&quot;
#include &quot;crc32compat.h&quot;
#include &quot;sdram.h&quot;

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DC3_DBG_MODL_FLASH );/* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::FlashMgr)

/* Private defines -----------------------------------------------------------*/
#define MAX_FLASH_RETRIES                                                      5
#define RAM_TEST_BLOCK_SIZE                                           0x00800000
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static FlashMgr l_FlashMgr; /* the single instance of the Interstage active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_FlashMgr = (QActive *)&amp;l_FlashMgr;  /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::FlashMgr_ctor)
$define(AOs::FlashMgr)

/**
 * @} end addtogroup groupBsp
 */

/******** Copyright (C) 2015 Harry Rostovtsev. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="FlashMgr_gen.h">
   <text>/**
 * @file    FlashMgr.h
 * Declarations for functions for the FlashMgr AO.  This state
 * machine handles all FW flashing operations
 *
 * Note: If editing this file, please make sure to update the FlashMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    04/29/2015
 * @author  Harry Rostovtsev
 * @email   rost0031@gmail.com
 * Copyright (C) 2015 Harry Rostovtsev. All rights reserved.
 *
 * @addtogroup groupBsp
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef FLASHMGR_H_
#define FLASHMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;DC3CommApi.h&quot;              /* For API for communicating with client */
#include &quot;DC3Signals.h&quot;             /* For QP signals available to the system */

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)
/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::FlashMgr_ctor)
$declare(AOs::AO_FlashMgr)

/**
 * @} end addtogroup groupBsp
 */

#endif                                                         /* FLASHMGR_H_ */
/******** Copyright (C) 2014 Harry Rostovtsev. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
