<?xml version="1.0" encoding="UTF-8"?>
<model version="3.2.2">
 <documentation>/**
 * CommStackMgr Active Object which.  This AO handles all communications work.
 */</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="FWDataEvt" superclass="qpc::QEvt">
   <documentation>/**&lt; Event type that allows transport of FW data */</documentation>
   <attribute name="dataCRC" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW Data packet CRC */</documentation>
   </attribute>
   <attribute name="dataLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data buffer */</documentation>
   </attribute>
   <attribute name="dataBuf[CB_MAX_MSG_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Data buffer */</documentation>
   </attribute>
   <attribute name="seqCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW data packet sequence number */</documentation>
   </attribute>
   <attribute name="seqTotal" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Total number of FW data packets expected */</documentation>
   </attribute>
  </class>
  <class name="FWMetaEvt" superclass="qpc::QEvt">
   <documentation>/**&lt; Event type that transports metadata about the FW upgrade */</documentation>
   <attribute name="imageCRC" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image CRC */</documentation>
   </attribute>
   <attribute name="imageSize" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image size */</documentation>
   </attribute>
   <attribute name="imageType" type="CBBootMode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image type */</documentation>
   </attribute>
   <attribute name="imageMaj" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image major version number */</documentation>
   </attribute>
   <attribute name="imageMin" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image minor version number */</documentation>
   </attribute>
   <attribute name="imageDatetime[CB_DATETIME_LEN]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image datetime */</documentation>
   </attribute>
   <attribute name="imageDatetimeLen" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW image datetime length */</documentation>
   </attribute>
   <attribute name="errorCode" type="CBErrorCode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the FW flash completion.  Only used when sending back from FlashMgr */</documentation>
   </attribute>
  </class>
  <class name="FlashStatusEvt" superclass="qpc::QEvt">
   <documentation>/**&lt; Event type that transports metadata about the FW upgrade */</documentation>
   <attribute name="errorCode" type="CBErrorCode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the FlashMgr operation completion. */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="FlashMgr" superclass="qpc::QActive">
   <documentation>/**
 * \brief FlashMgr &quot;class&quot;
 */</documentation>
   <attribute name="msgRoute" type="CBMsgRoute" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keeps track of where the message came from */</documentation>
   </attribute>
   <attribute name="reqProg" type="bool" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of whether Prog responses were requested by the sender of the msg */</documentation>
   </attribute>
   <attribute name="errorCode" type="CBErrorCode" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of errors that may occur in the AO */</documentation>
   </attribute>
   <attribute name="fwFlashMetadata" type="struct CBFlashMetaPayloadMsg" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Common struct for CBBasicMsg.  This can be re-used in most cases since once the
 * request has been unwrapped, all the data from that struct has been stored locally */</documentation>
   </attribute>
   <attribute name="fwPacketExp" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; How many total FW data packets to expect */</documentation>
   </attribute>
   <attribute name="fwPacketCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; How many total FW data packets to expect */</documentation>
   </attribute>
   <attribute name="flashAddrCurr" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the current flash address */</documentation>
   </attribute>
   <attribute name="retryCurr" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Counter for retries */</documentation>
   </attribute>
   <attribute name="flashSectorsToErase[ADDR_FLASH_SECTORS]" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; FW flash sectors to erase */</documentation>
   </attribute>
   <attribute name="flashSectorsToEraseNum" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; How many flash sectors to erase (how many are in the flashSectorsToErase array) */</documentation>
   </attribute>
   <attribute name="flashSectorsToEraseIndex" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Index into the flashSectorsToErase array for when we are erasing flash */</documentation>
   </attribute>
   <attribute name="flashTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Used for timing out the entire FW upgrade process in FlashMgr object. */</documentation>
   </attribute>
   <attribute name="flashOpTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Used for timing out individual operations on flash in FlashMgr object. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/0">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_CommMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;CommMgr_initial);
QS_FUN_DICTIONARY(&amp;CommMgr_Active);

QS_FUN_DICTIONARY(&amp;CommMgr_Idle);
QS_FUN_DICTIONARY(&amp;CommMgr_Busy);
QS_FUN_DICTIONARY(&amp;CommMgr_PrepFlash);
QS_FUN_DICTIONARY(&amp;CommMgr_WaitingForFWData);
QS_FUN_DICTIONARY(&amp;CommMgr_WritingFlash);
QS_FUN_DICTIONARY(&amp;CommMgr_FinalizingFlash);

QActive_subscribe((QActive *)me, FLASH_OP_START_SIG);
QActive_subscribe((QActive *)me, FLASH_DATA_SIG);
QActive_subscribe((QActive *)me, FLASH_DONE_SIG);
QActive_subscribe((QActive *)me, FLASH_ERROR_SIG);
QActive_subscribe((QActive *)me, FLASH_TIMEOUT_SIG);</action>
     <initial_glyph conn="1,2,4,3,9,5">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Arm and disarm*/
QTimeEvt_postIn(
    &amp;me-&gt;flashTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
);
QTimeEvt_disarm(&amp;me-&gt;flashTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;flashOpTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
);
QTimeEvt_disarm(&amp;me-&gt;flashOpTimerEvt);</entry>
     <state name="Idle">
      <documentation>/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Clear out all the variables on entry to Idle state.  By this point, any error
 * feedback should have already happened. */
me-&gt;errorCode       = ERR_NONE;
me-&gt;msgRoute        = _CB_NoRoute;
me-&gt;reqProg         = false;

memset(&amp;me-&gt;fwFlashMetadata, 0, sizeof(me-&gt;fwFlashMetadata));</entry>
      <tran trig="FLASH_OP_START" target="../../1/2">
       <action>DBG_printf(&quot;FLASH_OP_START\n&quot;);

/* Get the metadata and record it.  Ignore the status  */
me-&gt;fwFlashMetadata._imageCrc  = ((FWMetaEvt const *)e)-&gt;imageCRC;
me-&gt;fwFlashMetadata._imageMaj  = ((FWMetaEvt const *)e)-&gt;imageMaj;
me-&gt;fwFlashMetadata._imageMin  = ((FWMetaEvt const *)e)-&gt;imageMin;
me-&gt;fwFlashMetadata._imageSize = ((FWMetaEvt const *)e)-&gt;imageSize;
me-&gt;fwFlashMetadata._imageType = ((FWMetaEvt const *)e)-&gt;imageType;
me-&gt;fwFlashMetadata._imageDatetime_len = ((FWMetaEvt const *)e)-&gt;imageDatetimeLen;
MEMCPY(
    me-&gt;fwFlashMetadata._imageDatetime,
    ((FWMetaEvt const *)e)-&gt;imageDatetime,
    me-&gt;fwFlashMetadata._imageDatetime_len
);
</action>
       <tran_glyph conn="6,16,3,3,40">
        <action box="0,-2,15,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="6,8,15,85">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Busy">
      <documentation>/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Arm the timer so if the message can't be processed for some reason, we can get
 * back to idle state.  This timer may be re-armed if some messages require more 
 * time to process than others. */
QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;flashTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
);

FLASH_Unlock();/* Always unlock the flash on entry since we'll be doing stuff to it */

/* Reset all the variables that keep track of FW upgrades on entry so they are 
 * guaranteed to be cleared when we start any new operation */
memset( me-&gt;flashSectorsToErase, 0, sizeof(me-&gt;flashSectorsToErase) );
me-&gt;flashSectorsToEraseIndex = 0;
me-&gt;flashSectorsToEraseNum = 0;
me-&gt;fwPacketCurr = 0;
me-&gt;fwPacketExp  = 0;
me-&gt;retryCurr    = 0;</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;flashTimerEvt); /* Disarm timer on exit */

FLASH_Lock();     /* Always lock the flash on exit */

/* Always send a flash status event to the CommMgr AO with the current error code */
FlashStatusEvt *evt = Q_NEW(FlashStatusEvt, FLASH_OP_DONE_SIG);
evt-&gt;errorCode = me-&gt;errorCode;
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);</exit>
      <tran trig="FLASH_TIMEOUT" target="../../0">
       <action>ERR_printf(&quot;Timeout trying to process flash request, error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
       <tran_glyph conn="42,92,3,1,-21">
        <action box="-14,-2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="FLASH_ERROR" target="../../0">
       <action>ERR_printf(&quot;FLASH_ERROR\n&quot;);
</action>
       <tran_glyph conn="42,89,3,1,-21">
        <action box="-14,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state name="PrepFlash">
       <documentation>/**
 * @brief    Prepares flash memory for flashing
 * This state is responsible for erasing the appropriate sections of the Flash.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>/* Self post an event to keep going.  The reason this is done is so that we can use
 * common error handling of the parent state to report errors back to CommMgr instead
 * of having to manually port events whenever an error occurs.*/
QEvt *evt = Q_NEW(QEvt, FLASH_NEXT_STEP_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
</entry>
       <tran trig="FLASH_NEXT_STEP">
        <action>DBG_printf(&quot;FLASH_NEXT_STEP\n&quot;);

LOG_printf(&quot;Extracted FW image metadata:\n&quot;);
LOG_printf(&quot;CRC: 0x%08x\n&quot;, me-&gt;fwFlashMetadata._imageCrc);
LOG_printf(&quot;Maj: %02d\n&quot;, me-&gt;fwFlashMetadata._imageMaj);
LOG_printf(&quot;Min: %02d\n&quot;, me-&gt;fwFlashMetadata._imageMin);
LOG_printf(&quot;Size: %d\n&quot;, me-&gt;fwFlashMetadata._imageSize);
LOG_printf(&quot;Type: %d\n&quot;, me-&gt;fwFlashMetadata._imageType);
LOG_printf(&quot;Datetime: %s\n&quot;, me-&gt;fwFlashMetadata._imageDatetime);

/* Do some sanity checking on the FW image metadata */
me-&gt;errorCode = FLASH_validateMetadata(&amp;(me-&gt;fwFlashMetadata));</action>
        <choice>
         <guard brief="MetadataValid?">ERR_NONE == me-&gt;errorCode</guard>
         <action>DBG_printf(&quot;Finding flash sectors to erase.\n&quot;);

me-&gt;errorCode = FLASH_getSectorsToErase(
    me-&gt;flashSectorsToErase,
    &amp;(me-&gt;flashSectorsToEraseNum),
    ADDR_FLASH_SECTORS,
    me-&gt;fwFlashMetadata._imageType,
    me-&gt;fwFlashMetadata._imageSize
);



</action>
         <choice target="../../../2">
          <guard brief="SectorsValid?">ERR_NONE == me-&gt;errorCode &amp;&amp; me-&gt;flashSectorsToEraseNum &gt; 1</guard>
          <action>LOG_printf(&quot;List of %d sectors (by address) to erase:\n&quot;, me-&gt;flashSectorsToEraseNum);
for( uint8_t i=0; i &lt; me-&gt;flashSectorsToEraseNum; i++ ) {
    LOG_printf(&quot;Sector at address at 0x%08x\n&quot;, me-&gt;flashSectorsToErase[i]);
}</action>
          <choice_glyph conn="77,19,5,0,17,2">
           <action box="1,-2,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <action>ERR_printf(&quot;Unable to get a list of sectors to erase. Error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
          <choice_glyph conn="77,19,4,1,5,-56">
           <action box="-7,3,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="64,19,5,-1,13">
          <action box="1,-2,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard>else</guard>
         <action>ERR_printf(&quot;FW image metadata failed validation with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
         <choice_glyph conn="64,19,4,1,3,-43">
          <action box="-6,3,5,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="46,19,3,-1,18">
         <action box="1,-2,14,2"/>
        </tran_glyph>
       </tran>
       <tran trig="FLASH_OP_TIMEOUT" target="../../../0">
        <action>/* Override whatever error since the timeout interrupted whatever was happening. */
me-&gt;errorCode = ERR_FLASH_ERASE_TIMEOUT;</action>
        <tran_glyph conn="46,27,3,1,-25">
         <action box="-21,-2,16,2"/>
        </tran_glyph>
       </tran>
       <state name="ErasingSector">
        <documentation>/**
 * @brief    Waits while a sector of flash is erased
 * This state is responsible for initializing the erasure of a sector and waiting
 * until the operation is complete.  A timeout may occur during this time and an 
 * error will be reported.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;flashOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_SECTOR_ERASE )
);

DBG_printf(&quot;Attempting to erase sector addr 0x%08x\n&quot;,
    me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]);

/* Use a separate status variable so if a timeout occurs, the timeout error won't get
 * overwritten */
me-&gt;errorCode = FLASH_eraseSector(
    me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]
);

/* Post event to move to the next step only AFTER the blocking call to 
 * FLASH_eraseSector() returns */
QEvt *evt = Q_NEW(QEvt, FLASH_NEXT_STEP_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;flashOpTimerEvt); /* Disarm timer on exit */</exit>
        <tran trig="FLASH_NEXT_STEP">
         <choice>
          <guard brief="EraseOK?">ERR_NONE == me-&gt;errorCode</guard>
          <action>DBG_printf(&quot;Successfully erased sector addr 0x%08x\n&quot;,
    me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]);

me-&gt;flashSectorsToEraseIndex += 1; /* increment the index into the erase array */
</action>
          <choice target="../../..">
           <guard brief="MoreToErase?">me-&gt;flashSectorsToEraseIndex &lt; me-&gt;flashSectorsToEraseNum</guard>
           <choice_glyph conn="97,39,5,1,11,-13,-4">
            <action box="1,0,10,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../3">
           <guard>else</guard>
           <choice_glyph conn="97,39,5,0,-42,7">
            <action box="-8,-2,5,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="97,33,4,-1,6">
           <action box="0,1,10,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard>else</guard>
          <action>WRN_printf(&quot;Failed to erase flash sector 0x%08x\n&quot;, me-&gt;flashSectorsToErase[ me-&gt;flashSectorsToEraseIndex ]);</action>
          <choice target="../../..">
           <guard brief="retry?">me-&gt;retryCurr &lt; MAX_FLASH_RETRIES</guard>
           <action>me-&gt;retryCurr += 1; /* Increment retry counter */
WRN_printf(&quot;Attempting operation again (retry %d out of %d)...\n&quot;, me-&gt;retryCurr, MAX_FLASH_RETRIES);</action>
           <choice_glyph conn="73,33,4,3,-7,10">
            <action box="0,-4,7,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../0">
           <guard>else</guard>
           <action>ERR_printf(&quot;No more retries, aborting with error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
           <choice_glyph conn="73,33,5,1,-52">
            <action box="-8,0,6,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="97,33,5,-1,-24">
           <action box="-9,-2,5,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="83,29,3,-1,14,4">
          <action box="0,-2,14,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="83,21,21,9">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="46,13,66,30">
        <entry box="1,2,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitingForFWData">
       <documentation>/**
 * @brief    Requests and waits for FW data packets
 * This state is responsible for:
 * 1. Requesting a FW data packet from CommMgr.
 * 2. Waiting (with a timeout) to receive the packet.
 * 3. Validating the packet
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>DBG_printf(&quot;Waiting for FW data packets...\n&quot;);

me-&gt;errorCode = ERR_FLASH_WAIT_FOR_DATA_TIMEOUT;

QTimeEvt_rearm(                         /* Re-arm timer on entry */
    &amp;me-&gt;flashOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_WAIT_FOR_DATA )
);


/* Ok, we are ready to receive FW data and start flashing. Post an event letting
 * CommMgr know we are ready for a data packet. */
FlashStatusEvt *evt = Q_NEW(FlashStatusEvt, FLASH_OP_DONE_SIG);
evt-&gt;errorCode = me-&gt;errorCode;
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;flashOpTimerEvt); /* Disarm timer on exit */</exit>
       <tran trig="FLASH_DATA">
        <action>DBG_printf(&quot;FLASH_DATA received\n&quot;);</action>
        <choice target="../../../4">
         <guard brief="ValidSeq?">me-&gt;fwPacketCurr + 1 == ((FWDataEvt const *)e)-&gt;seqCurr</guard>
         <action>DBG_printf(&quot;Valid fw packet sequence number\n&quot;);</action>
         <choice_glyph conn="58,58,4,0,3">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard>else</guard>
         <action>ERR_printf(&quot;Invalid fw packet sequence number\n&quot;);</action>
         <choice_glyph conn="58,58,5,1,-37">
          <action box="-7,-2,5,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="46,54,3,-1,12,4">
         <action box="0,-2,11,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="46,46,26,9">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WritingFlash">
       <documentation>/**
 * @brief    Writes and verifies received flash data packet to Flash memory.
 * This state is responsible for:
 * 1. Writing the data packet to flash memory at the location necessary.
 * 2. Reading back the flash memory and verifying it was written correctly.
 * 3. Checking if more packets are needed.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <tran trig="FLASH_DONE">
        <action>DBG_printf(&quot;FLASH_DONE\n&quot;);

/* Increment current packet after we have successfully written */
me-&gt;fwPacketCurr++;</action>
        <choice target="../../../3">
         <guard brief="MorePackets?">me-&gt;fwPacketCurr == me-&gt;fwPacketExp</guard>
         <action>DBG_printf(&quot;Waiting for next fw packet\n&quot;);</action>
         <choice_glyph conn="76,66,4,1,-16,-4">
          <action box="1,-5,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../5">
         <guard>else</guard>
         <action>DBG_printf(&quot;No more fw packets expected\n&quot;);</action>
         <choice_glyph conn="76,66,4,1,12,-4">
          <action box="1,2,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="46,66,3,-1,30">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="FLASH_ERROR">
        <action>WRN_printf(&quot;FLASH_ERROR\n&quot;);</action>
        <choice target="../..">
         <guard brief="RetriesLeft?">me-&gt;retryCurr &lt; MAX_FLASH_RETRIES</guard>
         <action>LOG_printf(&quot;Retrying to flash packet, retry %d out of %d max\n&quot;, me-&gt;retryCurr, MAX_FLASH_RETRIES);</action>
         <choice_glyph conn="58,74,5,2,10,-3">
          <action box="1,0,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../0">
         <guard>else</guard>
         <action>ERR_printf(&quot;No more retries\n&quot;);</action>
         <choice_glyph conn="58,74,5,1,-37">
          <action box="-9,0,10,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="46,69,3,-1,12,5">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="46,61,26,10"/>
      </state>
      <state name="FinalizeFlash">
       <documentation>/**
 * @brief    Writes FW image size, CRC, versions, and datetime to Flash; locks it.
 * This state is responsible for:
 * 1. Writing the FW image CRC, Major/Minor versions, size, and datetime to a special
 *    sector of the flash memory
 * 2. Verifying the CRC/size/version/datetime of the written FW image matches what
 *    was sent down with the initial metadata.
 * 3. Locking the flash and sending the new metadata (which should match the
 *    original) to CommMgr to send back to the client.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <tran trig="FLASH_DONE" target="../../../0">
        <action>DBG_printf(&quot;FLASH_DONE\n&quot;);</action>
        <tran_glyph conn="72,84,1,1,-51">
         <action box="-16,-2,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="46,76,26,10"/>
      </state>
      <state_glyph node="42,8,84,85">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,3,130,91">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="163,95"/>
   </statechart>
  </class>
  <attribute name="AO_FlashMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="FlashMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for FlashMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */</documentation>
   <code>FlashMgr *me = &amp;l_FlashMgr;
QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;FlashMgr_initial);
QTimeEvt_ctor(&amp;me-&gt;flashTimerEvt, FLASH_TIMEOUT_SIG);
QTimeEvt_ctor(&amp;me-&gt;flashOpTimerEvt, FLASH_OP_TIMEOUT_SIG);</code>
  </operation>
 </package>
 <directory name=".">
  <file name="FlashMgr_gen.c">
   <text>/**
 * @file    FlashMgr.c
 * Declarations for functions for the FlashMgr AO.  This state
 * machine handles all FW flashing operations
 *
 * Note: If editing this file, please make sure to update the FlashMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    04/29/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupBsp
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;FlashMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp_defs.h&quot;                         /* For time to ticks conversion */
#include &quot;flash.h&quot;

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_FLASH );/* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::FlashMgr)

/* Private defines -----------------------------------------------------------*/
#define USER_FLASH_FIRST_PAGE_ADDRESS                                 0x08020000
#define MAX_FLASH_RETRIES                                                      5

/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static FlashMgr l_FlashMgr; /* the single instance of the Interstage active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_FlashMgr = (QActive *)&amp;l_FlashMgr;  /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::FlashMgr_ctor)
$define(AOs::FlashMgr)

/**
 * @} end addtogroup groupBsp
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="FlashMgr_gen.h">
   <text>/**
 * @file    FlashMgr.h
 * Declarations for functions for the FlashMgr AO.  This state
 * machine handles all FW flashing operations
 *
 * Note: If editing this file, please make sure to update the FlashMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    04/29/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupBsp
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef FLASHMGR_H_
#define FLASHMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;CBCommApi.h&quot;               /* For API for communicating with client */
#include &quot;CBSignals.h&quot;              /* For QP signals available to the system */

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)
/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::FlashMgr_ctor)
$declare(AOs::AO_FlashMgr)

/**
 * @} end addtogroup groupBsp
 */

#endif                                                         /* FLASHMGR_H_ */
/******** Copyright (C) 2014 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
