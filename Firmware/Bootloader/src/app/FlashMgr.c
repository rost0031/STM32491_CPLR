/*****************************************************************************
* Model: FlashMgr.qm
* File:  ./FlashMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::FlashMgr_gen.c} .....................................................*/
/**
 * @file    FlashMgr.c
 * Declarations for functions for the FlashMgr AO.  This state
 * machine handles all FW flashing operations
 *
 * Note: If editing this file, please make sure to update the FlashMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    04/29/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupBsp
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "FlashMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp_defs.h"                         /* For time to ticks conversion */
#include "flash.h"

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_FLASH );/* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/

/**
 * \brief FlashMgr "class"
 */
/*${AOs::FlashMgr} .........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Keeps track of where the message came from */
    CBMsgRoute msgRoute;

    /**< Keep track of whether Prog responses were requested by the sender of the msg */
    bool reqProg;

    /**< Keep track of errors that may occur in the AO */
    CBErrorCode errorCode;

    /**< Common struct for CBBasicMsg.  This can be re-used in most cases since once the
     * request has been unwrapped, all the data from that struct has been stored locally */
    struct CBFlashMetaPayloadMsg fwFlashMetadata;

    /**< How many total FW data packets to expect */
    uint16_t fwPacketExp;

    /**< How many total FW data packets to expect */
    uint16_t fwPacketCurr;

    /**< Keep track of the current flash address */
    uint32_t flashAddrCurr;

    /**< Counter for retries */
    uint16_t retryCurr;

    /**< Used for timing out events and actions in FlashMgr object. */
    QTimeEvt flashTimerEvt;

    /**< FW flash sectors to erase */
    uint32_t flashSectorsToErase[ADDR_FLASH_SECTORS];

    /**< How many flash sectors to erase (how many are in the flashSectorsToErase array) */
    uint8_t flashSectorsToEraseNum;
} FlashMgr;

/* protected: */
static QState FlashMgr_initial(FlashMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_Active(FlashMgr * const me, QEvt const * const e);

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_Idle(FlashMgr * const me, QEvt const * const e);

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_Busy(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Prepares flash memory for flashing
 * This state is responsible for erasing the appropriate sections of the Flash.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_PrepFlash(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Requests and waits for FW data packets
 * This state is responsible for:
 * 1. Requesting a FW data packet from CommMgr.
 * 2. Waiting (with a timeout) to receive the packet.
 * 3. Validating the packet
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_WaitingForFWData(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Writes and verifies received flash data packet to Flash memory.
 * This state is responsible for:
 * 1. Writing the data packet to flash memory at the location necessary.
 * 2. Reading back the flash memory and verifying it was written correctly.
 * 3. Checking if more packets are needed.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_WritingFlash(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Writes FW image size, CRC, versions, and datetime to Flash; locks it.
 * This state is responsible for:
 * 1. Writing the FW image CRC, Major/Minor versions, size, and datetime to a special
 *    sector of the flash memory
 * 2. Verifying the CRC/size/version/datetime of the written FW image matches what
 *    was sent down with the initial metadata.
 * 3. Locking the flash and sending the new metadata (which should match the
 *    original) to CommMgr to send back to the client.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_FinalizeFlash(FlashMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
#define USER_FLASH_FIRST_PAGE_ADDRESS                                 0x08020000
#define MAX_FLASH_RETRIES                                                      5

/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static FlashMgr l_FlashMgr; /* the single instance of the Interstage active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_FlashMgr = (QActive *)&l_FlashMgr;  /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for FlashMgr "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::FlashMgr_ctor} ....................................................*/
void FlashMgr_ctor(void) {
    FlashMgr *me = &l_FlashMgr;
    QActive_ctor(&me->super, (QStateHandler)&FlashMgr_initial);
    QTimeEvt_ctor(&me->flashTimerEvt, FLASH_TIMEOUT_SIG);
}

/**
 * \brief FlashMgr "class"
 */
/*${AOs::FlashMgr} .........................................................*/
/*${AOs::FlashMgr::SM} .....................................................*/
static QState FlashMgr_initial(FlashMgr * const me, QEvt const * const e) {
    /* ${AOs::FlashMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_CommMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&CommMgr_initial);
    QS_FUN_DICTIONARY(&CommMgr_Active);

    QS_FUN_DICTIONARY(&CommMgr_Idle);
    QS_FUN_DICTIONARY(&CommMgr_Busy);
    QS_FUN_DICTIONARY(&CommMgr_PrepFlash);
    QS_FUN_DICTIONARY(&CommMgr_WaitingForFWData);
    QS_FUN_DICTIONARY(&CommMgr_WritingFlash);
    QS_FUN_DICTIONARY(&CommMgr_FinalizingFlash);

    QActive_subscribe((QActive *)me, FLASH_OP_START_SIG);
    QActive_subscribe((QActive *)me, FLASH_DATA_SIG);
    QActive_subscribe((QActive *)me, FLASH_DONE_SIG);
    QActive_subscribe((QActive *)me, FLASH_ERROR_SIG);
    QActive_subscribe((QActive *)me, FLASH_TIMEOUT_SIG);
    return Q_TRAN(&FlashMgr_Idle);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active} .............................................*/
static QState FlashMgr_Active(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Arm and disarm*/
            QTimeEvt_postIn(
                &me->flashTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_CLI_MSG_PROCESS )
            );
            QTimeEvt_disarm(&me->flashTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Idle} .......................................*/
static QState FlashMgr_Idle(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* Clear out all the variables on entry to Idle state.  By this point, any error
             * feedback should have already happened. */
            me->errorCode       = ERR_NONE;
            me->msgRoute        = _CB_NoRoute;
            me->reqProg         = false;

            memset(&me->fwFlashMetadata, 0, sizeof(me->fwFlashMetadata));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Idle} */
        case Q_EXIT_SIG: {
            /* Reset all the variables that keep track of FW upgrades */
            me->fwPacketCurr = 0;
            me->fwPacketExp  = 0;
            me->retryCurr    = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Idle::FLASH_OP_START} */
        case FLASH_OP_START_SIG: {
            DBG_printf("FLASH_OP_START\n");

            /* Get the metadata and record it.  Ignore the status  */
            me->fwFlashMetadata._imageCrc  = ((FWMetaEvt const *)e)->imageCRC;
            me->fwFlashMetadata._imageMaj  = ((FWMetaEvt const *)e)->imageMaj;
            me->fwFlashMetadata._imageMin  = ((FWMetaEvt const *)e)->imageMin;
            me->fwFlashMetadata._imageSize = ((FWMetaEvt const *)e)->imageSize;
            me->fwFlashMetadata._imageType = ((FWMetaEvt const *)e)->imageType;
            MEMCPY(
                me->fwFlashMetadata._imageDatetime,
                ((FWMetaEvt const *)e)->imageDatetime,
                CB_DATETIME_LEN
            );

            LOG_printf("Extracted FW image metadata:\n");
            LOG_printf("CRC: 0x%08x\n", me->fwFlashMetadata._imageCrc);
            LOG_printf("Maj: %02d\n", me->fwFlashMetadata._imageMaj);
            LOG_printf("Min: %02d\n", me->fwFlashMetadata._imageMin);
            LOG_printf("Size: %d\n", me->fwFlashMetadata._imageSize);
            LOG_printf("Type: %d\n", me->fwFlashMetadata._imageType);
            LOG_printf("Datetime: %s\n", me->fwFlashMetadata._imageDatetime);


            DBG_printf("Finding flash sectors to erase.\n");

            /* Clear out the array and its length */
            memset( me->flashSectorsToErase, 0, sizeof(me->flashSectorsToErase) );
            me->flashSectorsToEraseNum = 0;

            me->errorCode = FLASH_getSectorsToErase(
                me->flashSectorsToErase,
                &(me->flashSectorsToEraseNum),
                ADDR_FLASH_SECTORS,
                me->fwFlashMetadata._imageType,
                me->fwFlashMetadata._imageSize
            );
            LOG_printf("List of %d sectors (by address) to erase:\n", me->flashSectorsToEraseNum);
            for( uint8_t i=0; i < me->flashSectorsToEraseNum; i++ ) {
                LOG_printf("Sector at address at 0x%08x\n", me->flashSectorsToErase[i]);
            }

            status_ = Q_TRAN(&FlashMgr_PrepFlash);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy} .......................................*/
static QState FlashMgr_Busy(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Arm the timer so if the message can't be processed for some reason, we can get
             * back to idle state.  This timer may be re-armed if some messages require more
             * time to process than others. */
            QTimeEvt_rearm(
                &me->flashTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_CLI_MSG_PROCESS )
            );



            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            /* Disarm timer on exit */
            QTimeEvt_disarm(&me->flashTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::FLASH_TIMEOUT} */
        case FLASH_TIMEOUT_SIG: {
            ERR_printf("Timeout trying to process flash request, error: 0x%08x\n", me->errorCode);
            status_ = Q_TRAN(&FlashMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Prepares flash memory for flashing
 * This state is responsible for erasing the appropriate sections of the Flash.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::PrepFlash} ............................*/
static QState FlashMgr_PrepFlash(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash} */
        case Q_ENTRY_SIG: {
            LOG_printf("Erasing flash\n");


            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::FLASH_DONE} */
        case FLASH_DONE_SIG: {
            DBG_printf("FLASH_DONE\n");
            status_ = Q_TRAN(&FlashMgr_WaitingForFWData);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Requests and waits for FW data packets
 * This state is responsible for:
 * 1. Requesting a FW data packet from CommMgr.
 * 2. Waiting (with a timeout) to receive the packet.
 * 3. Validating the packet
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData} .....................*/
static QState FlashMgr_WaitingForFWData(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA} */
        case FLASH_DATA_SIG: {
            DBG_printf("FLASH_DATA_RECEIVED\n");
            /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA::[ValidSeq?]} */
            if (me->fwPacketCurr + 1 == ((FWDataEvt const *)e)->seqCurr) {
                DBG_printf("Valid fw packet sequence number\n");
                status_ = Q_TRAN(&FlashMgr_WritingFlash);
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA::[else]} */
            else {
                ERR_printf("Invalid fw packet sequence number\n");
                status_ = Q_TRAN(&FlashMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Writes and verifies received flash data packet to Flash memory.
 * This state is responsible for:
 * 1. Writing the data packet to flash memory at the location necessary.
 * 2. Reading back the flash memory and verifying it was written correctly.
 * 3. Checking if more packets are needed.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::WritingFlash} .........................*/
static QState FlashMgr_WritingFlash(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_DONE} */
        case FLASH_DONE_SIG: {
            DBG_printf("FLASH_DONE\n");

            /* Increment current packet after we have successfully written */
            me->fwPacketCurr++;
            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_DONE::[MorePackets?]} */
            if (me->fwPacketCurr == me->fwPacketExp) {
                DBG_printf("Waiting for next fw packet\n");
                status_ = Q_TRAN(&FlashMgr_WaitingForFWData);
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_DONE::[else]} */
            else {
                DBG_printf("No more fw packets expected\n");
                status_ = Q_TRAN(&FlashMgr_FinalizeFlash);
            }
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_ERROR} */
        case FLASH_ERROR_SIG: {
            WRN_printf("FLASH_ERROR\n");
            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_ERROR::[RetriesLeft?]} */
            if (me->retryCurr < MAX_FLASH_RETRIES) {
                LOG_printf("Retrying to flash packet, retry %d out of %d max\n", me->retryCurr, MAX_FLASH_RETRIES);
                status_ = Q_TRAN(&FlashMgr_WritingFlash);
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_ERROR::[else]} */
            else {
                ERR_printf("No more retries\n");
                status_ = Q_TRAN(&FlashMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Writes FW image size, CRC, versions, and datetime to Flash; locks it.
 * This state is responsible for:
 * 1. Writing the FW image CRC, Major/Minor versions, size, and datetime to a special
 *    sector of the flash memory
 * 2. Verifying the CRC/size/version/datetime of the written FW image matches what
 *    was sent down with the initial metadata.
 * 3. Locking the flash and sending the new metadata (which should match the
 *    original) to CommMgr to send back to the client.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::FinalizeFlash} ........................*/
static QState FlashMgr_FinalizeFlash(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::FinalizeFlash::FLASH_DONE} */
        case FLASH_DONE_SIG: {
            DBG_printf("FLASH_DONE\n");
            status_ = Q_TRAN(&FlashMgr_Idle);
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::FinalizeFlash::FLASH_ERROR} */
        case FLASH_ERROR_SIG: {
            WRN_printf("FLASH_ERROR\n");
            status_ = Q_TRAN(&FlashMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupBsp
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
