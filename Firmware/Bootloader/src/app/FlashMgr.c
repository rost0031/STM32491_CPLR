/*****************************************************************************
* Model: FlashMgr.qm
* File:  ./FlashMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::FlashMgr_gen.c} .....................................................*/
/**
 * @file    FlashMgr.c
 * Declarations for functions for the FlashMgr AO.  This state
 * machine handles all FW flashing operations
 *
 * Note: If editing this file, please make sure to update the FlashMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    04/29/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupBsp
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "FlashMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp_defs.h"                         /* For time to ticks conversion */
#include "flash.h"
#include "CommMgr.h"
#include "crc32compat.h"

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_FLASH );/* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/

/**
 * \brief FlashMgr "class"
 */
/*${AOs::FlashMgr} .........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Keeps track of where the message came from */
    CBMsgRoute msgRoute;

    /**< Keep track of whether Prog responses were requested by the sender of the msg */
    bool reqProg;

    /**< Keep track of errors that may occur in the AO */
    CBErrorCode errorCode;

    /**< Common struct for CBBasicMsg.  This can be re-used in most cases since once the
     * request has been unwrapped, all the data from that struct has been stored locally */
    struct CBFlashMetaPayloadMsg fwFlashMetadata;

    /**< How many total FW data packets to expect */
    uint16_t fwPacketExp;

    /**< How many total FW data packets to expect */
    uint16_t fwPacketCurr;

    /**< Keep track of the current flash address */
    uint32_t flashAddrCurr;

    /**< Counter for retries */
    uint16_t retryCurr;

    /**< FW flash sectors to erase */
    uint32_t flashSectorsToErase[ADDR_FLASH_SECTORS];

    /**< How many flash sectors to erase (how many are in the flashSectorsToErase array) */
    uint8_t flashSectorsToEraseNum;

    /**< Index into the flashSectorsToErase array for when we are erasing flash */
    uint8_t flashSectorsToEraseIndex;

    /**< Used for timing out the entire FW upgrade process in FlashMgr object. */
    QTimeEvt flashTimerEvt;

    /**< Used for timing out individual operations on flash in FlashMgr object. */
    QTimeEvt flashOpTimerEvt;

    /**< Buffer with FW data to flash */
    uint8_t fwDataToFlash[112];

    /**< Length of data in fwDataToFlash buffer */
    uint8_t fwDataToFlashLen;
} FlashMgr;

/* protected: */
static QState FlashMgr_initial(FlashMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_Active(FlashMgr * const me, QEvt const * const e);

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_Idle(FlashMgr * const me, QEvt const * const e);

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_Busy(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Prepares flash memory for flashing
 * This state is responsible for erasing the appropriate sections of the Flash.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_PrepFlash(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Waits while a sector of flash is erased
 * This state is responsible for initializing the erasure of a sector and waiting
 * until the operation is complete.  A timeout may occur during this time and an
 * error will be reported.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_ErasingSector(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Requests and waits for FW data packets
 * This state is responsible for:
 * 1. Requesting a FW data packet from CommMgr.
 * 2. Waiting (with a timeout) to receive the packet.
 * 3. Validating the packet
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_WaitingForFWData(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Writes and verifies received flash data packet to Flash memory.
 * This state is responsible for:
 * 1. Writing the data packet to flash memory at the location necessary.
 * 2. Reading back the flash memory and verifying it was written correctly.
 * 3. Checking if more packets are needed.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_WritingFlash(FlashMgr * const me, QEvt const * const e);

/**
 * @brief    Writes FW image size, CRC, versions, and datetime to Flash; locks it.
 * This state is responsible for:
 * 1. Writing the FW image CRC, Major/Minor versions, size, and datetime to a special
 *    sector of the flash memory
 * 2. Verifying the CRC/size/version/datetime of the written FW image matches what
 *    was sent down with the initial metadata.
 * 3. Locking the flash and sending the new metadata (which should match the
 *    original) to CommMgr to send back to the client.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState FlashMgr_FinalizeFlash(FlashMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
#define USER_FLASH_FIRST_PAGE_ADDRESS                                 0x08020000
#define MAX_FLASH_RETRIES                                                      5

/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static FlashMgr l_FlashMgr; /* the single instance of the Interstage active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_FlashMgr = (QActive *)&l_FlashMgr;  /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for FlashMgr "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::FlashMgr_ctor} ....................................................*/
void FlashMgr_ctor(void) {
    FlashMgr *me = &l_FlashMgr;
    QActive_ctor(&me->super, (QStateHandler)&FlashMgr_initial);
    QTimeEvt_ctor(&me->flashTimerEvt, FLASH_TIMEOUT_SIG);
    QTimeEvt_ctor(&me->flashOpTimerEvt, FLASH_OP_TIMEOUT_SIG);
}

/**
 * \brief FlashMgr "class"
 */
/*${AOs::FlashMgr} .........................................................*/
/*${AOs::FlashMgr::SM} .....................................................*/
static QState FlashMgr_initial(FlashMgr * const me, QEvt const * const e) {
    /* ${AOs::FlashMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_CommMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&CommMgr_initial);
    QS_FUN_DICTIONARY(&CommMgr_Active);

    QS_FUN_DICTIONARY(&CommMgr_Idle);
    QS_FUN_DICTIONARY(&CommMgr_Busy);
    QS_FUN_DICTIONARY(&CommMgr_PrepFlash);
    QS_FUN_DICTIONARY(&CommMgr_WaitingForFWData);
    QS_FUN_DICTIONARY(&CommMgr_WritingFlash);
    QS_FUN_DICTIONARY(&CommMgr_FinalizingFlash);

    QActive_subscribe((QActive *)me, FLASH_OP_START_SIG);
    QActive_subscribe((QActive *)me, FLASH_DATA_SIG);
    QActive_subscribe((QActive *)me, FLASH_DONE_SIG);
    QActive_subscribe((QActive *)me, FLASH_ERROR_SIG);
    QActive_subscribe((QActive *)me, FLASH_TIMEOUT_SIG);
    return Q_TRAN(&FlashMgr_Idle);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active} .............................................*/
static QState FlashMgr_Active(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Arm and disarm*/
            QTimeEvt_postIn(
                &me->flashTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
            );
            QTimeEvt_disarm(&me->flashTimerEvt);

            QTimeEvt_postIn(
                &me->flashOpTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
            );
            QTimeEvt_disarm(&me->flashOpTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Idle} .......................................*/
static QState FlashMgr_Idle(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* Clear out all the variables on entry to Idle state.  By this point, any error
             * feedback should have already happened. */
            me->errorCode       = ERR_NONE;
            me->msgRoute        = _CB_NoRoute;
            me->reqProg         = false;

            memset(&me->fwFlashMetadata, 0, sizeof(me->fwFlashMetadata));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Idle::FLASH_OP_START} */
        case FLASH_OP_START_SIG: {
            DBG_printf("FLASH_OP_START\n");

            /* Get the metadata and record it.  Ignore the status  */
            me->fwFlashMetadata._imageCrc  = ((FWMetaEvt const *)e)->imageCRC;
            me->fwFlashMetadata._imageMaj  = ((FWMetaEvt const *)e)->imageMaj;
            me->fwFlashMetadata._imageMin  = ((FWMetaEvt const *)e)->imageMin;
            me->fwFlashMetadata._imageSize = ((FWMetaEvt const *)e)->imageSize;
            me->fwFlashMetadata._imageType = ((FWMetaEvt const *)e)->imageType;
            me->fwFlashMetadata._imageDatetime_len = ((FWMetaEvt const *)e)->imageDatetimeLen;
            MEMCPY(
                me->fwFlashMetadata._imageDatetime,
                ((FWMetaEvt const *)e)->imageDatetime,
                me->fwFlashMetadata._imageDatetime_len
            );

            status_ = Q_TRAN(&FlashMgr_PrepFlash);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy} .......................................*/
static QState FlashMgr_Busy(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Arm the timer so if the message can't be processed for some reason, we can get
             * back to idle state.  This timer may be re-armed if some messages require more
             * time to process than others. */
            QTimeEvt_rearm(                         /* Re-arm timer on entry */
                &me->flashTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_FLASH_FW )
            );

            FLASH_Unlock();/* Always unlock the flash on entry since we'll be doing stuff to it */

            /* Reset all the variables that keep track of FW upgrades on entry so they are
             * guaranteed to be cleared when we start any new operation */
            memset( me->flashSectorsToErase, 0, sizeof(me->flashSectorsToErase) );
            me->flashSectorsToEraseIndex = 0;
            me->flashSectorsToEraseNum = 0;
            me->fwPacketCurr = 0;
            me->fwPacketExp  = 0;
            me->retryCurr    = 0;
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->flashTimerEvt); /* Disarm timer on exit */

            FLASH_Lock();     /* Always lock the flash on exit */

            /* Always send a flash status event to the CommMgr AO with the current error code */
            FlashStatusEvt *evt = Q_NEW(FlashStatusEvt, FLASH_OP_DONE_SIG);
            evt->errorCode = me->errorCode;
            QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_FlashMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::FLASH_TIMEOUT} */
        case FLASH_TIMEOUT_SIG: {
            ERR_printf("Timeout trying to process flash request, error: 0x%08x\n", me->errorCode);
            status_ = Q_TRAN(&FlashMgr_Idle);
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::FLASH_ERROR} */
        case FLASH_ERROR_SIG: {
            ERR_printf("FLASH_ERROR\n");

            status_ = Q_TRAN(&FlashMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Prepares flash memory for flashing
 * This state is responsible for erasing the appropriate sections of the Flash.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::PrepFlash} ............................*/
static QState FlashMgr_PrepFlash(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash} */
        case Q_ENTRY_SIG: {
            /* Self post an event to keep going.  The reason this is done is so that we can use
             * common error handling of the parent state to report errors back to CommMgr instead
             * of having to manually port events whenever an error occurs.*/
            QEvt *evt = Q_NEW(QEvt, FLASH_NEXT_STEP_SIG);
            QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::FLASH_NEXT_STEP} */
        case FLASH_NEXT_STEP_SIG: {
            DBG_printf("FLASH_NEXT_STEP\n");

            LOG_printf("Extracted FW image metadata:\n");
            LOG_printf("CRC: 0x%08x\n", me->fwFlashMetadata._imageCrc);
            LOG_printf("Maj: %02d\n", me->fwFlashMetadata._imageMaj);
            LOG_printf("Min: %02d\n", me->fwFlashMetadata._imageMin);
            LOG_printf("Size: %d\n", me->fwFlashMetadata._imageSize);
            LOG_printf("Type: %d\n", me->fwFlashMetadata._imageType);
            LOG_printf("Datetime: %s\n", me->fwFlashMetadata._imageDatetime);

            /* Do some sanity checking on the FW image metadata */
            me->errorCode = FLASH_validateMetadata(&(me->fwFlashMetadata));
            /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::FLASH_NEXT_STEP::[MetadataValid?]} */
            if (ERR_NONE == me->errorCode) {
                DBG_printf("Finding flash sectors to erase.\n");

                me->errorCode = FLASH_getSectorsToErase(
                    me->flashSectorsToErase,
                    &(me->flashSectorsToEraseNum),
                    ADDR_FLASH_SECTORS,
                    me->fwFlashMetadata._imageType,
                    me->fwFlashMetadata._imageSize
                );

                /* Set the start address which will get used later when the fw packets start coming in*/
                if (me->fwFlashMetadata._imageType == _CB_Application ) {
                    me->flashAddrCurr = FLASH_APPL_START_ADDRESS;
                    me->fwPacketExp   = me->fwFlashMetadata._imageNumPackets;
                    DBG_printf("Expecting %d FW data packets\n", me->fwPacketExp);
                } else {
                    me->errorCode = ERR_FLASH_IMAGE_TYPE_INVALID;
                    ERR_printf("FW image type %d currently not supported for FW upgrades, error: 0x%08x\n",
                        me->fwFlashMetadata._imageType, me->errorCode);
                }
                /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::FLASH_NEXT_STEP::[MetadataValid?]::[SectorsValid?]} */
                if (ERR_NONE == me->errorCode && me->flashSectorsToEraseNum > 1) {
                    LOG_printf("List of %d sectors (by address) to erase:\n", me->flashSectorsToEraseNum);
                    for( uint8_t i=0; i < me->flashSectorsToEraseNum; i++ ) {
                        LOG_printf("Sector at address at 0x%08x\n", me->flashSectorsToErase[i]);
                    }
                    status_ = Q_TRAN(&FlashMgr_ErasingSector);
                }
                /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::FLASH_NEXT_STEP::[MetadataValid?]::[else]} */
                else {
                    ERR_printf("Unable to get a list of sectors to erase. Error: 0x%08x\n", me->errorCode);
                    status_ = Q_TRAN(&FlashMgr_Idle);
                }
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::FLASH_NEXT_STEP::[else]} */
            else {
                ERR_printf("FW image metadata failed validation with error: 0x%08x\n", me->errorCode);
                status_ = Q_TRAN(&FlashMgr_Idle);
            }
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::FLASH_OP_TIMEOUT} */
        case FLASH_OP_TIMEOUT_SIG: {
            /* Override whatever error since the timeout interrupted whatever was happening. */
            me->errorCode = ERR_FLASH_ERASE_TIMEOUT;
            status_ = Q_TRAN(&FlashMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Waits while a sector of flash is erased
 * This state is responsible for initializing the erasure of a sector and waiting
 * until the operation is complete.  A timeout may occur during this time and an
 * error will be reported.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector} .............*/
static QState FlashMgr_ErasingSector(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                         /* Re-arm timer on entry */
                &me->flashOpTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_SECTOR_ERASE )
            );

            DBG_printf("Attempting to erase sector addr 0x%08x\n",
                me->flashSectorsToErase[ me->flashSectorsToEraseIndex ]);

            /* Use a separate status variable so if a timeout occurs, the timeout error won't get
             * overwritten */
            me->errorCode = FLASH_eraseSector(
                me->flashSectorsToErase[ me->flashSectorsToEraseIndex ]
            );

            /* Post event to move to the next step only AFTER the blocking call to
             * FLASH_eraseSector() returns */
            QEvt *evt = Q_NEW(QEvt, FLASH_NEXT_STEP_SIG);
            QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->flashOpTimerEvt); /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector::FLASH_NEXT_STEP} */
        case FLASH_NEXT_STEP_SIG: {
            /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector::FLASH_NEXT_STEP::[EraseOK?]} */
            if (ERR_NONE == me->errorCode) {
                DBG_printf("Successfully erased sector addr 0x%08x\n",
                    me->flashSectorsToErase[ me->flashSectorsToEraseIndex ]);

                me->flashSectorsToEraseIndex += 1; /* increment the index into the erase array */

                /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector::FLASH_NEXT_STEP::[EraseOK?]::[MoreToErase?]} */
                if (me->flashSectorsToEraseIndex < me->flashSectorsToEraseNum) {
                    status_ = Q_TRAN(&FlashMgr_ErasingSector);
                }
                /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector::FLASH_NEXT_STEP::[EraseOK?]::[else]} */
                else {
                    status_ = Q_TRAN(&FlashMgr_WaitingForFWData);
                }
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector::FLASH_NEXT_STEP::[else]} */
            else {
                WRN_printf("Failed to erase flash sector 0x%08x\n", me->flashSectorsToErase[ me->flashSectorsToEraseIndex ]);
                /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector::FLASH_NEXT_STEP::[else]::[retry?]} */
                if (me->retryCurr < MAX_FLASH_RETRIES) {
                    me->retryCurr += 1; /* Increment retry counter */
                    WRN_printf("Attempting operation again (retry %d out of %d)...\n", me->retryCurr, MAX_FLASH_RETRIES);
                    status_ = Q_TRAN(&FlashMgr_ErasingSector);
                }
                /* ${AOs::FlashMgr::SM::Active::Busy::PrepFlash::ErasingSector::FLASH_NEXT_STEP::[else]::[else]} */
                else {
                    ERR_printf("No more retries, aborting with error: 0x%08x\n", me->errorCode);
                    status_ = Q_TRAN(&FlashMgr_Idle);
                }
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_PrepFlash);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Requests and waits for FW data packets
 * This state is responsible for:
 * 1. Requesting a FW data packet from CommMgr.
 * 2. Waiting (with a timeout) to receive the packet.
 * 3. Validating the packet
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData} .....................*/
static QState FlashMgr_WaitingForFWData(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData} */
        case Q_ENTRY_SIG: {
            /* Ok, we are ready to receive FW data and start flashing. Post an event letting
             * CommMgr know we are ready for a data packet. */
            FlashStatusEvt *evt = Q_NEW(FlashStatusEvt, FLASH_OP_DONE_SIG);
            evt->errorCode = me->errorCode;
            QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_FlashMgr);

            me->errorCode = ERR_FLASH_WAIT_FOR_DATA_TIMEOUT; /* Set the timeout error code*/

            QTimeEvt_rearm(                         /* Re-arm timer on entry */
                &me->flashOpTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_WAIT_FOR_DATA )
            );


            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->flashOpTimerEvt); /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA} */
        case FLASH_DATA_SIG: {
            /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA::[ValidSeq?]} */
            if (me->fwPacketCurr + 1 == ((FWDataEvt const *)e)->seqCurr) {
                /* Calculate packet data CRC and make sure it matches the one sent over */
                CRC_ResetDR();
                uint32_t CRCValue = CRC32_Calc(((FWDataEvt const *)e)->dataBuf, ((FWDataEvt const *)e)->dataLen);

                /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA::[ValidSeq?]::[ValidCRC?]} */
                if (CRCValue != ((FWDataEvt const *)e)->dataCRC) {
                    me->fwDataToFlashLen = ((FWDataEvt const *)e)->dataLen;
                    MEMCPY(
                        me->fwDataToFlash,
                        ((FWDataEvt const *)e)->dataBuf,
                        me->fwDataToFlashLen
                    );
                    status_ = Q_TRAN(&FlashMgr_WritingFlash);
                }
                /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA::[ValidSeq?]::[else]} */
                else {
                    me->errorCode = ERR_FLASH_INVALID_FW_PACKET_CRC;
                    ERR_printf(
                        "Sent CRC (0x%08x) doesn't match calculated (0x%08x) for fw packet: %d. Error: 0x%08x\n",
                        CRCValue, ((FWDataEvt const *)e)->dataCRC, ((FWDataEvt const *)e)->seqCurr, me->errorCode);

                    status_ = Q_TRAN(&FlashMgr_Idle);
                }
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::WaitingForFWData::FLASH_DATA::[else]} */
            else {
                ERR_printf("Invalid fw packet sequence number\n");
                status_ = Q_TRAN(&FlashMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Writes and verifies received flash data packet to Flash memory.
 * This state is responsible for:
 * 1. Writing the data packet to flash memory at the location necessary.
 * 2. Reading back the flash memory and verifying it was written correctly.
 * 3. Checking if more packets are needed.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::WritingFlash} .........................*/
static QState FlashMgr_WritingFlash(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash} */
        case Q_ENTRY_SIG: {
            me->errorCode = ERR_FLASH_WRITE_TIMEOUT; /* Set the timeout error code*/
            DBG_printf("Writing for FW data packet %d...\n", me->fwPacketCurr + 1);

            QTimeEvt_rearm(                         /* Re-arm timer on entry */
                &me->flashOpTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_FLASH_DATA_WRITE )
            );

            uint16_t bytesWritten = 0;
            CBErrorCode err = FLASH_writeBuffer(
                  me->flashAddrCurr,
                  me->fwDataToFlash,
                  me->fwDataToFlashLen,
                  &bytesWritten
            );

            me->errorCode = err;

            if( ERR_NONE != err || bytesWritten != me->fwDataToFlashLen) { /* Error occurred */
                WRN_printf("Error flashing data: 0x%08x\n", me->errorCode);
                QEvt *evt = Q_NEW(QEvt, FLASH_ERROR_SIG);
                QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
            } else {                                                            /* No errors */
                /* Increment addr and counters */
                me->flashAddrCurr += bytesWritten;
                me->fwPacketCurr += 1;
                QEvt *evt = Q_NEW(QEvt, FLASH_DONE_SIG);
                QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_FlashMgr);
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_DONE} */
        case FLASH_DONE_SIG: {


            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_DONE::[MorePackets?]} */
            if (me->fwPacketCurr != me->fwPacketExp) {
                status_ = Q_TRAN(&FlashMgr_WaitingForFWData);
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_DONE::[else]} */
            else {
                DBG_printf("No more fw packets expected\n");
                status_ = Q_TRAN(&FlashMgr_FinalizeFlash);
            }
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_ERROR} */
        case FLASH_ERROR_SIG: {
            WRN_printf("FLASH_ERROR\n");
            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_ERROR::[RetriesLeft?]} */
            if (me->retryCurr < MAX_FLASH_RETRIES) {
                LOG_printf("Retrying to flash packet, retry %d out of %d max\n", me->retryCurr, MAX_FLASH_RETRIES);
                status_ = Q_TRAN(&FlashMgr_WritingFlash);
            }
            /* ${AOs::FlashMgr::SM::Active::Busy::WritingFlash::FLASH_ERROR::[else]} */
            else {
                ERR_printf("No more retries\n");
                status_ = Q_TRAN(&FlashMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Writes FW image size, CRC, versions, and datetime to Flash; locks it.
 * This state is responsible for:
 * 1. Writing the FW image CRC, Major/Minor versions, size, and datetime to a special
 *    sector of the flash memory
 * 2. Verifying the CRC/size/version/datetime of the written FW image matches what
 *    was sent down with the initial metadata.
 * 3. Locking the flash and sending the new metadata (which should match the
 *    original) to CommMgr to send back to the client.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::FlashMgr::SM::Active::Busy::FinalizeFlash} ........................*/
static QState FlashMgr_FinalizeFlash(FlashMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::FlashMgr::SM::Active::Busy::FinalizeFlash} */
        case Q_ENTRY_SIG: {
            DBG_printf("Finalizing FW update...\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::FlashMgr::SM::Active::Busy::FinalizeFlash::FLASH_DONE} */
        case FLASH_DONE_SIG: {
            DBG_printf("FLASH_DONE\n");
            status_ = Q_TRAN(&FlashMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&FlashMgr_Busy);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupBsp
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
