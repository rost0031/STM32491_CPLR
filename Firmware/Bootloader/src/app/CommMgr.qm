<?xml version="1.0" encoding="UTF-8"?>
<model version="3.2.2">
 <documentation>/**
 * CommStackMgr Active Object which.  This AO handles all communications work.
 */</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01"/>
 <package name="AOs" stereotype="0x02">
  <class name="CommMgr" superclass="qpc::QActive">
   <documentation>/**
 * \brief CommMgr &quot;class&quot;
 */</documentation>
   <attribute name="dataBuf[DC3_MAX_MSG_LEN]" type="uint8_t*" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Local buffer to store incoming msgs */</documentation>
   </attribute>
   <attribute name="basicMsg" type="struct DC3BasicMsg" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Common struct for DC3BasicMsg.  This can be re-used in most cases since once the
 * request has been unwrapped, all the data from that struct has been stored locally */</documentation>
   </attribute>
   <attribute name="basicMsgOffset" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keeps track of how far into the dataBuf basicMsg was.  Sometimes, there are
 * additional payload msgs after the BasicMsg in the buffer and this variable allows
 * the next deserialization step to know where to find them */</documentation>
   </attribute>
   <attribute name="msgRoute" type="DC3MsgRoute_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keeps track of where the message came from */</documentation>
   </attribute>
   <attribute name="msgId" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the ID of the msg */</documentation>
   </attribute>
   <attribute name="msgReqProg" type="bool" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of whether Prog responses were requested by the sender of the msg */</documentation>
   </attribute>
   <attribute name="cliEvtSrc" type="DC3MsgRoute_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the CLI_RECEIVED_SIG event source in order to send it back the
 * same comm channel */</documentation>
   </attribute>
   <attribute name="cliEvtDst" type="DC3MsgRoute_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of the CLI_RECEIVED_SIG event destination.
 * TODO: This isn't currently used but hold on to it just in case. Figure out if
 * this is even needed.*/</documentation>
   </attribute>
   <attribute name="errorCode" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of errors that may occur in the AO */</documentation>
   </attribute>
   <attribute name="msgPayloadName" type="DC3MsgName_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of what the payload msg is supposed to be upon reception.  This is
 * necessary because basicMsg struct gets modified to send an Ack and this variable
 * will be used to extract the rest of the payload from the data buffer where it's 
 * still being stored. */</documentation>
   </attribute>
   <attribute name="payloadMsgUnion" type="DC3PayloadMsgUnion_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Union of all the possible payload msgs.  This gets populated by the recieved msg
 * processing and later reused to send Prog and Done msgs. */</documentation>
   </attribute>
   <attribute name="commMgrTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Timer for timing out the Busy state of CommMgr Ao. */</documentation>
   </attribute>
   <attribute name="commOpTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Timer for timing out the individual operations in CommMgr AO. */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/1">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_CommMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;CommMgr_initial);
QS_FUN_DICTIONARY(&amp;CommMgr_Active);

QActive_subscribe((QActive *)me, SER_RECEIVED_SIG);
QActive_subscribe((QActive *)me, CLI_RECEIVED_SIG);
QActive_subscribe((QActive *)me, I2C1_DEV_READ_DONE_SIG);
QActive_subscribe((QActive *)me, I2C1_DEV_WRITE_DONE_SIG);
QActive_subscribe((QActive *)me, DB_GET_ELEM_DONE_SIG);
QActive_subscribe((QActive *)me, DB_SET_ELEM_DONE_SIG);</action>
     <initial_glyph conn="1,3,4,3,10,4">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Arm and disarm*/
QTimeEvt_postIn(
    &amp;me-&gt;commMgrTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_MSG_PROCESS )
);
QTimeEvt_disarm(&amp;me-&gt;commMgrTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;commOpTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_MSG_PROCESS )
);
QTimeEvt_disarm(&amp;me-&gt;commOpTimerEvt);</entry>
     <tran trig="BOOT_APPL">
      <action>/* This slow log statement has to be here because it flushes the serial output. If
 * this is removed, there will be crashing here - HR */
log_slow_printf(&quot;Got BOOT_APPL sig. Booting Application...\n&quot;);

/* If we made it here, no errors have been encountered and we
 * can safely proceed to boot the Application FW image */

/* Disable the Systick ISR */
SysTick-&gt;CTRL &amp;= ~(SysTick_CTRL_TICKINT_Msk   | SysTick_CTRL_ENABLE_Msk);

/* Jump to user application */
JumpAddress = *(__IO uint32_t*) (FLASH_APPL_START_ADDR + 4);
Jump_To_Application = (pFunction) JumpAddress;

/* Initialize user application's Stack Pointer */
__set_MSP(*(__IO uint32_t*) FLASH_APPL_START_ADDR);

/* After this call, we are running the Application FW image */
Jump_To_Application();</action>
      <tran_glyph conn="2,150,3,-1,23">
       <action box="3,-2,10,2"/>
      </tran_glyph>
     </tran>
     <state name="Idle">
      <documentation>/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Clear out all the variables on entry to Idle state.  By this point, any error
 * feedback should have already happened. */
me-&gt;errorCode       = ERR_NONE;
me-&gt;msgId           = 0;
me-&gt;cliEvtSrc       = _DC3_NoRoute;
me-&gt;cliEvtDst       = _DC3_NoRoute;
me-&gt;msgRoute        = _DC3_NoRoute;
me-&gt;msgPayloadName  = _DC3NoMsg;
me-&gt;msgReqProg      = false;

memset(&amp;me-&gt;basicMsg, 0, sizeof(me-&gt;basicMsg));
memset(&amp;me-&gt;payloadMsgUnion, 0, sizeof(me-&gt;payloadMsgUnion));
memset(me-&gt;dataBuf, 0, sizeof(me-&gt;dataBuf));</entry>
      <tran trig="SER_RECEIVED">
       <action>LrgDataEvt *cliEvt = Q_NEW(LrgDataEvt, CLI_RECEIVED_SIG);
cliEvt-&gt;dataLen = base64_decode(
    (char *)((LrgDataEvt const *) e)-&gt;dataBuf,
    ((LrgDataEvt const *) e)-&gt;dataLen,
    (char *)cliEvt-&gt;dataBuf,
    DC3_MAX_MSG_LEN
);

cliEvt-&gt;src = ((LrgDataEvt const *) e)-&gt;src;
cliEvt-&gt;dst = ((LrgDataEvt const *) e)-&gt;dst;

QACTIVE_POST(
    AO_CommMgr,
    (QEvt *)(cliEvt),
    AO_CommMgr
);</action>
       <tran_glyph conn="5,38,3,-1,18">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="CLI_RECEIVED" target="../../2/3">
       <action>/* Extract the basicMsg first */
memset(&amp;(me-&gt;basicMsg), 0, sizeof(me-&gt;basicMsg));
me-&gt;basicMsgOffset = DC3BasicMsg_read_delimited_from(
    (void*)((LrgDataEvt const *) e)-&gt;dataBuf,
    &amp;(me-&gt;basicMsg),
    0
);

/* Store the event source and destination before entering a new state where that 
 * information will be lost. */
me-&gt;cliEvtSrc = ((LrgDataEvt const *) e)-&gt;src;
me-&gt;cliEvtDst = ((LrgDataEvt const *) e)-&gt;dst;

/* Store the basic msg elements locally since they are needed to send back all the 
 * ack, prog, and done replies. */
me-&gt;msgRoute   = me-&gt;basicMsg._msgRoute;
me-&gt;msgId      = me-&gt;basicMsg._msgID;
me-&gt;msgReqProg = (bool)(me-&gt;basicMsg._msgReqProg);
me-&gt;msgPayloadName = me-&gt;basicMsg._msgPayload; // save this since Ack will overwrite it

DBG_printf( &quot;Rcvd BasicMsg: %s (%d) with PayloadMsg: %s (%d)\n&quot;,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName,
    CON_msgNameToStr( me-&gt;msgPayloadName),  me-&gt;msgPayloadName );

/* Extract the payload (if exists) since this buffer is going away the moment we get
 * into a state.  We'll figure out later if it's valid, right before we send an Ack */
switch( me-&gt;msgPayloadName ) {
    case _DC3NoMsg:
        break;
    case _DC3BootModePayloadMsg:
        DC3BootModePayloadMsg_read_delimited_from(
            ((LrgDataEvt *) e)-&gt;dataBuf,
            &amp;(me-&gt;payloadMsgUnion.bootmodePayload),
            me-&gt;basicMsgOffset
        );
        break;
    case _DC3FlashMetaPayloadMsg:
        DC3FlashMetaPayloadMsg_read_delimited_from(
            ((LrgDataEvt *) e)-&gt;dataBuf,
            &amp;(me-&gt;payloadMsgUnion.flashMetaPayload),
            me-&gt;basicMsgOffset
        );
        break;
    case _DC3FlashDataPayloadMsg:
        DC3FlashDataPayloadMsg_read_delimited_from(
            ((LrgDataEvt *) e)-&gt;dataBuf,
            &amp;(me-&gt;payloadMsgUnion.flashDataPayload),
            me-&gt;basicMsgOffset
        );
        break;
    case _DC3I2CDataPayloadMsg:
        DC3I2CDataPayloadMsg_read_delimited_from(
            ((LrgDataEvt *) e)-&gt;dataBuf,
            &amp;(me-&gt;payloadMsgUnion.i2cDataPayload),
            me-&gt;basicMsgOffset
        );
        break;
    case _DC3DbgPayloadMsg:
        DC3DbgPayloadMsg_read_delimited_from(
            ((LrgDataEvt *) e)-&gt;dataBuf,
            &amp;(me-&gt;payloadMsgUnion.dbgPayload),
            me-&gt;basicMsgOffset
        );
        break;
    case _DC3DBDataPayloadMsg:
        DC3DBDataPayloadMsg_read_delimited_from(
            ((LrgDataEvt *) e)-&gt;dataBuf,
            &amp;(me-&gt;payloadMsgUnion.dbDataPayload),
            me-&gt;basicMsgOffset
        );
        break;
    case _DC3StatusPayloadMsg:             /* Intentionally fall through */
    case _DC3VersionPayloadMsg:            /* Intentionally fall through */
    default:
        WRN_printf(&quot;%s (%d) payload in Req msg, this is probably an error. Ignoring...\n&quot;,
        CON_msgNameToStr( me-&gt;msgPayloadName),  me-&gt;msgPayloadName );
        break;
}</action>
       <tran_glyph conn="5,17,3,3,103">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="5,10,28,136">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Busy">
      <documentation>/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Arm the timer so if the message can't be processed for some reason, we can get
 * back to idle state.  This timer may be re-armed if some messages require more 
 * time to process than others. */
QTimeEvt_rearm(
    &amp;me-&gt;commMgrTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_MSG_PROCESS )
);

/* Compose and send Ack response.  We can re-use the current structure since only
 * one non-essential field changes. */
me-&gt;basicMsg._msgType    = _DC3_Ack;
me-&gt;basicMsg._msgPayload = _DC3NoMsg; // This was saved earlier
/* The rest of the fields are the same */

/* Serialize the msg into a buffer of a fresh event. This event will be passed to
 * a function which will post it directly to the correct AO. */
LrgDataEvt *evt = Q_NEW(LrgDataEvt, CLI_SEND_DATA_SIG);
/* The src and dst are swapped on purpose since we have to tell the message to go
 * to where it originally came from. */
evt-&gt;dst = me-&gt;cliEvtSrc;
evt-&gt;src = me-&gt;cliEvtDst;
evt-&gt;dataLen = DC3BasicMsg_write_delimited_to(&amp;(me-&gt;basicMsg), evt-&gt;dataBuf, 0);
me-&gt;errorCode = Comm_sendToClient( evt );

/* Only print error if something went wrong */
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    _DC3_ACCESS_QPC,
    &quot;Error sending Ack, attempting to continue. Error 0x%08x\n&quot;,
    me-&gt;errorCode
);</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;commMgrTimerEvt);                 /* Disarm timer on exit */

/* Set the fields of the msg common for all Done msgs regardless of status or msg */
me-&gt;basicMsg._msgType    = _DC3_Done;
me-&gt;basicMsg._msgRoute   = me-&gt;msgRoute;
me-&gt;basicMsg._msgID      = me-&gt;msgId;
me-&gt;basicMsg._msgReqProg = (unsigned long)me-&gt;msgReqProg;

/* The command specific fields should have already been set up by their respective
 * exit transitions */
LrgDataEvt *evt = Q_NEW(LrgDataEvt, CLI_SEND_DATA_SIG);
evt-&gt;dataLen = DC3BasicMsg_write_delimited_to(&amp;me-&gt;basicMsg, evt-&gt;dataBuf, 0);
/* The src and dst are swapped on purpose since we have to tell the message to go
 * to where it originally came from. */
evt-&gt;dst = me-&gt;cliEvtSrc;
evt-&gt;src = me-&gt;cliEvtDst;
evt-&gt;dataLen = DC3BasicMsg_write_delimited_to(&amp;(me-&gt;basicMsg), evt-&gt;dataBuf, 0);

/* Append payload msg if needed */
switch( me-&gt;msgPayloadName ) {
    case _DC3StatusPayloadMsg:
        evt-&gt;dataLen = DC3StatusPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.statusPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3VersionPayloadMsg:
        evt-&gt;dataLen = DC3VersionPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.versionPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3BootModePayloadMsg:
        evt-&gt;dataLen = DC3BootModePayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.bootmodePayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3FlashMetaPayloadMsg:
        evt-&gt;dataLen = DC3FlashMetaPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.flashMetaPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3FlashDataPayloadMsg:
        evt-&gt;dataLen = DC3FlashDataPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.flashDataPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3I2CDataPayloadMsg:
        evt-&gt;dataLen = DC3I2CDataPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.i2cDataPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3RamTestPayloadMsg:
        evt-&gt;dataLen = DC3RamTestPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.ramTestPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3DbgPayloadMsg:
        evt-&gt;dataLen = DC3DbgPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.dbgPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3DBDataPayloadMsg:
        evt-&gt;dataLen = DC3DBDataPayloadMsg_write_delimited_to(
            (void*)&amp;(me-&gt;payloadMsgUnion.dbDataPayload),
            evt-&gt;dataBuf,
            evt-&gt;dataLen
        );
        break;
    case _DC3NoMsg:
        break;
    default:
        WRN_printf(&quot;Unknown payload detected %d, this is probably an error\n&quot;,
            me-&gt;msgPayloadName
        );
        break;
}

DBG_printf(&quot;Sending Done type BasicMsg: %s (%d) with PayloadMsg: %s (%d)\n&quot;,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName,
    CON_msgNameToStr( me-&gt;msgPayloadName),  me-&gt;msgPayloadName );

/* Send the Done msg buffer to the client */
me-&gt;errorCode = Comm_sendToClient( evt );

/* Only print error if something went wrong */
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    _DC3_ACCESS_QPC,
    &quot;Error sending Done, attempting to continue. Error 0x%08x\n&quot;,
    me-&gt;errorCode
);</exit>
      <tran trig="COMM_MGR_TIMEOUT" target="../../1">
       <action>ERR_printf( &quot;COMM_MGR_TIMEOUT running BasicMsg: %s (%d) with PayloadMsg %s (%d): Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName,
    CON_msgNameToStr( me-&gt;msgPayloadName),  me-&gt;msgPayloadName, me-&gt;errorCode );</action>
       <tran_glyph conn="62,20,3,1,-29">
        <action box="-19,-2,19,2"/>
       </tran_glyph>
      </tran>
      <tran trig="COMM_OP_TIMEOUT" target="../../1">
       <action>ERR_printf( &quot;COMM_OP_TIMEOUT running BasicMsg: %s (%d) with PayloadMsg %s (%d): Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName,
    CON_msgNameToStr( me-&gt;msgPayloadName),  me-&gt;msgPayloadName, me-&gt;errorCode );</action>
       <tran_glyph conn="62,23,3,1,-29">
        <action box="-19,-2,19,2"/>
       </tran_glyph>
      </tran>
      <state name="WaitForRespFromFlashMgr">
       <documentation>/**
 * @brief    State that waits for a response from FlashMgr AO.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;commOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_COMM_MSG_FLASH_OP )
);

me-&gt;errorCode = ERR_COMM_FLASHMGR_TIMEOUT; /* Set the error in case we timeout */</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;commOpTimerEvt);                  /* Disarm timer on exit */

/* Only print error if something went wrong */
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    _DC3_ACCESS_QPC,
    &quot;Leaving WaitForRespFromFlashMgr state with error 0x%08x\n&quot;,
    me-&gt;errorCode
);</exit>
       <tran trig="FLASH_OP_DONE" target="../../../1">
        <action>me-&gt;errorCode = ((FlashStatusEvt const *)e)-&gt;errorCode;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;</action>
        <tran_glyph conn="65,58,3,1,-32">
         <action box="-19,-2,15,2"/>
        </tran_glyph>
       </tran>
       <tran trig="FLASH_FW_DONE" target="../../../1">
        <action>me-&gt;errorCode = ((FWMetaEvt const *)e)-&gt;errorCode;

/* Overwrite the done response since the FW flashing is complete; we have to send the
 * metadata back so the client can be happy that we did things correctly.  We can 
 * re-use the current structure and it will be used by the exit action of the parent
 * state to send the msg.  Here, we only set up fields that are specific to this
 * response. We can also destructively change the payload name since we are sending
 * a response right after this. */
me-&gt;msgPayloadName = _DC3FlashMetaPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;

/* Set up the payload msg here */
me-&gt;payloadMsgUnion.flashMetaPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.flashMetaPayload._imageCrc  = ((FWMetaEvt const *)e)-&gt;imageCRC;
me-&gt;payloadMsgUnion.flashMetaPayload._imageMaj  = ((FWMetaEvt const *)e)-&gt;imageMaj;
me-&gt;payloadMsgUnion.flashMetaPayload._imageMin  = ((FWMetaEvt const *)e)-&gt;imageMin;
me-&gt;payloadMsgUnion.flashMetaPayload._imageSize = ((FWMetaEvt const *)e)-&gt;imageSize;
me-&gt;payloadMsgUnion.flashMetaPayload._imageType = ((FWMetaEvt const *)e)-&gt;imageType;
MEMCPY(
    me-&gt;payloadMsgUnion.flashMetaPayload._imageDatetime,
    ((FWMetaEvt const *)e)-&gt;imageDatetime,
    DC3_DATETIME_LEN
);
</action>
        <tran_glyph conn="65,55,3,1,-32">
         <action box="-19,-2,15,2"/>
        </tran_glyph>
       </tran>
       <tran trig="RAM_TEST_DONE" target="../../../1">
        <action>me-&gt;errorCode = ((RamStatusEvt const *)e)-&gt;errorCode;
me-&gt;payloadMsgUnion.ramTestPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.ramTestPayload._test = ((RamStatusEvt const *)e)-&gt;test;
me-&gt;payloadMsgUnion.ramTestPayload._addr = ((RamStatusEvt const *)e)-&gt;addr;</action>
        <tran_glyph conn="65,61,3,1,-32">
         <action box="-19,-2,14,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="65,53,19,10">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="ValidateMsg">
       <documentation>/**
 * @brief	State that ensures the system stays in the Busy state while processing.
 * This state just self-posts an event to start the msg processing. Its primary
 * reason for existance is to make sure that the state machine ends up inside the
 * busy state for proper error handling (if any occur).
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;commOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_COMM_MSG_VALIDATE_MSG_OP )
);

/* Post to self to leave the state and continue processing the rest of the msg */
QEvt *evt = Q_NEW(QEvt, MSG_PROCESS_SIG);
QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_CommMgr);</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;commOpTimerEvt);                  /* Disarm timer on exit */</exit>
       <tran trig="MSG_PROCESS">
        <choice target="../../../../1">
         <guard brief="GetBootMode?">_DC3GetBootModeMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3BootModePayloadMsg;

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.bootmodePayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.bootmodePayload._bootMode  = _DC3_Bootloader; // This is the bootloader
DBG_printf(&quot;Setting bootMode payload with bootmode: %d\n&quot;, me-&gt;payloadMsgUnion.bootmodePayload._bootMode);</action>
         <choice_glyph conn="110,25,4,1,3,-77">
          <action box="-11,1,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard>else</guard>
         <action>me-&gt;errorCode = ERR_MSG_UNKNOWN_BASIC;
ERR_printf(
    &quot;Unknown msg (%d) with msgId=%d. Error: 0x%08x\n&quot;,
    me-&gt;basicMsg._msgName, me-&gt;msgId, me-&gt;errorCode);

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;

/* Don't change the basicMsg name since we don't actually know what it is but add a
 * status payload msg to let the user know the error. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;


</action>
         <choice_glyph conn="110,25,5,1,-77">
          <action box="-8,-2,8,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="SetBootMode?">_DC3SetBootModeMsg == me-&gt;basicMsg._msgName</guard>
         <choice target="../../../../../1">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
ERR_printf(&quot;Unexpected payload %s (%d) msg for basic msg: %s (%d). Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;msgPayloadName), me-&gt;msgPayloadName,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName, me-&gt;errorCode);

/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="95,31,5,1,-62">
           <action box="-5,0,5,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="ValidPayload?">_DC3BootModePayloadMsg == me-&gt;msgPayloadName</guard>
          <action>/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice>
           <guard brief="Application?">_DC3_Application == me-&gt;payloadMsgUnion.bootmodePayload._bootMode</guard>
           <action>/* Read the application CRC */
uint32_t storedCRC = FLASH_readApplCRC();
DBG_printf(&quot;Stored CRC: 0x%08x\n&quot;, storedCRC);</action>
           <choice>
            <guard brief="Valid CRC?">storedCRC != 0xFFFFFFFF &amp;&amp; storedCRC != 0x00000000</guard>
            <action>/* Read the application size */
uint32_t storedSize = FLASH_readApplSize();
DBG_printf(&quot;Stored size: 0x%08x\n&quot;, storedSize);</action>
            <choice target="../../../../../../../../1">
             <guard>else</guard>
             <action>me-&gt;errorCode = ERR_COMM_INVALID_APPL_SIZE;
ERR_printf(&quot;Invalid stored Application FW image size: 0x%08x. Error: 0x%08x\n&quot;,
    storedSize, me-&gt;errorCode);</action>
             <choice_glyph conn="69,43,5,1,-36">
              <action box="-5,0,5,2"/>
             </choice_glyph>
            </choice>
            <choice>
             <guard brief="Valid Size?">storedSize != 0xFFFFFFFF &amp;&amp; storedSize != 0x00000000</guard>
             <action>CRC_ResetDR();
uint32_t crcCheck = CRC32_Calc(
    (uint8_t *)FLASH_APPL_START_ADDR,
    storedSize
);</action>
             <choice target="../../../../../../../../../1">
              <guard brief="CRC match?">crcCheck == storedCRC</guard>
              <action>me-&gt;errorCode = ERR_NONE;
LOG_printf(&quot;CRC check passed, booting to Application FW image\n&quot;);

/* Post to self to boot to application but still have enough time to send a Done */
QEvt *evt = Q_NEW(QEvt, BOOT_APPL_SIG);
QACTIVE_POST(AO_CommMgr, (QEvt *)(evt), AO_CommMgr);</action>
              <choice_glyph conn="69,46,4,1,3,-36">
               <action box="1,1,10,2"/>
              </choice_glyph>
             </choice>
             <choice target="../../../../../../../../../1">
              <guard>else</guard>
              <action>me-&gt;errorCode = ERR_COMM_INVALID_APPL_CRC_MISMATCH;
ERR_printf(
    &quot;Stored Application CRC (0x%08x) doesn't match calculated (0x%08x). Reflash the Application FW image. Error: 0x%08x\n&quot;,
    storedCRC, crcCheck, me-&gt;errorCode
);</action>
              <choice_glyph conn="69,46,5,1,-36">
               <action box="-5,0,5,2"/>
              </choice_glyph>
             </choice>
             <choice_glyph conn="69,43,4,-1,3">
              <action box="1,1,10,2"/>
             </choice_glyph>
            </choice>
            <choice_glyph conn="69,40,4,-1,3">
             <action box="1,1,10,2"/>
            </choice_glyph>
           </choice>
           <choice target="../../../../../../../1">
            <guard>else</guard>
            <action>me-&gt;errorCode = ERR_COMM_INVALID_APPL_CRC;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;
ERR_printf(&quot;Invalid stored Application FW image CRC: 0x%08x. Error: 0x%08x\n&quot;, storedCRC, me-&gt;errorCode);</action>
            <choice_glyph conn="69,40,5,1,-36">
             <action box="-5,0,5,2"/>
            </choice_glyph>
           </choice>
           <choice_glyph conn="88,34,4,-1,6,-19">
            <action box="-9,6,10,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard brief="Bootloader?">_DC3_Bootloader == me-&gt;payloadMsgUnion.bootmodePayload._bootMode</guard>
           <action>me-&gt;errorCode = ERR_NONE;
LOG_printf(&quot;Already in bootloader mode, ignoring.\n&quot;);</action>
           <choice_glyph conn="88,34,4,1,3,-55">
            <action box="-9,3,10,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard>else</guard>
           <action>me-&gt;errorCode = ERR_COMM_INVALID_BOOTMODE_REQUESTED;
ERR_printf(&quot;Unsupported bootmode requested (%d). Error: 0x%08x\n&quot;,
    me-&gt;payloadMsgUnion.bootmodePayload._bootMode, me-&gt;errorCode
);</action>
           <choice_glyph conn="88,34,5,1,-55">
            <action box="-6,0,5,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="95,31,4,-1,3,-7">
           <action box="0,1,11,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="110,25,4,-1,6,-15">
          <action box="-11,4,10,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="Flash?">_DC3FlashMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;
</action>
         <choice target="../../../../2">
          <guard brief="FlashMetaPayload?">_DC3FlashMetaPayloadMsg == me-&gt;msgPayloadName</guard>
          <action>/* The flash meta payload is the start of the FW update.  The meta payload contains
 * all the information about the coming fw data.  We need to store this so it can be
 * used to keep track of the FW flash process. */

/* 1. Create a FWMetaEvt and send it along to FlashMgr AO to prep the flash */
FWMetaEvt *evt = Q_NEW(FWMetaEvt, FLASH_OP_START_SIG);
evt-&gt;imageCRC  = me-&gt;payloadMsgUnion.flashMetaPayload._imageCrc;
evt-&gt;imageMaj  = me-&gt;payloadMsgUnion.flashMetaPayload._imageMaj;
evt-&gt;imageMin  = me-&gt;payloadMsgUnion.flashMetaPayload._imageMin;
evt-&gt;imageSize = me-&gt;payloadMsgUnion.flashMetaPayload._imageSize;
evt-&gt;imageType = me-&gt;payloadMsgUnion.flashMetaPayload._imageType;
evt-&gt;imageNumPackets = me-&gt;payloadMsgUnion.flashMetaPayload._imageNumPackets;

evt-&gt;imageDatetimeLen = me-&gt;payloadMsgUnion.flashMetaPayload._imageDatetime_len;
MEMCPY(
    evt-&gt;imageDatetime,
    me-&gt;payloadMsgUnion.flashMetaPayload._imageDatetime,
    evt-&gt;imageDatetimeLen
);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_CommMgr);

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="100,52,4,1,7,-16">
           <action box="-13,5,13,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../2">
          <guard brief="FlashDataPayload?">_DC3FlashDataPayloadMsg == me-&gt;msgPayloadName</guard>
          <action>/* The flash data payload is used to transfer the FW data packets to FlashMgr AO. */

/* 1. Create a FWMetaEvt and send it along to FlashMgr AO to prep the flash */
FWDataEvt *evt = Q_NEW(FWDataEvt, FLASH_DATA_SIG);
evt-&gt;dataCRC  = me-&gt;payloadMsgUnion.flashDataPayload._dataCrc;
evt-&gt;dataLen  = me-&gt;payloadMsgUnion.flashDataPayload._dataBuf_len;
evt-&gt;seqCurr  = me-&gt;payloadMsgUnion.flashDataPayload._seqCurr;
MEMCPY(
    evt-&gt;dataBuf,
    me-&gt;payloadMsgUnion.flashDataPayload._dataBuf,
    evt-&gt;dataLen
);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_CommMgr);

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="100,52,4,1,4,-16">
           <action box="-13,2,13,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../1">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
ERR_printf(&quot;Unexpected payload %s (%d) msg for basic msg: %s (%d). Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;msgPayloadName), me-&gt;msgPayloadName,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName, me-&gt;errorCode);

/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="100,52,5,1,-67">
           <action box="-6,-2,6,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="110,25,4,-1,27,-10">
          <action box="-7,25,7,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="I2CRead?">_DC3I2CReadMsg == me-&gt;basicMsg._msgName</guard>
         <choice target="../../../../../1">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
ERR_printf(&quot;Unexpected payload %s (%d) msg for basic msg: %s (%d). Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;msgPayloadName), me-&gt;msgPayloadName,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName, me-&gt;errorCode);

/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="100,64,5,1,-67">
           <action box="-6,0,6,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="ValidPayload?">_DC3I2CDataPayloadMsg == me-&gt;msgPayloadName</guard>
          <action>/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3I2CDataPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;

</action>
          <choice target="../../../../../4">
           <guard>else</guard>
           <action>/* Create the event and directly post it to the right AO. */
I2CReadReqEvt *i2cReadReqEvt  = Q_NEW(I2CReadReqEvt, I2C1_DEV_RAW_MEM_READ_SIG);
i2cReadReqEvt-&gt;i2cDev         = me-&gt;payloadMsgUnion.i2cDataPayload._i2cDev;
i2cReadReqEvt-&gt;start          = me-&gt;payloadMsgUnion.i2cDataPayload._start;
i2cReadReqEvt-&gt;bytes          = me-&gt;payloadMsgUnion.i2cDataPayload._nBytes;
i2cReadReqEvt-&gt;accessType     = me-&gt;payloadMsgUnion.i2cDataPayload._accType;
QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cReadReqEvt), me);</action>
           <choice_glyph conn="87,70,5,1,-6">
            <action box="-5,-2,5,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../../1">
           <guard brief="BareMetal?">_DC3_ACCESS_BARE == me-&gt;payloadMsgUnion.i2cDataPayload._accType</guard>
           <action>me-&gt;payloadMsgUnion.i2cDataPayload._errorCode = I2C_readDevMem(
      me-&gt;payloadMsgUnion.i2cDataPayload._accType,
      me-&gt;payloadMsgUnion.i2cDataPayload._i2cDev,
      me-&gt;payloadMsgUnion.i2cDataPayload._start,
      me-&gt;payloadMsgUnion.i2cDataPayload._nBytes,
      MAX_I2C_READ_LEN,
      (uint8_t *)me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf,
      (uint16_t *)&amp;(me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf_len)
);</action>
           <choice_glyph conn="87,70,4,1,-3,-54">
            <action box="-8,-5,10,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="100,64,4,-1,6,-13">
           <action box="-10,4,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="110,25,4,-1,39,-10">
          <action box="-8,39,9,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="I2CWrite?">_DC3I2CWriteMsg == me-&gt;basicMsg._msgName</guard>
         <choice target="../../../../../1">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
ERR_printf(&quot;Unexpected payload %s (%d) msg for basic msg: %s (%d). Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;msgPayloadName), me-&gt;msgPayloadName,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName, me-&gt;errorCode);

/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="100,78,5,1,-67">
           <action box="-6,-2,6,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard brief="ValidPayload?">_DC3I2CDataPayloadMsg == me-&gt;msgPayloadName</guard>
          <action>/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;

</action>
          <choice target="../../../../../../1">
           <guard brief="BareMetal?">_DC3_ACCESS_BARE == me-&gt;payloadMsgUnion.i2cDataPayload._accType</guard>
           <action>me-&gt;payloadMsgUnion.i2cDataPayload._errorCode = I2C_writeDevMem(
      me-&gt;payloadMsgUnion.i2cDataPayload._accType,
      me-&gt;payloadMsgUnion.i2cDataPayload._i2cDev,
      me-&gt;payloadMsgUnion.i2cDataPayload._start,
      me-&gt;payloadMsgUnion.i2cDataPayload._nBytes,
      me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf_len,
      (uint8_t *)me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf,
      (uint16_t *)&amp;(me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf_len)
);</action>
           <choice_glyph conn="87,73,4,1,3,-54">
            <action box="-8,1,10,2"/>
           </choice_glyph>
          </choice>
          <choice target="../../../../../4">
           <guard>else</guard>
           <action>/* Create the event and directly post it to the right AO. */
I2CWriteReqEvt *i2cWriteReqEvt  = Q_NEW(I2CWriteReqEvt, I2C1_DEV_RAW_MEM_WRITE_SIG);
i2cWriteReqEvt-&gt;i2cDev         = me-&gt;payloadMsgUnion.i2cDataPayload._i2cDev;
i2cWriteReqEvt-&gt;start          = me-&gt;payloadMsgUnion.i2cDataPayload._start;
i2cWriteReqEvt-&gt;accessType     = me-&gt;payloadMsgUnion.i2cDataPayload._accType;
i2cWriteReqEvt-&gt;bytes          = me-&gt;payloadMsgUnion.i2cDataPayload._nBytes;
MEMCPY(
    i2cWriteReqEvt-&gt;dataBuf,
    me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf,
    me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf_len
);

QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cWriteReqEvt), me);
</action>
           <choice_glyph conn="87,73,5,1,-6">
            <action box="-5,-2,5,2"/>
           </choice_glyph>
          </choice>
          <choice_glyph conn="100,78,4,-1,-5,-13">
           <action box="-10,-5,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="110,25,4,-1,53,-10">
          <action box="-8,51,9,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../2">
         <guard brief="RamTest?">_DC3RamTestMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3RamTestPayloadMsg;

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
//me-&gt;payloadMsgUnion.ramTestPayload._errorCode = me-&gt;errorCode;

QEvt *evt = Q_NEW(QEvt, RAM_TEST_START_SIG);
QACTIVE_POST(AO_FlashMgr, (QEvt *)(evt), AO_CommMgr);
</action>
         <choice_glyph conn="110,25,4,1,37,-26">
          <action box="-8,35,10,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgGetCurrent?">_DC3DbgGetCurrentMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3DbgPayloadMsg;

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.dbgPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.dbgPayload._dbgSettings  = glbDbgModuleConfig;
DBG_printf(&quot;Setting dbgPayload payload with dbgSettings: 0x%08x\n&quot;, me-&gt;payloadMsgUnion.dbgPayload._dbgSettings);</action>
         <choice_glyph conn="110,25,4,1,56,-77">
          <action box="-12,54,11,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgSetCurrent?">_DC3DbgSetCurrentMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3DbgPayloadMsg;

/* Set the debugging modules bitfield to what was sent over, overwriting all settings.*/
DBG_SET_DEBUG_FOR_ALL_MODULES( me-&gt;payloadMsgUnion.dbgPayload._dbgSettings );

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.dbgPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.dbgPayload._dbgSettings  = glbDbgModuleConfig;
DBG_printf(&quot;Setting dbgPayload payload with dbgSettings: 0x%08x\n&quot;, me-&gt;payloadMsgUnion.dbgPayload._dbgSettings);</action>
         <choice_glyph conn="110,25,4,1,59,-77">
          <action box="-12,57,11,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgEnable?">_DC3DbgEnableMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3DbgPayloadMsg;

/* Enable debug module sent over in the message.*/
DBG_ENABLE_DEBUG_FOR_MODULE( me-&gt;payloadMsgUnion.dbgPayload._dbgSettings );

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.dbgPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.dbgPayload._dbgSettings  = glbDbgModuleConfig;
DBG_printf(&quot;Setting dbgPayload payload with dbgSettings: 0x%08x\n&quot;, me-&gt;payloadMsgUnion.dbgPayload._dbgSettings);</action>
         <choice_glyph conn="110,25,4,1,62,-77">
          <action box="-9,60,11,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgDisable?">_DC3DbgDisableMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3DbgPayloadMsg;

/* Disable debug module sent over in the message.*/
DBG_DISABLE_DEBUG_FOR_MODULE( me-&gt;payloadMsgUnion.dbgPayload._dbgSettings );

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.dbgPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.dbgPayload._dbgSettings  = glbDbgModuleConfig;
DBG_printf(&quot;Setting dbgPayload payload with dbgSettings: 0x%08x\n&quot;, me-&gt;payloadMsgUnion.dbgPayload._dbgSettings);</action>
         <choice_glyph conn="110,25,4,1,65,-77">
          <action box="-9,63,11,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgEnableEth?">_DC3DbgEnableEthMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;

/* Enable debug output over ethernet */
DBG_ENABLE_DEVICE( _DC3_DBG_DEV_ETH );

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;
</action>
         <choice_glyph conn="110,25,4,1,68,-77">
          <action box="-12,66,13,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgDisableEth?">_DC3DbgDisableEthMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;

/* Disable debug output over ethernet */
DBG_DISABLE_DEVICE( _DC3_DBG_DEV_ETH );

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;
</action>
         <choice_glyph conn="110,25,4,1,71,-77">
          <action box="-12,69,13,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgEnableSer?">_DC3DbgEnableSerMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;

/* Enable debug output over serial */
DBG_ENABLE_DEVICE( _DC3_DBG_DEV_SER );

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;
</action>
         <choice_glyph conn="110,25,4,1,74,-77">
          <action box="-12,72,13,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../../1">
         <guard brief="DbgDisableSer?">_DC3DbgDisableSerMsg == me-&gt;basicMsg._msgName</guard>
         <action>me-&gt;errorCode = ERR_NONE;

/* Compose Done response.  We can re-use the current structure and it will be used by
 * the exit action of the parent state to send the msg.  Here, we only set up fields
 * that are specific to this response. We can also destructively change the payload
 * name since we are sending a response right after this. */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;

/* Enable debug output over serial */
DBG_DISABLE_DEVICE( _DC3_DBG_DEV_SER );

/* Don't change the basicMsg name since it should be the same in all cases. */
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;
</action>
         <choice_glyph conn="110,25,4,1,77,-77">
          <action box="-12,75,13,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="DBGetElem?">_DC3DBGetElemMsg == me-&gt;basicMsg._msgName</guard>
         <choice target="../../../../../1">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
ERR_printf(&quot;Unexpected payload %s (%d) msg for basic msg: %s (%d). Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;msgPayloadName), me-&gt;msgPayloadName,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName, me-&gt;errorCode);

/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="96,105,5,1,-63">
           <action box="-6,-2,6,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../5">
          <guard brief="ValidPayload?">_DC3DBDataPayloadMsg == me-&gt;msgPayloadName</guard>
          <action>/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3DBDataPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;

/* Create the event and directly post it to the right AO. */
DBReadReqEvt *dbReadReqEvt  = Q_NEW(DBReadReqEvt, DB_GET_ELEM_SIG);
dbReadReqEvt-&gt;dbElem        = me-&gt;payloadMsgUnion.dbDataPayload._elem;
dbReadReqEvt-&gt;accessType    = me-&gt;payloadMsgUnion.dbDataPayload._accType;
/* Ignore the _dataBuf and _dataBuf_len parts of the msg since they are not needed
 * for a read */
QACTIVE_POST(AO_SysMgr, (QEvt *)(dbReadReqEvt), me);</action>
          <choice_glyph conn="96,105,4,1,4,-12">
           <action box="-10,2,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="110,25,4,-1,80,-14">
          <action box="-9,78,9,2"/>
         </choice_glyph>
        </choice>
        <choice>
         <guard brief="DBSetElem?">_DC3DBSetElemMsg == me-&gt;basicMsg._msgName</guard>
         <choice target="../../../../../1">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_MSG_UNEXPECTED_PAYLOAD;
ERR_printf(&quot;Unexpected payload %s (%d) msg for basic msg: %s (%d). Error: 0x%08x\n&quot;,
    CON_msgNameToStr(me-&gt;msgPayloadName), me-&gt;msgPayloadName,
    CON_msgNameToStr(me-&gt;basicMsg._msgName), me-&gt;basicMsg._msgName, me-&gt;errorCode);

/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;</action>
          <choice_glyph conn="96,115,5,1,-63">
           <action box="-6,-2,6,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../5">
          <guard brief="ValidPayload?">_DC3I2CDataPayloadMsg == me-&gt;msgPayloadName</guard>
          <action>/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3DBDataPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;

/* Create the event and directly post it to the right AO. */
DBWriteReqEvt *dbWriteReqEvt  = Q_NEW(DBWriteReqEvt, DB_GET_ELEM_SIG);
dbWriteReqEvt-&gt;dbElem         = me-&gt;payloadMsgUnion.dbDataPayload._elem;
dbWriteReqEvt-&gt;accessType     = me-&gt;payloadMsgUnion.dbDataPayload._accType;
dbWriteReqEvt-&gt;dataLen        = me-&gt;payloadMsgUnion.dbDataPayload._dataBuf_len;
MEMCPY(
    dbWriteReqEvt-&gt;dataBuf,
    me-&gt;payloadMsgUnion.dbDataPayload._dataBuf,
    dbWriteReqEvt-&gt;dataLen
);

QACTIVE_POST(AO_SysMgr, (QEvt *)(dbWriteReqEvt), me);</action>
          <choice_glyph conn="96,115,4,1,-4,-12">
           <action box="-10,-4,10,2"/>
          </choice_glyph>
         </choice>
         <choice_glyph conn="110,25,4,-1,90,-14">
          <action box="-9,90,9,2"/>
         </choice_glyph>
        </choice>
        <choice target="../../../5">
         <guard brief="DBFullReset?">_DC3DBFullResetMsg == me-&gt;basicMsg._msgName</guard>
         <action>/* Has to be set after checking for a valid payload */
me-&gt;msgPayloadName = _DC3StatusPayloadMsg;
me-&gt;basicMsg._msgPayload = me-&gt;msgPayloadName;

/* Create the event and directly post it to the right AO. */
QEvt *dbFullResetEvt  = Q_NEW(QEvt, DB_FULL_RESET_SIG);
QACTIVE_POST(AO_SysMgr, (QEvt *)(dbFullResetEvt), me);</action>
         <choice_glyph conn="110,25,4,1,85,-26">
          <action box="-11,83,13,2"/>
         </choice_glyph>
        </choice>
        <tran_glyph conn="110,21,2,-1,4">
         <action box="0,0,12,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="108,15,14,6">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitForRespFromI2C">
       <documentation>/**
 * @brief    State that waits for a response from I2C1DevMgr AO.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;commOpTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_CLI_WAIT_FOR_SIMPLE_MSG_DONE )
);

me-&gt;errorCode = ERR_COMM_I2C_READ_CMD_TIMEOUT; /* Set the error in case we timeout */</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;commOpTimerEvt);                  /* Disarm timer on exit */

/* Only print error if something went wrong */
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    _DC3_ACCESS_QPC,
    &quot;Leaving WaitForRespFromI2C state with error 0x%08x\n&quot;,
    me-&gt;errorCode
);</exit>
       <tran trig="I2C1_DEV_READ_DONE" target="../../../1">
        <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;
me-&gt;payloadMsgUnion.i2cDataPayload._errorCode = me-&gt;errorCode;

/* Only copy data from the event if no errors occurred to avoid reading invalid data */
if ( ERR_NONE == me-&gt;errorCode ) {
    me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf_len = ((I2CReadDoneEvt const *) e)-&gt;bytes;
    MEMCPY(
        me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf,
        ((I2CReadDoneEvt const *) e)-&gt;dataBuf,
        me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf_len
    );
} else {
    me-&gt;payloadMsgUnion.i2cDataPayload._dataBuf_len = 0;
}</action>
        <tran_glyph conn="65,70,3,1,-32">
         <action box="-19,-2,15,2"/>
        </tran_glyph>
       </tran>
       <tran trig="I2C1_DEV_WRITE_DONE" target="../../../1">
        <action>me-&gt;errorCode = ((I2CWriteDoneEvt const *) e)-&gt;status;
me-&gt;payloadMsgUnion.statusPayload._errorCode = me-&gt;errorCode;</action>
        <tran_glyph conn="65,73,3,1,-32">
         <action box="-19,-2,15,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="65,68,16,6">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state name="WaitForRespFromSysMgr">
       <documentation>/**
 * @brief    State that waits for a response from SysMgr AO.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;commOpTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
);

me-&gt;errorCode = ERR_COMM_DB_ACCESS_CMD_TIMEOUT; /* Set the error in case we timeout */</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;commOpTimerEvt);                  /* Disarm timer on exit */

/* Only print error if something went wrong */
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    _DC3_ACCESS_QPC,
    &quot;Leaving WaitForRespFromSysMgr state with error 0x%08x\n&quot;,
    me-&gt;errorCode
);</exit>
       <tran trig="DB_GET_ELEM_DONE" target="../../../1">
        <action>me-&gt;errorCode = ((DBReadDoneEvt const *) e)-&gt;status;
me-&gt;payloadMsgUnion.dbDataPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.dbDataPayload._elem      = ((DBReadDoneEvt const *) e)-&gt;dbElem;

/* Only copy data from the event if no errors occurred to avoid reading invalid data */
if ( ERR_NONE == me-&gt;errorCode ) {
    me-&gt;payloadMsgUnion.dbDataPayload._dataBuf_len = ((DBReadDoneEvt const *) e)-&gt;dataLen;
    MEMCPY(
        me-&gt;payloadMsgUnion.dbDataPayload._dataBuf,
        ((DBReadDoneEvt const *) e)-&gt;dataBuf,
        me-&gt;payloadMsgUnion.dbDataPayload._dataBuf_len
    );
} else {
    me-&gt;payloadMsgUnion.dbDataPayload._dataBuf_len = 0;
}</action>
        <tran_glyph conn="65,108,3,1,-32">
         <action box="-19,-2,15,2"/>
        </tran_glyph>
       </tran>
       <tran trig="DB_SET_ELEM_DONE" target="../../../1">
        <action>me-&gt;errorCode = ((DBWriteDoneEvt const *) e)-&gt;status;
me-&gt;payloadMsgUnion.dbDataPayload._errorCode = me-&gt;errorCode;
me-&gt;payloadMsgUnion.dbDataPayload._elem      = ((DBReadDoneEvt const *) e)-&gt;dbElem;</action>
        <tran_glyph conn="65,111,3,1,-32">
         <action box="-19,-2,15,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="65,106,19,7">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="62,10,62,137">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="2,5,124,147">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="144,154"/>
   </statechart>
  </class>
  <attribute name="AO_CommMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="CommMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for CommMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */</documentation>
   <code>CommMgr *me = &amp;l_CommMgr;
QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;CommMgr_initial);
QTimeEvt_ctor(&amp;me-&gt;commMgrTimerEvt, COMM_MGR_TIMEOUT_SIG);
QTimeEvt_ctor(&amp;me-&gt;commOpTimerEvt, COMM_OP_TIMEOUT_SIG);</code>
  </operation>
  <operation name="Comm_sendToClient" type="DC3Error_t" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief	Wrapper around serial and UDP send data function.
 * This function acts as a simple wrapper around serial and UDP ethernet send data
 * functions to allow easy posting of events to send out data over those interfaces.
 * @param [in] *evt: LrgDataEvt pointer to event to send.
 * @return: DC3Error_t indicating status of operation.
 */</documentation>
   <parameter name="evt" type="LrgDataEvt*"/>
   <code>DC3Error_t status = ERR_NONE;
if ( _DC3_Serial == evt-&gt;dst ) {
    uint8_t encDataBuf[DC3_MAX_MSG_LEN];
    memset(encDataBuf, 0, sizeof(encDataBuf));
    uint16_t encDataLen = base64_encode(
          (char *)(evt-&gt;dataBuf),
          evt-&gt;dataLen,
          (char *)encDataBuf,
          DC3_MAX_MSG_LEN
    );

    if(encDataLen &lt; 1) {
        status = ERR_SERIAL_MSG_BASE64_ENC_FAILED;
        ERR_printf(
            &quot;Base64 encoding ran out of space, error: 0x%08x\n&quot;,
            status
        );
        /* Set so we don't error out copying.  Client should know how to
         * to properly handle this */
        encDataLen = 1;
    }

    /* Modify the contents of the event with the new encoded data and send
     * it regardless of whether we*/
    evt-&gt;dataLen = encDataLen;
    MEMCPY( evt-&gt;dataBuf, encDataBuf, evt-&gt;dataLen);
    evt-&gt;dst = _DC3_Serial;
    evt-&gt;src = _DC3_Serial;

    /* Directly post to the LWIPMgr AO. */
    QACTIVE_POST( AO_SerialMgr, (QEvt *)(evt), 0 );

} else { /* Always attempt to send over UDP to prevent leaking the event */
    /* No modifications needed to the UDP send so just post it directly to that AO.*/
    /* Directly post to the LWIPMgr AO. */
    QACTIVE_POST( AO_LWIPMgr, (QEvt *)(evt), 0 );
}

/* If we got here, src or dst was not set up properly. */
return status;</code>
  </operation>
 </package>
 <directory name=".">
  <file name="CommMgr_gen.c">
   <text>/**
 * @file    CommMgr.c
 * Declarations for functions for the CommMgr AO.  This state
 * machine handles all incoming messages and their distribution for the
 * bootloader.
 *
 * Note: If editing this file, please make sure to update the CommMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/27/2014
 * @author  Harry Rostovtsev
 * @email   rost0031@gmail.com
 * Copyright (C) 2014 Harry Rostovtsev. All rights reserved.
 *
 * @addtogroup groupComm
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;CommMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp_defs.h&quot;                         /* For time to ticks conversion */
#include &quot;base64_wrapper.h&quot;                            /* For base64 encoding */
#include &quot;crc32compat.h&quot;                             /* For CRC functionality */
#include &quot;version.h&quot;                               /* For version information */
#include &quot;i2c_dev.h&quot;                          /* For I2C device functionality */
#include &quot;serial.h&quot;                               /* For serial functionality */
#include &quot;flash.h&quot;                          /* For Flash device functionality */

#include &quot;I2C1DevMgr.h&quot;                                  /* For I2C Evt types */
#include &quot;LWIPMgr.h&quot;                           /* For ethernet events and AOs */
#include &quot;SerialMgr.h&quot;                           /* For serial events and AOs */
#include &quot;SysMgr.h&quot;                 /* For Database and SysMgr events and AOs */
#include &quot;FlashMgr.h&quot;                          /* For FlashMgr events and AOs */

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DC3_DBG_MODL_COMM );/* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
typedef void (*pFunction)(void);

$declare(AOs::CommMgr)

/* Private defines -----------------------------------------------------------*/
#define LWIP_ALLOWED

/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
pFunction Jump_To_Application;
uint32_t JumpAddress;

static CommMgr l_CommMgr; /* the single instance of the Interstage active object */

/* Global-scope objects ----------------------------------------------------*/
QActive * const AO_CommMgr = (QActive *)&amp;l_CommMgr;  /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::CommMgr_ctor)
$define(AOs::Comm_sendToClient)
$define(AOs::CommMgr)

/**
 * @} end addtogroup groupComm
 */

/******** Copyright (C) 2014 Harry Rostovtsev. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="CommMgr_gen.h">
   <text>/**
 * @file    CommMgr.h
 * Declarations for functions for the CommMgr AO.  This state
 * machine handles all incoming messages and their distribution for the
 * bootloader.
 *
 * Note: If editing this file, please make sure to update the CommMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/27/2014
 * @author  Harry Rostovtsev
 * @email   rost0031@gmail.com
 * Copyright (C) 2014 Harry Rostovtsev. All rights reserved.
 *
 * @addtogroup groupComm
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef COMMMGR_H_
#define COMMMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;DC3CommApi.h&quot;              /* For API for communicating with client */
#include &quot;DC3Signals.h&quot;             /* For QP signals available to the system */

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::CommMgr_ctor)
$declare(AOs::Comm_sendToClient)
$declare(AOs::AO_CommMgr)

/* Don't declare the MsgEvt type here since it needs to be visible to LWIP, 
 * which is a shared port common to any ethernet project.  Instead, it's 
 * declared in Shared.h, which is included by LWIPMgr.h */
/* $declare(Events) */

/**
 * @} end addtogroup groupComm
 */

#endif                                                          /* COMMMGR_H_ */
/******** Copyright (C) 2014 Harry Rostovtsev. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
