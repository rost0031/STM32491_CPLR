/*****************************************************************************
* Model: SysMgr.qm
* File:  ./SysMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::SysMgr_gen.c} .......................................................*/
/**
 * @file    SysMgr.c
 * Declarations for functions for the SysMgr AO.  This state
 * machine handles various system level requests.
 *
 * Note: If editing this file, please make sure to update the SysMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/13/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupSys
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "SysMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp_defs.h"     /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include "I2C1DevMgr.h"                         /* For accessing I2C1 devices */
#include "Shared.h"
#include "i2c_dev.h"
#include "version.h"
#if CPLR_APP
#include "cplr.h"
#elif CPLR_BOOT

#else
    #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
#endif

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DC3_DBG_MODL_SYS ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/

/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Keep track of errors that may occur in the AO */
    DC3Error_t errorCode;

    /**< Native QF queue for deferred request events. */
    QEQueue deferredEvtQueue;

    /**< Storage for deferred event queue. */
    QTimeEvt const * deferredEvtQSto[20];

    /**< QPC timer Used to timeout overall SysMgr interactions. */
    QTimeEvt sysTimerEvt;

    /**< QPC timer Used to timeout DB accesses. */
    QTimeEvt dbTimerEvt;

    /**< Access type of current request (used for DB access) */
    DC3AccessType_t accessType;

    /**< DB command of current request (used for DB access to guarantee a reply) */
    DB_Operation_t dbCmd;

    /**< Buffer that holds the data for read results from any device we have to wait for */
    uint8_t dataBuf[MAX_DB_ELEM_SIZE];

    /**< Length of data in dataBuf */
    uint16_t dataLen;

    /**< DB element to get or set with the current request (used for DB access to guarantee a reply) */
    DC3DBElem_t dbElem;

    /**< Flag that keeps track of whether DB is valid.  Starts out false but gets set to
     * true after checking. */
    bool isDBValid;

    /**< Current retry number. Used throughout the state machine to make sure we don't
     * get stuck in an inf loop when retrying */
    uint8_t currRetry;

    /**< Compiled in version of the DB. This is set only once at the beginning and used for
     * verification and validation of the DB on startup */
    uint16_t dbVersionDef;

    /**< Compiled in magic word that specifies if the DB is intact. This is set only once
     * at the beginning and used for verification and validation of the DB on startup */
    uint32_t dbMagicWordDef;
} SysMgr;

/* protected: */
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e);

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e);
static QState SysMgr_DBFullReset(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check DB element and set it if not properly set.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_DBCheckAndSetElem(SysMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
#define MAX_RETRIES     5       /**< Max number of times to retry operations. */
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static SysMgr l_SysMgr;          /* the single instance of the Active object */

/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_SysMgr = (QActive *)&l_SysMgr;      /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/

extern const DC3Error_t DB_initToDefault( const DC3AccessType_t accessType  );
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for SysMgr "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::SysMgr_ctor} ......................................................*/
void SysMgr_ctor(void) {
    SysMgr *me = &l_SysMgr;
    QActive_ctor(&me->super, (QStateHandler)&SysMgr_initial);

    /* Initialize the deferred event queue and storage for it */
    QEQueue_init(
        &me->deferredEvtQueue,
        (QEvt const **)( me->deferredEvtQSto ),
        Q_DIM(me->deferredEvtQSto)
    );

    QTimeEvt_ctor( &me->sysTimerEvt, SYS_MGR_TIMEOUT_SIG );
    QTimeEvt_ctor( &me->dbTimerEvt, DB_ACCESS_TIMEOUT_SIG );
}


/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
/*${AOs::SysMgr::SM} .......................................................*/
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e) {
    /* ${AOs::SysMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_CommMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&CommMgr_initial);
    QS_FUN_DICTIONARY(&CommMgr_Active);

    /* Subscribe to I2C read and write done signals since it will be publishing them */
    QActive_subscribe((QActive *)me, I2C1_DEV_READ_DONE_SIG);
    QActive_subscribe((QActive *)me, I2C1_DEV_WRITE_DONE_SIG);
    QActive_subscribe((QActive *)me, DB_GET_ELEM_SIG);
    QActive_subscribe((QActive *)me, DB_SET_ELEM_SIG);
    QActive_subscribe((QActive *)me, DB_FULL_RESET_SIG);

    me->isDBValid = false;
    me->dbVersionDef = DB_VERSION_DEF;
    me->dbMagicWordDef = DB_MAGIC_WORD_DEF;

    /* Post to self to validate DB on startup */
    DBCheckSetElemEvt *evt;
    #if CPLR_BOOT
    evt = Q_NEW(DBCheckSetElemEvt, DB_INTRNL_CHK_ELEM_SIG);
    evt->dbElem = _DC3_DB_MAGIC_WORD;
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt, me);

    evt = Q_NEW(DBCheckSetElemEvt, DB_INTRNL_CHK_ELEM_SIG);
    evt->dbElem = _DC3_DB_VERSION;
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt, me);

    evt = Q_NEW(DBCheckSetElemEvt, DB_INTRNL_CHK_ELEM_SIG);
    evt->dbElem = _DC3_DB_BOOT_BUILD_DATETIME;
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt, me);

    evt = Q_NEW(DBCheckSetElemEvt, DB_INTRNL_CHK_ELEM_SIG);
    evt->dbElem = _DC3_DB_BOOT_MAJ;
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt, me);

    evt = Q_NEW(DBCheckSetElemEvt, DB_INTRNL_CHK_ELEM_SIG);
    evt->dbElem = _DC3_DB_BOOT_MIN;
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt, me);
    #endif

    evt = Q_NEW(DBCheckSetElemEvt, DB_INTRNL_CHK_ELEM_SIG);
    evt->dbElem = _DC3_DB_DBG_MODULES;
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt, me);

    evt = Q_NEW(DBCheckSetElemEvt, DB_INTRNL_CHK_ELEM_SIG);
    evt->dbElem = _DC3_DB_DBG_DEVICES;
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt, me);

    return Q_TRAN(&SysMgr_Idle);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active} ...............................................*/
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Post and disarm all the timer events so they can be rearmed at any time */
            QTimeEvt_postIn(
                &me->sysTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->sysTimerEvt);

            QTimeEvt_postIn(
                &me->dbTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->dbTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Idle} .........................................*/
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* Clear out all the variables on entry to Idle state.  By this point, any error
             * feedback should have already happened. */
            me->errorCode       = ERR_NONE;
            me->accessType      = _DC3_ACCESS_NONE;
            me->dbCmd           = DB_OP_NONE;
            me->dataLen         = 0;
            me->currRetry       = 0;
            me->dbElem          = _DC3_DB_MAX_ELEM;
            memset(me->dataBuf, 0, sizeof(me->dataBuf));

            /* recall the request from the private requestQueue */
            QActive_recall(
                (QActive *)me,
                &me->deferredEvtQueue
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_GET_ELEM} */
        case DB_GET_ELEM_SIG: {
            DBG_printf("DB_GET_ELEM, posting DB_READ\n");

            me->dbElem = ((DBReadReqEvt const *)e)->dbElem;
            me->dbCmd = DB_OP_READ;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBReadReqEvt *)e)->super.sig = DB_READ_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_SET_ELEM} */
        case DB_SET_ELEM_SIG: {
            DBG_printf("DB_SET_ELEM, posting DB_WRITE\n");

            me->dbElem = ((DBWriteReqEvt const *)e)->dbElem;
            me->dbCmd = DB_OP_WRITE;
            me->accessType = ((DBWriteReqEvt const *)e)->accessType;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBWriteReqEvt *)e)->super.sig = DB_WRITE_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_FULL_RESET} */
        case DB_FULL_RESET_SIG: {
            /* Need to set some DB element since the reply carries this back.  This is technically
             * the first and most important field being written so this seems like a safe choice.
             * Realistically, the reply shouldn't even include this info so it technically doesn't
             * matter. */
            me->dbElem = _DC3_DB_MAGIC_WORD;
            me->dbCmd = DB_OP_WRITE;
            me->accessType = _DC3_ACCESS_QPC;

            status_ = Q_TRAN(&SysMgr_DBFullReset);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_INTRNL_FULL_R~} */
        case DB_INTRNL_FULL_RESET_SIG: {
            /* Need to set some DB element since the reply carries this back.  This is technically
             * the first and most important field being written so this seems like a safe choice.
             * Realistically, the reply shouldn't even include this info so it technically doesn't
             * matter. */
            me->dbElem = _DC3_DB_MAGIC_WORD;
            me->dbCmd = DB_OP_INTERNAL;
            me->accessType = _DC3_ACCESS_QPC;
            status_ = Q_TRAN(&SysMgr_DBFullReset);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_INTRNL_CHK_EL~} */
        case DB_INTRNL_CHK_ELEM_SIG: {
            me->dbElem = ((DBCheckSetElemEvt const *)e)->dbElem;
            me->dbCmd = DB_OP_INTERNAL;
            me->accessType = _DC3_ACCESS_QPC;
            status_ = Q_TRAN(&SysMgr_DBCheckAndSetElem);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy} .........................................*/
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Arm the timer so if the message can't be processed for some reason, we can get
             * back to idle state.  This timer may be re-armed if some messages require more
             * time to process than others. */
            QTimeEvt_rearm(
                &me->sysTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->sysTimerEvt);                 /* Disarm timer on exit */

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::SYS_MGR_TIMEOUT} */
        case SYS_MGR_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::DB_SET_ELEM, DB_~} */
        case DB_SET_ELEM_SIG: /* intentionally fall through */
        case DB_GET_ELEM_SIG: /* intentionally fall through */
        case DB_INTRNL_CHK_ELEM_SIG: {
            if (QEQueue_getNFree(&me->deferredEvtQueue) > 0) {
               /* defer the request - this event will be handled
                * when the state machine goes back to Idle state */
               QActive_defer((QActive *)me, &me->deferredEvtQueue, e);
            } else {
               /* notify the request sender that the request was ignored.. */
               ERR_printf("Unable to defer DB request\n");
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB} ............................*/
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_ENTRY_SIG: {
            /* Set the error code in case of timeout */
            me->errorCode = ERR_DB_ACCESS_TIMEOUT;

            /* Arm the timer so if DB access is broken, the system can properly return an error */
            QTimeEvt_rearm(
                &me->dbTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            DBG_printf("Starting %s access DB elem %s (%d) via %s\n",
                CON_dbOpToStr(me->dbCmd),
                CON_dbElemToStr( me->dbElem ),
                me->dbElem,
                CON_accessToStr( me->accessType )
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                 /* Disarm timer on exit */

            DBG_printf("Finished %s access DB elem %s (%d) via %s\n",
                CON_dbOpToStr(me->dbCmd),
                CON_dbElemToStr( me->dbElem ),
                me->dbElem,
                CON_accessToStr( me->accessType )
            );

            if ( me->dbCmd == DB_OP_READ ) {
                DBReadDoneEvt *evt = Q_NEW(DBReadDoneEvt, DB_GET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;
                evt->dataLen = me->dataLen;
                MEMCPY(evt->dataBuf, me->dataBuf, evt->dataLen);
                DBG_printf("Publishing DB_GET_ELEM_DONE_SIG with %d len and error 0x%08x\n",evt->dataLen, evt->status);

                if ( _DC3_ACCESS_FRT == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }

            } else if ( me->dbCmd == DB_OP_WRITE ) {
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_SET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( _DC3_ACCESS_FRT == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }
            } else if ( me->dbCmd == DB_OP_INTERNAL ) {
                /* Do nothing in this case.  Internal operations are for DB
                 * validation and similar actions and are initiated intenally so
                 * so nobody is expecting a response */
                if ( ERR_NONE != me->errorCode ) {
                    ERR_printf("Internal DB op failed with error code: 0x%08x\n", me->errorCode);
                }
            } else {
                me->errorCode = ERR_DB_OPERATION_REQUESTED;
                ERR_printf("Invalid DB operation (%d) specified somehow\n", me->dbCmd);
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_ERROR_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( _DC3_ACCESS_FRT == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif
                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }
            }

            /* This will only print if me->errorCode is not ERR_NONE */
            ERR_COND_OUTPUT( me->errorCode, me->accessType,
                "FAILED %s (%d) operation on DB elem %s via %s: Error 0x%08x\n",
                CON_dbOpToStr(me->dbCmd), me->dbCmd, CON_dbElemToStr( me->dbElem ),
                CON_accessToStr(me->accessType),  me->errorCode );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_ACCESS_TIMEOU~} */
        case DB_ACCESS_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_READ} */
        case DB_READ_SIG: {
            /* This is a common function that will do a proper read based on access type and
             * element.  Arguments for buffer size and buffer can be 0 and NULL, respectively
             * since the function will post an event to do the read and it allocates its own
             * buffer space.  Once the read is complete, an event will be posted that signifies
             * the competion of the read and the data will be contained within those events.
             * See I2C1_DEV_READ/WRITE_DONE_SIG and DB_FLASH_READ_DONE_SIG handlers. */
            me->errorCode = DB_read(
                ((DBReadReqEvt const *)e)->dbElem,        // What element to read
                ((DBReadReqEvt const *)e)->accessType,    // What access to use
                0, NULL                                   // buffer size and pointer
            );

            /* This will only print out if me->errorCode is not ERR_NONE */
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "%s access of DB elem %s (%d) via %s: Error 0x%08x\n",
                CON_dbOpToStr(me->dbCmd),
                CON_dbElemToStr( me->dbElem ),
                me->dbElem,
                CON_accessToStr( me->accessType),
                me->errorCode
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_WRITE} */
        case DB_WRITE_SIG: {
            /* This is a common function that will do a proper read based on access type and
             * element.  Arguments for buffer size and buffer can be 0 and NULL, respectively
             * since the function will post an event to do the read and it allocates its own
             * buffer space.  Once the read is complete, an event will be posted that signifies
             * the competion of the read and the data will be contained within those events.
             * See I2C1_DEV_READ/WRITE_DONE_SIG and DB_FLASH_READ_DONE_SIG handlers. */
            me->errorCode = DB_write(
                ((DBWriteReqEvt const *)e)->dbElem,         // Element to write
                ((DBWriteReqEvt const *)e)->accessType,     // Access type to use
                MAX_DB_ELEM_SIZE,                           // Max size of buffer
                ((DBWriteReqEvt const *)e)->dataBuf         // Buffer containing data to write
            );

            /* This will only print out if me->errorCode is not ERR_NONE */
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "%s access of DB elem %s (%d) via %s: Error 0x%08x\n",
                CON_dbOpToStr(me->dbCmd),
                CON_dbElemToStr( me->dbElem ),
                me->dbElem,
                CON_accessToStr( me->accessType),
                me->errorCode
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_WRITE_D~} */
        case I2C1_DEV_WRITE_DONE_SIG: {
            me->errorCode = ((I2CWriteDoneEvt const *) e)->status;

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_FLASH_READ_DO~} */
        case DB_FLASH_READ_DONE_SIG: {
            me->errorCode = ((DBReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((DBReadDoneEvt const *) e)->dataLen;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                } else {
                    MEMCPY(me->dataBuf, ((DBReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Busy);
            break;
        }
    }
    return status_;
}
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBFullReset} ...............*/
static QState SysMgr_DBFullReset(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBFullReset} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );


            /* This function will fill out the appropriate data and post the event to reset the DB */
            me->errorCode = DB_initToDefault( me->accessType );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBFullReset} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check DB element and set it if not properly set.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBCheckAndSetEle~} .........*/
static QState SysMgr_DBCheckAndSetElem(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBCheckAndSetEle~} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );

            /* This function will post the event to read the element.  Don't need a buffer
             * since the data will come back via an event with its own buffer. */
            me->errorCode = DB_read( me->dbElem, me->accessType, 0, NULL );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBCheckAndSetEle~} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBCheckAndSetEle~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            /* Whie DB reads could certainly involve reading from sources other than EEPROM,
             * it's only worth checking the RW sources since they are the only ones that could
             * become corrupted. Hence, only I2c1_DEV_READ_DONE signal is being checked. */

            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            /* This function will compare the passed in value of the element to the compiled
             * default and report back via error code. */
            me->errorCode = DB_chkElem(
                me->dbElem,
                me->accessType,
                ((I2CReadDoneEvt const *) e)->bytes,
                ((I2CReadDoneEvt const *) e)->dataBuf
            );

            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            WRN_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Checking DB elem %s (%d): Error 0x%08x \n",
                me->errorCode,
                CON_dbElemToStr( me->dbElem ),
                me->dbElem
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBCheckAndSetEle~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (ERR_NONE == me->errorCode) {
                status_ = Q_TRAN(&SysMgr_Idle);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBCheckAndSetEle~::I2C1_DEV_READ_DO~::[else]} */
            else {
                switch( me->errorCode ) {

                    case ERR_DB_VER_MISMATCH:   /* Intentionally fall though */
                        /* For now, handle DB version mismatch simply.  Later,
                         * if multiple versions of DB come into existence, this
                         * case will have to be handled differently. */
                    case ERR_DB_CHK_ELEM_NEEDS_RESET: {
                        /* Get the default value that needs to be set */
                        me->errorCode = DB_getEepromDefaultElem(
                            me->dbElem, me->accessType, MAX_DB_ELEM_SIZE, me->dataBuf );
                        if ( ERR_NONE == me->errorCode ) {
                            /* If no errors, write the default to EEPROM */
                            DB_write( me->dbElem, me->accessType,
                                DB_getElemSize(me->dbElem), me->dataBuf );
                        }
                        break;
                    }
                    case ERR_DB_CHK_DBG_MODULES_MISMATCH: {
                        uint32_t dbgModules = 0;
                        MEMCPY(
                            (uint8_t *)&dbgModules,
                            ((I2CReadDoneEvt const *) e)->dataBuf,
                            DB_getElemSize(me->dbElem)
                        );
                        DBG_SET_DEBUG_FOR_ALL_MODULES( dbgModules );

                        /* Self post to get back to Idle */
                        QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
                        QACTIVE_POST(AO_SysMgr, evt, me);
                        break;
                    }
                    case ERR_DB_CHK_DBG_DEVICES_MISMATCH: {
                        DBG_SET_DEBUG_FOR_ALL_DEVICES( ((I2CReadDoneEvt const *) e)->dataBuf[0] );
                        /* Self post to get back to Idle  */
                        QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
                        QACTIVE_POST(AO_SysMgr, evt, me);
                        break;
                    }
                    case ERR_DB_NOT_INIT: /* Intentionally fall though */
                    default:
                        /* This function will fill out the appropriate data and
                         * post the event to reset the DB */
                        me->errorCode = DB_initToDefault( me->accessType );
                        break;
                }
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupSys
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
