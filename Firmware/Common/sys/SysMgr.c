/*****************************************************************************
* Model: SysMgr.qm
* File:  ./SysMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::SysMgr_gen.c} .......................................................*/
/**
 * @file    SysMgr.c
 * Declarations for functions for the SysMgr AO.  This state
 * machine handles various system level requests.
 *
 * Note: If editing this file, please make sure to update the SysMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/13/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupSys
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "SysMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp_defs.h"     /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include "I2C1DevMgr.h"                         /* For accessing I2C1 devices */
#include "Shared.h"
#include "i2c_dev.h"
#include "version.h"
#if CPLR_APP
#include "cplr.h"
#elif CPLR_BOOT

#else
    #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
#endif

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DC3_DBG_MODL_SYS ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/

/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Keep track of errors that may occur in the AO */
    DC3Error_t errorCode;

    /**< Native QF queue for deferred request events. */
    QEQueue deferredEvtQueue;

    /**< Storage for deferred event queue. */
    QTimeEvt const * deferredEvtQSto[20];

    /**< QPC timer Used to timeout overall SysMgr interactions. */
    QTimeEvt sysTimerEvt;

    /**< QPC timer Used to timeout DB accesses. */
    QTimeEvt dbTimerEvt;

    /**< Access type of current request (used for DB access) */
    DC3AccessType_t accessType;

    /**< DB command of current request (used for DB access to guarantee a reply) */
    DB_Operation_t dbCmd;

    /**< Buffer that holds the data for read results from any device we have to wait for */
    uint8_t dataBuf[MAX_DB_ELEM_SIZE];

    /**< Length of data in dataBuf */
    uint16_t dataLen;

    /**< DB element to get or set with the current request (used for DB access to guarantee a reply) */
    DC3DBElem_t dbElem;

    /**< Flag that keeps track of whether DB is valid.  Starts out false but gets set to
     * true after checking. */
    bool isDBValid;

    /**< Current retry number. Used throughout the state machine to make sure we don't
     * get stuck in an inf loop when retrying */
    uint8_t currRetry;

    /**< Compiled in version of the DB. This is set only once at the beginning and used for
     * verification and validation of the DB on startup */
    uint16_t dbVersionDef;

    /**< Compiled in magic word that specifies if the DB is intact. This is set only once
     * at the beginning and used for verification and validation of the DB on startup */
    uint32_t dbMagicWordDef;
} SysMgr;

/* protected: */
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e);

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check DB magic number and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_DBMagicWordCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the DB magic word to default values.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_ResetDBMagicWord(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check DB version and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_DBVersionCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check bootloader build datetime and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_BootLdrBuildDTCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the DB version to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_ResetDBVersion(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the bootloader build datetime.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_SetBootLdrDatetime(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the bootloader major version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_SetBootLdrMajVer(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check bootloader major version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_BootLdrMajVerCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check bootloader minor version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_BootLdrMinVerCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the bootloader minor version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_SetBootLdrMinVer(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Small timeout to make sure that retries don't overwhelm the logging
 * system.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Wait2(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Small timeout to make sure that retries don't overwhelm the logging
 * system.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Wait1(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check DB debug modules and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_DBGetDebugModules(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the DB debug modules to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_ResetDBDbgModules(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check DB debug modules and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_DBGetDebugDevices(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the DB debug Devices to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_ResetDBDbgDevices(SysMgr * const me, QEvt const * const e);
static QState SysMgr_DBFullReset(SysMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
#define MAX_RETRIES     5       /**< Max number of times to retry operations. */
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static SysMgr l_SysMgr;          /* the single instance of the Active object */

/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_SysMgr = (QActive *)&l_SysMgr;      /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for SysMgr "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::SysMgr_ctor} ......................................................*/
void SysMgr_ctor(void) {
    SysMgr *me = &l_SysMgr;
    QActive_ctor(&me->super, (QStateHandler)&SysMgr_initial);

    /* Initialize the deferred event queue and storage for it */
    QEQueue_init(
        &me->deferredEvtQueue,
        (QEvt const **)( me->deferredEvtQSto ),
        Q_DIM(me->deferredEvtQSto)
    );

    QTimeEvt_ctor( &me->sysTimerEvt, SYS_MGR_TIMEOUT_SIG );
    QTimeEvt_ctor( &me->dbTimerEvt, DB_ACCESS_TIMEOUT_SIG );
}


/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
/*${AOs::SysMgr::SM} .......................................................*/
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e) {
    /* ${AOs::SysMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_CommMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&CommMgr_initial);
    QS_FUN_DICTIONARY(&CommMgr_Active);

    /* Subscribe to I2C read and write done signals since it will be publishing them */
    QActive_subscribe((QActive *)me, I2C1_DEV_READ_DONE_SIG);
    QActive_subscribe((QActive *)me, I2C1_DEV_WRITE_DONE_SIG);
    QActive_subscribe((QActive *)me, DB_GET_ELEM_SIG);
    QActive_subscribe((QActive *)me, DB_SET_ELEM_SIG);
    QActive_subscribe((QActive *)me, DB_FULL_RESET_SIG);

    me->isDBValid = false;
    me->dbVersionDef = DB_VERSION_DEF;
    me->dbMagicWordDef = DB_MAGIC_WORD_DEF;

    /* Post to self to validate DB on startup */
    QEvt *evt = Q_NEW(QEvt, DB_INTRNL_CHECK_SETTINGS_SIG);
    QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);

    #if CPLR_BOOT
    /* If this is the bootloader, also validate the bootloader build datetime
     * and version in the DB. */
    QEvt *evt1 = Q_NEW(QEvt, DB_INTRNL_CHECK_BOOTLDR_VER_SIG);
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt1, me);
    #endif
    return Q_TRAN(&SysMgr_Idle);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active} ...............................................*/
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Post and disarm all the timer events so they can be rearmed at any time */
            QTimeEvt_postIn(
                &me->sysTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->sysTimerEvt);

            QTimeEvt_postIn(
                &me->dbTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->dbTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Idle} .........................................*/
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* Clear out all the variables on entry to Idle state.  By this point, any error
             * feedback should have already happened. */
            me->errorCode       = ERR_NONE;
            me->accessType      = _DC3_ACCESS_NONE;
            me->dbCmd           = DB_OP_NONE;
            me->dataLen         = 0;
            me->currRetry       = 0;
            memset(me->dataBuf, 0, sizeof(me->dataBuf));

            /* recall the request from the private requestQueue */
            QActive_recall(
                (QActive *)me,
                &me->deferredEvtQueue
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_GET_ELEM} */
        case DB_GET_ELEM_SIG: {
            DBG_printf("DB_GET_ELEM, posting DB_READ\n");

            me->dbElem = ((DBReadReqEvt const *)e)->dbElem;
            me->dbCmd = DB_OP_READ;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBReadReqEvt *)e)->super.sig = DB_READ_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_SET_ELEM} */
        case DB_SET_ELEM_SIG: {
            DBG_printf("DB_SET_ELEM, posting DB_WRITE\n");

            me->dbElem = ((DBReadReqEvt const *)e)->dbElem;
            me->dbCmd = DB_OP_WRITE;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBWriteReqEvt *)e)->super.sig = DB_WRITE_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_INTRNL_CHECK_~} */
        case DB_INTRNL_CHECK_SETTINGS_SIG: {
            me->dbCmd = DB_OP_INTERNAL;
            status_ = Q_TRAN(&SysMgr_DBMagicWordCheck);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_INTRNL_CHECK_~} */
        case DB_INTRNL_CHECK_BOOTLDR_VER_SIG: {
            me->dbCmd = DB_OP_INTERNAL;
            status_ = Q_TRAN(&SysMgr_BootLdrBuildDTCheck);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_FULL_RESET} */
        case DB_FULL_RESET_SIG: {
            /* Need to set some DB element since the reply carries this back.  This is technically
             * the first and most important field being written so this seems like a safe choice.
             * Realistically, the reply shouldn't even include this info so it technically doesn't
             * matter. */
            me->dbElem = _DC3_DB_MAGIC_WORD;
            me->dbCmd = DB_OP_WRITE;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;

            status_ = Q_TRAN(&SysMgr_DBFullReset);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_INTRNL_FULL_R~} */
        case DB_INTRNL_FULL_RESET_SIG: {
            me->dbCmd = DB_OP_INTERNAL;
            me->accessType = _DC3_ACCESS_QPC;
            status_ = Q_TRAN(&SysMgr_DBFullReset);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy} .........................................*/
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Arm the timer so if the message can't be processed for some reason, we can get
             * back to idle state.  This timer may be re-armed if some messages require more
             * time to process than others. */
            QTimeEvt_rearm(
                &me->sysTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->sysTimerEvt);                 /* Disarm timer on exit */

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::SYS_MGR_TIMEOUT} */
        case SYS_MGR_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::DB_SET_ELEM, DB_~} */
        case DB_SET_ELEM_SIG: /* intentionally fall through */
        case DB_GET_ELEM_SIG: /* intentionally fall through */
        case DB_INTRNL_CHECK_SETTINGS_SIG: /* intentionally fall through */
        case DB_INTRNL_CHECK_BOOTLDR_VER_SIG: {
            if (QEQueue_getNFree(&me->deferredEvtQueue) > 0) {
               /* defer the request - this event will be handled
                * when the state machine goes back to Idle state */
               QActive_defer((QActive *)me, &me->deferredEvtQueue, e);
            } else {
               /* notify the request sender that the request was ignored.. */
               ERR_printf("Unable to defer DB request\n");
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB} ............................*/
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_ENTRY_SIG: {
            /* Set the error code in case of timeout */
            me->errorCode = ERR_DB_ACCESS_TIMEOUT;

            /* Arm the timer so if DB access is broken, the system can properly return an error */
            QTimeEvt_rearm(
                &me->dbTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                 /* Disarm timer on exit */

            if ( me->dbCmd == DB_OP_READ ) {
                DBReadDoneEvt *evt = Q_NEW(DBReadDoneEvt, DB_GET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;
                evt->dataLen = me->dataLen;
                MEMCPY(evt->dataBuf, me->dataBuf, evt->dataLen);
                DBG_printf("Publishing DB_GET_ELEM_DONE_SIG with %d len and error 0x%08x\n",evt->dataLen, evt->status);

                if ( _DC3_ACCESS_FRT == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }

            } else if ( me->dbCmd == DB_OP_WRITE ) {
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_SET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( _DC3_ACCESS_FRT == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }
            } else if ( me->dbCmd == DB_OP_INTERNAL ) {
                /* Do nothing in this case.  Internal operations are for DB
                 * validation and similar actions and are initiated intenally so
                 * so nobody is expecting a response */
                if ( ERR_NONE != me->errorCode ) {
                    ERR_printf("Internal DB op failed with error code: 0x%08x\n", me->errorCode);
                }
            } else {
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                ERR_printf("Invalid DB operation (%d) specified somehow\n", me->dbCmd);
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_ERROR_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( _DC3_ACCESS_FRT == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif
                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_ACCESS_TIMEOU~} */
        case DB_ACCESS_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_READ} */
        case DB_READ_SIG: {
            LOG_printf("DB_READ via %s access to read: %s (%d)\n",
                CON_accessToStr( ((DBReadReqEvt const *)e)->accessType ),
                CON_dbElemToStr( ((DBReadReqEvt const *)e)->dbElem ),
                ((DBReadReqEvt const *)e)->dbElem
            );

            /* Find where the element lives */
            DB_ElemLoc_t loc = DB_getElemLoc( ((DBReadReqEvt const *)e)->dbElem );

               /* 3. Call the location dependent functions to retrieve the data from DB */
            switch( loc ) {
                case DB_EEPROM:                           /* Intentionally fall through */
                case DB_SN_ROM:                           /* Intentionally fall through */
                case DB_UI_ROM:
                    ;
                    /* Create the event and directly post it to the right AO. */
                    I2CReadReqEvt *i2cReadReqEvt  = Q_NEW(I2CReadReqEvt, I2C1_DEV_RAW_MEM_READ_SIG);
                    i2cReadReqEvt->i2cDev         = DB_getI2CDev(loc);
                    i2cReadReqEvt->addr           = I2C_getMemAddr( i2cReadReqEvt->i2cDev ) + DB_getElemOffset(((DBReadReqEvt const *)e)->dbElem);
                    i2cReadReqEvt->bytes          = DB_getElemSize(((DBReadReqEvt const *)e)->dbElem);
                    i2cReadReqEvt->accessType     = me->accessType;
                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cReadReqEvt), me);
                    break;
                case DB_GPIO:
                    me->errorCode = ERR_UNIMPLEMENTED;
                    QEvt *evtGPIO = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtGPIO, me);
                    break;
                case DB_FLASH:
                    ;
                    me->errorCode = DB_readEEPROM(
                        ((DBReadReqEvt const *)e)->dbElem,
                        MAX_DB_ELEM_SIZE,
                        me->dataBuf,
                        &(me->dataLen)
                    );
                    QEvt *evtFlash = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtFlash, me);
                    break;
                    /* Add more locations here. Anything that fails will go to the default
                     * case and get logged as an error. */
                default:
                    me->errorCode  = ERR_DB_ELEM_NOT_FOUND;
                    QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtNotFound, me);
                    break;
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_WRITE} */
        case DB_WRITE_SIG: {
            LOG_printf("DB_WRITE via %s access to write: %s (%d)\n",
                CON_accessToStr( ((DBWriteReqEvt const *)e)->accessType ),
                CON_dbElemToStr( ((DBWriteReqEvt const *)e)->dbElem ),
                ((DBWriteReqEvt const *)e)->dbElem
            );

            /* Find where the element lives */
            DB_ElemLoc_t loc = DB_getElemLoc( ((DBWriteReqEvt const *)e)->dbElem );

               /* 3. Call the location dependent functions to retrieve the data from DB */
            switch( loc ) {
                case DB_EEPROM:
                    ;
                    /* Create the event and directly post it to the right AO. */
                    I2CWriteReqEvt *i2cWriteReqEvt  = Q_NEW(I2CWriteReqEvt, I2C1_DEV_RAW_MEM_WRITE_SIG);
                    i2cWriteReqEvt->i2cDev         = DB_getI2CDev(loc);
                    i2cWriteReqEvt->addr           = I2C_getMemAddr( i2cWriteReqEvt->i2cDev ) + DB_getElemOffset(((DBWriteReqEvt const *)e)->dbElem);
                    i2cWriteReqEvt->bytes          = DB_getElemSize(((DBWriteReqEvt const *)e)->dbElem);
                    i2cWriteReqEvt->accessType     = me->accessType;
                    MEMCPY(i2cWriteReqEvt->dataBuf, ((DBWriteReqEvt const *)e)->dataBuf, i2cWriteReqEvt->bytes);
                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cWriteReqEvt), me);
                    DBG_printf("Posting a write req to I2C1DevMgr\n");
                    break;
                case DB_GPIO:                             /* Intentionally fall through */
                case DB_SN_ROM:                           /* Intentionally fall through */
                case DB_UI_ROM:                           /* Intentionally fall through */
                case DB_FLASH:
                    me->errorCode = ERR_DB_ELEM_IS_READ_ONLY;
                    QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evt, me);
                    break;
                    /* Add more locations here. Anything that fails will go to the default
                     * case and get logged as an error. */
                default:
                    me->errorCode  = ERR_DB_ELEM_NOT_FOUND;
                    QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtNotFound, me);
                    break;
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_WRITE_D~} */
        case I2C1_DEV_WRITE_DONE_SIG: {
            me->errorCode = ((I2CWriteDoneEvt const *) e)->status;

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check DB magic number and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck} ..........*/
static QState SysMgr_DBMagicWordCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_MAGIC_WORD;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            if ( ((I2CReadDoneEvt const *) e)->bytes > MAX_DB_ELEM_SIZE ) {
                /* This should be considered a pretty critical error. */
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                goto END_ERROR_CHECK;
            }

            if( !DB_isArraysMatch(
                ((I2CReadDoneEvt const *) e)->dataBuf,
                (uint8_t *)&(me->dbMagicWordDef),
                ((I2CReadDoneEvt const *) e)->bytes ) ) {
                /* If the check fails, set the error code */
                me->errorCode = ERR_DB_NOT_INIT;

                WRN_printf("Invalid DB magic word. Error 0x%08x\n", me->errorCode);
                WRN_printf("Compiled: bytes: %x\n", me->dbMagicWordDef );

                CON_hexToStr(
                    ((I2CReadDoneEvt const *) e)->dataBuf, // data to convert
                    ((I2CReadDoneEvt const *) e)->bytes, // length of data to convert
                    (char *)me->dataBuf,                 // where to write output
                    sizeof(me->dataBuf),                 // max size of output buffer
                    &(me->dataLen),                      // size of the resulting output
                    0,                                   // no columns
                    ' ',                                 // separator
                    false                                // bPrintX
                );

                WRN_printf("In DB   : bytes: %s\n", me->dataBuf );

                goto END_ERROR_CHECK;
            }

            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Error 0x%08x reading DB elem %s (%d)\n",
                me->errorCode,
                CON_dbElemToStr(_DC3_DB_MAGIC_WORD),
                _DC3_DB_MAGIC_WORD
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~::[NoError?]} */
            if (ERR_NONE == me->errorCode) {
                status_ = Q_TRAN(&SysMgr_DBVersionCheck);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&SysMgr_ResetDBMagicWord);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the DB magic word to default values.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBMagicWord} ..........*/
static QState SysMgr_ResetDBMagicWord(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBMagicWord} */
        case Q_ENTRY_SIG: {
            WRN_printf("Resetting %s to default...\n", CON_dbElemToStr(_DC3_DB_MAGIC_WORD));

            uint32_t dbMagicWord = DB_MAGIC_WORD_DEF;

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_MAGIC_WORD;
            evt->dataLen =  DB_getElemSize(_DC3_DB_MAGIC_WORD);
            MEMCPY(evt->dataBuf, (uint8_t *)&dbMagicWord, evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBMagicWord::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_ResetDBVersion);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check DB version and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck} ............*/
static QState SysMgr_DBVersionCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_VERSION;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            if ( ((I2CReadDoneEvt const *) e)->bytes > MAX_DB_ELEM_SIZE ) {
                /* This should be considered a pretty critical error. */
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                goto END_ERROR_CHECK;
            }

            if( !DB_isArraysMatch(
                ((I2CReadDoneEvt const *) e)->dataBuf,
                (uint8_t *)&(me->dbVersionDef),
                ((I2CReadDoneEvt const *) e)->bytes ) ) {
                /* If the check fails, set the error code */
                me->errorCode = ERR_DB_NOT_INIT;

                WRN_printf("Invalid DB version. Error 0x%08x\n", me->errorCode);
                WRN_printf("Compiled: bytes: %x\n", me->dbVersionDef );

                CON_hexToStr(
                    ((I2CReadDoneEvt const *) e)->dataBuf, // data to convert
                    ((I2CReadDoneEvt const *) e)->bytes, // length of data to convert
                    (char *)me->dataBuf,                 // where to write output
                    sizeof(me->dataBuf),                 // max size of output buffer
                    &(me->dataLen),                      // size of the resulting output
                    0,                                   // no columns
                    ' ',                                 // separator
                    false                                // bPrintX
                );

                WRN_printf("In DB   : bytes: %s\n", me->dataBuf );

                goto END_ERROR_CHECK;
            }

            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Error 0x%08x reading DB elem %s (%d)\n",
                me->errorCode,
                CON_dbElemToStr(_DC3_DB_VERSION),
                _DC3_DB_VERSION
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~::[NoError?]} */
            if (ERR_NONE == me->errorCode) {
                status_ = Q_TRAN(&SysMgr_DBGetDebugModules);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&SysMgr_ResetDBVersion);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check bootloader build datetime and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~} .........*/
static QState SysMgr_BootLdrBuildDTCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~} */
        case Q_ENTRY_SIG: {
            DBG_printf("Validating %s (%d)...\n",
                CON_dbElemToStr(_DC3_DB_BOOT_BUILD_DATETIME),
                _DC3_DB_BOOT_BUILD_DATETIME);

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_BOOT_BUILD_DATETIME;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            if ( ((I2CReadDoneEvt const *) e)->bytes > MAX_DB_ELEM_SIZE ) {
                /* This should be considered a pretty critical error. */
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                goto END_ERROR_CHECK;
            }

            if( !DB_isArraysMatch(
                ((I2CReadDoneEvt const *) e)->dataBuf,
                (uint8_t *)BUILD_DATE,
                ((I2CReadDoneEvt const *) e)->bytes ) ) {
                /* If the check fails, set the error code */
                me->errorCode = ERR_DB_DATETIME_MISMATCH;

                WRN_printf("Bootloader datetime mismatch. Error 0x%08x\n", me->errorCode);
                LOG_printf("Note, this error is expected on first boot after a new bootloader was just flashed\n");

                CON_hexToStr(
                    ((I2CReadDoneEvt const *) e)->dataBuf, // data to convert
                    ((I2CReadDoneEvt const *) e)->bytes, // length of data to convert
                    (char *)me->dataBuf,                 // where to write output
                    sizeof(me->dataBuf),                 // max size of output buffer
                    &me->dataLen,                        // size of the resulting output
                    0,                                   // no columns
                    ' ',                                 // separator
                    false                                // bPrintX
                );

                WRN_printf("In DB:    bytes: %s, string: %s\n",
                    me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf
                );

                CON_hexToStr(
                    (uint8_t *)BUILD_DATE,               // data to convert
                    strlen(BUILD_DATE),                  // length of data to convert
                    (char *)me->dataBuf,                 // where to write output
                    sizeof(me->dataBuf),                 // max size of output buffer
                    &me->dataLen,                        // size of the resulting output
                    0,                                   // no columns
                    ' ',                                 // separator
                    false                                 // bPrintX
                );

                WRN_printf("Compiled: bytes: %s, string: %s\n",
                    me->dataBuf, BUILD_DATE
                );

                goto END_ERROR_CHECK;
            }

            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Error 0x%08x reading DB elem %s (%d)\n",
                me->errorCode,
                CON_dbElemToStr(_DC3_DB_BOOT_BUILD_DATETIME),
                _DC3_DB_BOOT_BUILD_DATETIME
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (me->errorCode == ERR_NONE) {
                //me->errorCode = DB_checkDTMatch( ((I2CReadDoneEvt const *) e)->dataBuf, (uint8_t *)BUILD_DATE );

                DBG_printf("Bootloader datetime match\n");
                status_ = Q_TRAN(&SysMgr_BootLdrMajVerCheck);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&SysMgr_SetBootLdrDatetime);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the DB version to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion} ............*/
static QState SysMgr_ResetDBVersion(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion} */
        case Q_ENTRY_SIG: {
            WRN_printf("Resetting %s to default...\n", CON_dbElemToStr(_DC3_DB_VERSION));

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_VERSION;
            evt->dataLen =  DB_getElemSize(_DC3_DB_VERSION);
            uint16_t dbVersion = DB_VERSION_DEF;
            MEMCPY(evt->dataBuf, (uint8_t *)&dbVersion, evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            me->currRetry++;
            status_ = Q_TRAN(&SysMgr_ResetDBDbgModules);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the bootloader build datetime.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrDateti~} .........*/
static QState SysMgr_SetBootLdrDatetime(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrDateti~} */
        case Q_ENTRY_SIG: {
            WRN_printf("Setting %s (%d) in DB to %s.\n",
                CON_dbElemToStr(_DC3_DB_BOOT_BUILD_DATETIME),
                _DC3_DB_BOOT_BUILD_DATETIME, BUILD_DATE);

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_BOOT_BUILD_DATETIME;
            evt->dataLen =  DB_getElemSize(_DC3_DB_BOOT_BUILD_DATETIME);
            MEMCPY(evt->dataBuf, (uint8_t *)BUILD_DATE, evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrDateti~::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_SetBootLdrMajVer);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the bootloader major version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMajVer} ..........*/
static QState SysMgr_SetBootLdrMajVer(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMajVer} */
        case Q_ENTRY_SIG: {
            WRN_printf("Setting %s (%d) in DB to %s.\n",
                CON_dbElemToStr(_DC3_DB_BOOT_MAJ),
                _DC3_DB_BOOT_MAJ, FW_VER_MAJOR);

            /* Post to SysMgr to set the major version since we no longer trust it */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_BOOT_MAJ;
            evt->dataLen =  DB_getElemSize(_DC3_DB_BOOT_MAJ);
            evt->dataBuf[0] = FW_VER_MAJOR;

            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMajVer::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_SetBootLdrMinVer);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check bootloader major version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~} .........*/
static QState SysMgr_BootLdrMajVerCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~} */
        case Q_ENTRY_SIG: {
            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_BOOT_MAJ;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            if ( ((I2CReadDoneEvt const *) e)->bytes > MAX_DB_ELEM_SIZE ) {
                /* This should be considered a pretty critical error. */
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                goto END_ERROR_CHECK;
            }

            if( ((I2CReadDoneEvt const *) e)->dataBuf[0] != FW_VER_MAJOR ) {
                me->errorCode = ERR_DB_INVALID_MAJ_VER_MISMATCH;
                WRN_printf("Bootloader %s mismatch. DB: %d, Compiled: %d\n",
                    CON_dbElemToStr(_DC3_DB_BOOT_MAJ),
                    ((I2CReadDoneEvt const *) e)->dataBuf[0], FW_VER_MAJOR
                );
                goto END_ERROR_CHECK;
            }


            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Error 0x%08x reading DB elem %s (%d)\n",
                me->errorCode,
                CON_dbElemToStr(_DC3_DB_BOOT_MAJ),
                _DC3_DB_BOOT_MAJ
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (me->errorCode == ERR_NONE) {
                status_ = Q_TRAN(&SysMgr_BootLdrMinVerCheck);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&SysMgr_SetBootLdrMajVer);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check bootloader minor version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~} .........*/
static QState SysMgr_BootLdrMinVerCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~} */
        case Q_ENTRY_SIG: {
            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_BOOT_MIN;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            if ( ((I2CReadDoneEvt const *) e)->bytes > MAX_DB_ELEM_SIZE ) {
                /* This should be considered a pretty critical error. */
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                goto END_ERROR_CHECK;
            }

            if( ((I2CReadDoneEvt const *) e)->dataBuf[0] != FW_VER_MINOR ) {
                me->errorCode = ERR_DB_INVALID_MIN_VER_MISMATCH;
                WRN_printf("Bootloader %s mismatch. DB: %d, Compiled: %d\n",
                    CON_dbElemToStr(_DC3_DB_BOOT_MIN),
                    ((I2CReadDoneEvt const *) e)->dataBuf[0], FW_VER_MINOR
                );
                goto END_ERROR_CHECK;
            }


            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Error 0x%08x reading DB elem %s (%d)\n",
                me->errorCode,
                CON_dbElemToStr(_DC3_DB_BOOT_MIN),
                _DC3_DB_BOOT_MIN
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (me->errorCode == ERR_NONE) {
                LOG_printf("Bootloader version and build datetime validation complete\n");
                status_ = Q_TRAN(&SysMgr_Idle);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&SysMgr_SetBootLdrMinVer);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the bootloader minor version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer} ..........*/
static QState SysMgr_SetBootLdrMinVer(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer} */
        case Q_ENTRY_SIG: {
            WRN_printf("Setting %s (%d) in DB to %s.\n",
                CON_dbElemToStr(_DC3_DB_BOOT_MIN),
                _DC3_DB_BOOT_MIN, FW_VER_MINOR);

            /* Post to SysMgr to set the major version since we no longer trust it */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_BOOT_MIN;
            evt->dataLen =  DB_getElemSize(_DC3_DB_BOOT_MIN);
            evt->dataBuf[0] = FW_VER_MINOR;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            me->currRetry++;
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer::DB_OP_DONE::[Retry?]} */
            if (me->currRetry < MAX_RETRIES) {
                status_ = Q_TRAN(&SysMgr_Wait2);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer::DB_OP_DONE::[else]} */
            else {
                me->errorCode = ERR_DB_NOT_INIT;
                ERR_printf("Out of retries when attempting to reset DB to a valid state. Error: 0x%08x\n", me->errorCode);
                status_ = Q_TRAN(&SysMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Small timeout to make sure that retries don't overwhelm the logging
 * system.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait2} .....................*/
static QState SysMgr_Wait2(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait2} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( LL_MAX_TIME_SEC_BETWEEN_RETRIES )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait2::DB_ACCESS_TIMEOU~} */
        case DB_ACCESS_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_BootLdrBuildDTCheck);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Small timeout to make sure that retries don't overwhelm the logging
 * system.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait1} .....................*/
static QState SysMgr_Wait1(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait1} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( LL_MAX_TIME_SEC_BETWEEN_RETRIES )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait1::DB_ACCESS_TIMEOU~} */
        case DB_ACCESS_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_DBMagicWordCheck);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check DB debug modules and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugModule~} .........*/
static QState SysMgr_DBGetDebugModules(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugModule~} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_DBG_MODULES;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugModule~} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugModule~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            if ( ((I2CReadDoneEvt const *) e)->bytes > MAX_DB_ELEM_SIZE ) {
                /* This should be considered a pretty critical error. */
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                goto END_ERROR_CHECK;
            }

            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Error 0x%08x reading DB elem %s (%d)\n",
                me->errorCode,
                CON_dbElemToStr(_DC3_DB_DBG_MODULES),
                _DC3_DB_DBG_MODULES
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugModule~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (ERR_NONE == me->errorCode) {
                status_ = Q_TRAN(&SysMgr_DBGetDebugDevices);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugModule~::I2C1_DEV_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&SysMgr_ResetDBDbgModules);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the DB debug modules to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgModule~} .........*/
static QState SysMgr_ResetDBDbgModules(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgModule~} */
        case Q_ENTRY_SIG: {
            WRN_printf("Resetting %s to default...\n", CON_dbElemToStr(_DC3_DB_DBG_MODULES));

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_DBG_MODULES;
            evt->dataLen =  DB_getElemSize(_DC3_DB_DBG_MODULES);
            uint32_t dbDbgModules = DB_DBG_MODULES_DEF;
            MEMCPY(evt->dataBuf, (uint8_t *)&dbDbgModules, evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgModule~::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            me->currRetry++;
            status_ = Q_TRAN(&SysMgr_ResetDBDbgDevices);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check DB debug modules and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugDevice~} .........*/
static QState SysMgr_DBGetDebugDevices(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugDevice~} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_DBG_DEVICES;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugDevice~} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugDevice~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;

            if ( ERR_NONE != me->errorCode ) {
                goto END_ERROR_CHECK;
            }

            if ( ((I2CReadDoneEvt const *) e)->bytes > MAX_DB_ELEM_SIZE ) {
                /* This should be considered a pretty critical error. */
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                goto END_ERROR_CHECK;
            }

            /* Local tag to jump to if an error is found or to reach naturally
             * once all the checks are complete */
            END_ERROR_CHECK:
            ERR_COND_OUTPUT(
                me->errorCode,
                me->accessType,
                "Error 0x%08x reading DB elem %s (%d)\n",
                me->errorCode,
                CON_dbElemToStr(_DC3_DB_DBG_DEVICES),
                _DC3_DB_DBG_DEVICES
            );
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugDevice~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (ERR_NONE == me->errorCode) {
                LOG_printf("DB integrity and version validation complete.\n");
                me->isDBValid = true;
                status_ = Q_TRAN(&SysMgr_Idle);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBGetDebugDevice~::I2C1_DEV_READ_DO~::[else]} */
            else {
                status_ = Q_TRAN(&SysMgr_ResetDBDbgDevices);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the DB debug Devices to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgDevice~} .........*/
static QState SysMgr_ResetDBDbgDevices(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgDevice~} */
        case Q_ENTRY_SIG: {
            WRN_printf("Resetting %s to default...\n", CON_dbElemToStr(_DC3_DB_DBG_DEVICES));

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = _DC3_ACCESS_QPC;
            evt->dbElem = _DC3_DB_DBG_DEVICES;
            evt->dataLen =  DB_getElemSize(_DC3_DB_DBG_DEVICES);
            uint8_t dbgDevices = DB_DBG_DEVICES_DEF;
            MEMCPY(evt->dataBuf, (uint8_t *)&dbgDevices, evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgDevice~::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            me->currRetry++;
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgDevice~::DB_OP_DONE::[Retry?]} */
            if (me->currRetry < MAX_RETRIES) {
                status_ = Q_TRAN(&SysMgr_Wait1);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBDbgDevice~::DB_OP_DONE::[else]} */
            else {
                me->errorCode = ERR_DB_NOT_INIT;
                ERR_printf("Out of retries when attempting to reset DB to a valid state. Error: 0x%08x\n", me->errorCode);
                status_ = Q_TRAN(&SysMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBFullReset} ...............*/
static QState SysMgr_DBFullReset(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBFullReset} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );


            /* This function will fill out the appropriate data and post the event to reset the DB */
            me->errorCode = DB_initToDefault( me->accessType );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBFullReset} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBFullReset::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupSys
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
