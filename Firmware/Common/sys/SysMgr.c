/*****************************************************************************
* Model: SysMgr.qm
* File:  ./SysMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::SysMgr_gen.c} .......................................................*/
/**
 * @file    SysMgr.c
 * Declarations for functions for the SysMgr AO.  This state
 * machine handles various system level requests.
 *
 * Note: If editing this file, please make sure to update the SysMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/13/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupSys
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "SysMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp_defs.h"     /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include "I2C1DevMgr.h"                         /* For accessing I2C1 devices */
#include "Shared.h"
#include "i2c_dev.h"
#include "version.h"
#if CPLR_APP
#include "cplr.h"
#elif CPLR_BOOT

#else
    #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
#endif

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_SYS ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/

/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Keep track of errors that may occur in the AO */
    CBErrorCode errorCode;

    /**< Native QF queue for deferred request events. */
    QEQueue deferredEvtQueue;

    /**< Storage for deferred event queue. */
    QTimeEvt const * deferredEvtQSto[10];

    /**< QPC timer Used to timeout overall SysMgr interactions. */
    QTimeEvt sysTimerEvt;

    /**< QPC timer Used to timeout DB accesses. */
    QTimeEvt dbTimerEvt;

    /**< Access type of current request (used for DB access) */
    AccessType_t accessType;

    /**< DB command of current request (used for DB access to guarantee a reply) */
    DB_Operation_t dbCmd;

    /**< Buffer that holds the data for read results from any device we have to wait for */
    uint8_t dataBuf[MAX_DB_ELEM_SIZE];

    /**< Length of data in dataBuf */
    uint8_t dataLen;

    /**< DB element to get or set with the current request (used for DB access to guarantee a reply) */
    DB_Elem_t dbElem;

    /**< Flag that keeps track of whether DB is valid.  Starts out false but gets set to
     * true after checking. */
    bool isDBValid;

    /**< Current retry number. Used throughout the state machine to make sure we don't
     * get stuck in an inf loop when retrying */
    uint8_t currRetry;
} SysMgr;

/* protected: */
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e);

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check DB magic number and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_DBMagicWordCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the DB magic word to default values.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_ResetDBMagicWord(SysMgr * const me, QEvt const * const e);
static QState SysMgr_DBVersionCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check bootloader build datetime and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_BootLdrBuildDTCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the settings DB version to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_ResetDBVersion(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the bootloader build datetime.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_SetBootLdrDatetime(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the bootloader major version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_SetBootLdrMajVer(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check bootloader major version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_BootLdrMajVerCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief    Check bootloader minor version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_BootLdrMinVerCheck(SysMgr * const me, QEvt const * const e);

/**
 * @brief   Reset the bootloader minor version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_SetBootLdrMinVer(SysMgr * const me, QEvt const * const e);
static QState SysMgr_Wait(SysMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
#define MAX_RETRIES     5       /**< Max number of times to retry operations. */
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static SysMgr l_SysMgr;          /* the single instance of the Active object */

/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_SysMgr = (QActive *)&l_SysMgr;      /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for SysMgr "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::SysMgr_ctor} ......................................................*/
void SysMgr_ctor(void) {
    SysMgr *me = &l_SysMgr;
    QActive_ctor(&me->super, (QStateHandler)&SysMgr_initial);

    /* Initialize the deferred event queue and storage for it */
    QEQueue_init(
        &me->deferredEvtQueue,
        (QEvt const **)( me->deferredEvtQSto ),
        Q_DIM(me->deferredEvtQSto)
    );

    QTimeEvt_ctor( &me->sysTimerEvt, SYS_MGR_TIMEOUT_SIG );
    QTimeEvt_ctor( &me->dbTimerEvt, DB_ACCESS_TIMEOUT_SIG );
}


/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
/*${AOs::SysMgr::SM} .......................................................*/
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e) {
    /* ${AOs::SysMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_CommMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&CommMgr_initial);
    QS_FUN_DICTIONARY(&CommMgr_Active);

    /* Subscribe to I2C read and write done signals since it will be publishing them */
    QActive_subscribe((QActive *)me, I2C1_DEV_READ_DONE_SIG);
    QActive_subscribe((QActive *)me, I2C1_DEV_WRITE_DONE_SIG);
    QActive_subscribe((QActive *)me, DB_GET_ELEM_SIG);
    QActive_subscribe((QActive *)me, DB_SET_ELEM_SIG);

    me->isDBValid = false;

    /* Post to self to validate DB on startup */
    QEvt *evt = Q_NEW(QEvt, DB_CHECK_SIG);
    QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);

    #if CPLR_BOOT
    /* If this is the bootloader, also validate the bootloader build datetime
     * and version in the DB. */
    QEvt *evt1 = Q_NEW(QEvt, DB_CHECK_BOOTLDR_VER_SIG);
    QACTIVE_POST(AO_SysMgr, (QEvt *)evt1, me);
    #endif
    return Q_TRAN(&SysMgr_Idle);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active} ...............................................*/
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Post and disarm all the timer events so they can be rearmed at any time */
            QTimeEvt_postIn(
                &me->sysTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->sysTimerEvt);

            QTimeEvt_postIn(
                &me->dbTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->dbTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Idle} .........................................*/
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* Clear out all the variables on entry to Idle state.  By this point, any error
             * feedback should have already happened. */
            me->errorCode       = ERR_NONE;
            me->accessType      = ACCESS_NONE;
            me->dbCmd           = DB_OP_NONE;
            me->dataLen         = 0;
            me->currRetry       = 0;
            memset(me->dataBuf, 0, sizeof(me->dataBuf));

            /* recall the request from the private requestQueue */
            QActive_recall(
                (QActive *)me,
                &me->deferredEvtQueue
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_GET_ELEM} */
        case DB_GET_ELEM_SIG: {
            DBG_printf("DB_GET_ELEM, posting DB_READ\n");

            me->dbCmd = DB_OP_READ;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;
            me->dbElem = ((DBReadReqEvt const *)e)->dbElem;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBReadReqEvt *)e)->super.sig = DB_READ_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_SET_ELEM} */
        case DB_SET_ELEM_SIG: {
            DBG_printf("DB_SET_ELEM, posting DB_WRITE\n");

            me->dbCmd = DB_OP_WRITE;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;
            me->dbElem = ((DBReadReqEvt const *)e)->dbElem;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBWriteReqEvt *)e)->super.sig = DB_WRITE_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_CHECK} */
        case DB_CHECK_SIG: {
            me->dbCmd = DB_OP_INTERNAL;
            status_ = Q_TRAN(&SysMgr_DBMagicWordCheck);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_CHECK_BOOTLDR~} */
        case DB_CHECK_BOOTLDR_VER_SIG: {
            me->dbCmd = DB_OP_INTERNAL;
            status_ = Q_TRAN(&SysMgr_BootLdrBuildDTCheck);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy} .........................................*/
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Arm the timer so if the message can't be processed for some reason, we can get
             * back to idle state.  This timer may be re-armed if some messages require more
             * time to process than others. */
            QTimeEvt_rearm(
                &me->sysTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->sysTimerEvt);                 /* Disarm timer on exit */

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::SYS_MGR_TIMEOUT} */
        case SYS_MGR_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::DB_SET_ELEM, DB_~} */
        case DB_SET_ELEM_SIG: /* intentionally fall through */
        case DB_GET_ELEM_SIG: /* intentionally fall through */
        case DB_CHECK_SIG: /* intentionally fall through */
        case DB_CHECK_BOOTLDR_VER_SIG: {
            if (QEQueue_getNFree(&me->deferredEvtQueue) > 0) {
               /* defer the request - this event will be handled
                * when the state machine goes back to Idle state */
               QActive_defer((QActive *)me, &me->deferredEvtQueue, e);
               DBG_printf("Deferring DB request until current is done\n");
            } else {
               /* notify the request sender that the request was ignored.. */
               ERR_printf("Unable to defer DB request\n");
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB} ............................*/
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_ENTRY_SIG: {
            /* Set the error code in case of timeout */
            me->errorCode = ERR_DB_ACCESS_TIMEOUT;

            /* Arm the timer so if DB access is broken, the system can properly return an error */
            QTimeEvt_rearm(
                &me->dbTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                 /* Disarm timer on exit */

            if ( me->dbCmd == DB_OP_READ ) {
                DBReadDoneEvt *evt = Q_NEW(DBReadDoneEvt, DB_GET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;
                evt->dataLen = me->dataLen;
                MEMCPY(evt->dataBuf, me->dataBuf, evt->dataLen);
                DBG_printf("Publishing DB_GET_ELEM_DONE_SIG with %d len and error 0x%08x\n",evt->dataLen, evt->status);

                if ( ACCESS_FREERTOS == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }

            } else if ( me->dbCmd == DB_OP_WRITE ) {
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_SET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( ACCESS_FREERTOS == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }
            } else if ( me->dbCmd == DB_OP_INTERNAL ) {
                /* Do nothing in this case.  Internal operations are for DB
                 * validation and similar actions and are initiated intenally so
                 * so nobody is expecting a response */
                LOG_printf("Internal DB operation completed with error code: 0x%08x\n", me->errorCode);
            } else {
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                ERR_printf("Invalid DB operation (%d) specified somehow\n", me->dbCmd);
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_ERROR_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( ACCESS_FREERTOS == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif
                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }

            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_ACCESS_TIMEOU~} */
        case DB_ACCESS_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_READ} */
        case DB_READ_SIG: {
            DBG_printf("DB_READ with accType %d and dbElem %d\n",
                ((DBReadReqEvt const *)e)->accessType,
                ((DBReadReqEvt const *)e)->dbElem
            );

            /* Find where the element lives */
            DB_ElemLoc_t loc = DB_getElemLoc( ((DBReadReqEvt const *)e)->dbElem );

               /* 3. Call the location dependent functions to retrieve the data from DB */
            switch( loc ) {
                case DB_EEPROM:                           /* Intentionally fall through */
                case DB_SN_ROM:                           /* Intentionally fall through */
                case DB_UI_ROM:
                    ;
                    /* Create the event and directly post it to the right AO. */
                    I2CReadReqEvt *i2cReadReqEvt  = Q_NEW(I2CReadReqEvt, I2C1_DEV_RAW_MEM_READ_SIG);
                    i2cReadReqEvt->i2cDev         = DB_getI2CDev(loc);
                    i2cReadReqEvt->addr           = I2C_getMemAddr( i2cReadReqEvt->i2cDev ) + DB_getElemOffset(((DBReadReqEvt const *)e)->dbElem);
                    i2cReadReqEvt->bytes          = DB_getElemSize(((DBReadReqEvt const *)e)->dbElem);
                    i2cReadReqEvt->accessType     = me->accessType;
                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cReadReqEvt), me);
                    DBG_printf("Posting a read req to I2C1DevMgr\n");
                    break;
                case DB_GPIO:
                    me->errorCode = ERR_UNIMPLEMENTED;
                    QEvt *evtGPIO = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtGPIO, me);
                    break;
                case DB_FLASH:
                    ;
                    me->errorCode = DB_readEEPROM(
                        ((DBReadReqEvt const *)e)->dbElem,
                        MAX_DB_ELEM_SIZE,
                        me->dataBuf,
                        &(me->dataLen)
                    );
                    QEvt *evtFlash = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtFlash, me);
                    break;
                    /* Add more locations here. Anything that fails will go to the default
                     * case and get logged as an error. */
                default:
                    me->errorCode  = ERR_DB_ELEM_NOT_FOUND;
                    QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtNotFound, me);
                    break;
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_WRITE} */
        case DB_WRITE_SIG: {
            DBG_printf("DB_WRITE with accType %d and dbElem %d\n",
                ((DBWriteReqEvt const *)e)->accessType,
                ((DBWriteReqEvt const *)e)->dbElem
            );

            /* Find where the element lives */
            DB_ElemLoc_t loc = DB_getElemLoc( ((DBWriteReqEvt const *)e)->dbElem );

               /* 3. Call the location dependent functions to retrieve the data from DB */
            switch( loc ) {
                case DB_EEPROM:
                    ;
                    /* Create the event and directly post it to the right AO. */
                    I2CWriteReqEvt *i2cWriteReqEvt  = Q_NEW(I2CWriteReqEvt, I2C1_DEV_RAW_MEM_WRITE_SIG);
                    i2cWriteReqEvt->i2cDev         = DB_getI2CDev(loc);
                    i2cWriteReqEvt->addr           = I2C_getMemAddr( i2cWriteReqEvt->i2cDev ) + DB_getElemOffset(((DBWriteReqEvt const *)e)->dbElem);
                    i2cWriteReqEvt->bytes          = DB_getElemSize(((DBWriteReqEvt const *)e)->dbElem);
                    i2cWriteReqEvt->accessType     = me->accessType;
                    MEMCPY(i2cWriteReqEvt->dataBuf, ((DBWriteReqEvt const *)e)->dataBuf, i2cWriteReqEvt->bytes);
                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cWriteReqEvt), me);
                    DBG_printf("Posting a write req to I2C1DevMgr\n");
                    break;
                case DB_GPIO:                             /* Intentionally fall through */
                case DB_SN_ROM:                           /* Intentionally fall through */
                case DB_UI_ROM:                           /* Intentionally fall through */
                case DB_FLASH:
                    me->errorCode = ERR_DB_ELEM_IS_READ_ONLY;
                    QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evt, me);
                    break;
                    /* Add more locations here. Anything that fails will go to the default
                     * case and get logged as an error. */
                default:
                    me->errorCode  = ERR_DB_ELEM_NOT_FOUND;
                    QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtNotFound, me);
                    break;
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            DBG_printf("Got a read done from I2C1DevMgr\n");

            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_WRITE_D~} */
        case I2C1_DEV_WRITE_DONE_SIG: {
            DBG_printf("Got a write done from I2C1DevMgr\n");

            me->errorCode = ((I2CWriteDoneEvt const *) e)->status;

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Busy);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check DB magic number and reset DB to default values if invalid.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck} ..........*/
static QState SysMgr_DBMagicWordCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_MAGIC_WORD;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            DBG_printf("Got a read done from I2C1DevMgr\n");

            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~::[NoError?]} */
            if (ERR_NONE == me->errorCode) {
                uint32_t dbMagicWord = 0;
                MEMCPY( &dbMagicWord, ((I2CReadDoneEvt const *)e)->dataBuf, ((I2CReadDoneEvt const *)e)->bytes );

                DBG_printf("Magic word read: 0x%08x vs built one: 0x%08x\n", dbMagicWord, DB_MAGIC_WORD_DEF);

                me->errorCode = DB_isMagicWordValid( dbMagicWord );





                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~::[NoError?]::[NoError?]} */
                if (ERR_NONE == me->errorCode) {
                    status_ = Q_TRAN(&SysMgr_DBVersionCheck);
                }
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~::[NoError?]::[else]} */
                else {
                    ERR_printf("Invalid Magic Word in DB, need to reset DB. Error: 0x%08x\n", me->errorCode);

                    /* Need to reset the DB */
                    status_ = Q_TRAN(&SysMgr_ResetDBMagicWord);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBMagicWordCheck::I2C1_DEV_READ_DO~::[else]} */
            else {
                ERR_printf("Unable to read Magic Word from DB, need to reset DB. Error: 0x%08x\n", me->errorCode);
                /* Need to reset the DB */
                status_ = Q_TRAN(&SysMgr_ResetDBMagicWord);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the DB magic word to default values.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBMagicWord} ..........*/
static QState SysMgr_ResetDBMagicWord(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBMagicWord} */
        case Q_ENTRY_SIG: {
            LOG_printf("Resetting DB magic word...\n");

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_MAGIC_WORD;
            evt->dataLen =  DB_getElemSize(DB_MAGIC_WORD);
            MEMCPY(evt->dataBuf, (uint8_t *)DB_MAGIC_WORD_DEF,evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBMagicWord::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_ResetDBVersion);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck} ............*/
static QState SysMgr_DBVersionCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
            );

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_VERSION;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                  /* Disarm timer on exit */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            DBG_printf("Got a read done from I2C1DevMgr\n");

            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~::[NoError?]} */
            if (ERR_NONE == me->errorCode) {
                uint16_t dbVersion = 0;
                MEMCPY( &dbVersion, ((I2CReadDoneEvt const *)e)->dataBuf, ((I2CReadDoneEvt const *)e)->bytes );

                me->errorCode = DB_isVersionValid( dbVersion );





                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~::[NoError?]::[NoError?]} */
                if (ERR_NONE == me->errorCode) {
                    LOG_printf("DB validation complete.\n");
                    me->isDBValid = true;
                    status_ = Q_TRAN(&SysMgr_Idle);
                }
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~::[NoError?]::[else]} */
                else {
                    ERR_printf("Invalid version in DB, need to reset DB. Error: 0x%08x\n", me->errorCode);

                    /* Need to reset the DB */
                    status_ = Q_TRAN(&SysMgr_ResetDBVersion);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DBVersionCheck::I2C1_DEV_READ_DO~::[else]} */
            else {
                ERR_printf("Unable to version from DB, need to reset DB. Error: 0x%08x\n", me->errorCode);
                /* Need to reset the DB */
                status_ = Q_TRAN(&SysMgr_ResetDBVersion);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check bootloader build datetime and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~} .........*/
static QState SysMgr_BootLdrBuildDTCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~} */
        case Q_ENTRY_SIG: {
            DBG_printf("Validating Bootloader build datetime...\n");

            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_BOOT_BUILD_DATETIME;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                    WRN_printf("Read Bootloader datetime and it's longer than max size\n");
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (me->errorCode == ERR_NONE) {
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]} */
                if (((I2CReadDoneEvt const *)e)->bytes == DB_getElemSize(DB_BOOT_BUILD_DATETIME)) {
                    me->errorCode = DB_checkDTMatch( ((I2CReadDoneEvt const *) e)->dataBuf, (uint8_t *)BUILD_DATE );
                    /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]::[DatetimeDiff?]} */
                    if (ERR_NONE != me->errorCode) {
                        WRN_printf("Bootloader datetime mismatch. DB: %s, Compiled: %s\n",
                            ((I2CReadDoneEvt const *) e)->dataBuf, BUILD_DATE
                        );
                        status_ = Q_TRAN(&SysMgr_SetBootLdrDatetime);
                    }
                    /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]::[else]} */
                    else {
                        DBG_printf("Bootloader datetime match\n");
                        status_ = Q_TRAN(&SysMgr_BootLdrMajVerCheck);
                    }
                }
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[NoError?]::[else]} */
                else {
                    me->errorCode = ERR_DB_INVALID_DATETIME_LENGTH;
                    ERR_printf(
                        "Bootloader datetime length (%d) invalid. EXpected %d. Error 0x%08x, aborting attempt to validating the DB\n",
                        ((DBReadDoneEvt const *)e)->dataLen,  DB_getElemSize(DB_BOOT_BUILD_DATETIME), me->errorCode
                    );
                    status_ = Q_TRAN(&SysMgr_SetBootLdrDatetime);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrBuildDTCh~::I2C1_DEV_READ_DO~::[else]} */
            else {
                ERR_printf("DB access resulted in error 0x%08x, aborting attempt to validating the DB\n", me->errorCode);
                status_ = Q_TRAN(&SysMgr_SetBootLdrDatetime);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the settings DB version to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion} ............*/
static QState SysMgr_ResetDBVersion(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion} */
        case Q_ENTRY_SIG: {
            LOG_printf("Resetting DB version...\n");

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_VERSION;
            evt->dataLen =  DB_getElemSize(DB_VERSION);
            MEMCPY(evt->dataBuf, (uint8_t *)DB_VERSION_DEF,evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            me->currRetry++;
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion::DB_OP_DONE::[Retry?]} */
            if (me->currRetry < MAX_RETRIES) {
                status_ = Q_TRAN(&SysMgr_DBMagicWordCheck);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::ResetDBVersion::DB_OP_DONE::[else]} */
            else {
                me->errorCode = ERR_DB_NOT_INIT;
                ERR_printf("Out of retries when attempting to reset DB to a valid state. Error: 0x%08x\n", me->errorCode);
                status_ = Q_TRAN(&SysMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the bootloader build datetime.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrDateti~} .........*/
static QState SysMgr_SetBootLdrDatetime(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrDateti~} */
        case Q_ENTRY_SIG: {
            WRN_printf("Setting bootloader build datetime in DB to %s.\n", BUILD_DATE);

            /* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_BOOT_BUILD_DATETIME;
            evt->dataLen =  DB_getElemSize(DB_BOOT_BUILD_DATETIME);
            MEMCPY(evt->dataBuf, (uint8_t *)BUILD_DATE, evt->dataLen);
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);


            uint8_t tmp[100] = {0};
            uint16_t tmpLen = 0;
            CBErrorCode err = CON_hexToStr(
                evt->dataBuf,                        // data to convert
                evt->dataLen,                        // length of data to convert
                tmp,                                 // where to write output
                sizeof(tmp),                         // max size of output buffer
                &tmpLen,                             // size of the resulting output
                0,                                   // no columns
                ' ',                                 // separator
                true                                 // bPrintX
            );

            DBG_printf(
                "Attempting to write %d bytes: %s\n",
                evt->dataLen, tmp
            );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrDateti~::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_SetBootLdrMajVer);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the bootloader major version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMajVer} ..........*/
static QState SysMgr_SetBootLdrMajVer(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMajVer} */
        case Q_ENTRY_SIG: {
            WRN_printf("Setting bootloader major version in DB to %d\n", FW_VER_MAJOR );

            /* Post to SysMgr to set the major version since we no longer trust it */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_BOOT_MAJ;
            evt->dataLen =  DB_getElemSize(DB_BOOT_MAJ);
            evt->dataBuf[0] = FW_VER_MAJOR;

            DBG_printf("Bootloader major version in byffer after copy: %d\n", evt->dataBuf[0] );

            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMajVer::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_SetBootLdrMinVer);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check bootloader major version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~} .........*/
static QState SysMgr_BootLdrMajVerCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~} */
        case Q_ENTRY_SIG: {
            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_BOOT_MAJ;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                    WRN_printf("Read Bootloader major version and it's longer than max size\n");
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (me->errorCode == ERR_NONE) {
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]} */
                if (((I2CReadDoneEvt const *)e)->bytes == DB_getElemSize(DB_BOOT_MAJ)) {
                    /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]::[MajVerDiff?]} */
                    if (((I2CReadDoneEvt const *) e)->dataBuf[0] != FW_VER_MAJOR) {
                        me->errorCode = ERR_DB_INVALID_MAJ_VER_MISMATCH;
                        WRN_printf("Bootloader datetime mismatch. DB: %d, Compiled: %d\n",
                            ((I2CReadDoneEvt const *) e)->dataBuf[0], FW_VER_MAJOR
                        );
                        status_ = Q_TRAN(&SysMgr_SetBootLdrMajVer);
                    }
                    /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]::[else]} */
                    else {
                        DBG_printf("Bootloader major version match\n");
                        status_ = Q_TRAN(&SysMgr_BootLdrMinVerCheck);
                    }
                }
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[else]} */
                else {
                    me->errorCode = ERR_DB_INVALID_MAJ_VER_LENGTH;
                    ERR_printf(
                        "Bootloader major version length (%d) invalid. EXpected %d. Error 0x%08x, aborting attempt to validating the DB\n",
                        ((DBReadDoneEvt const *)e)->dataLen,  DB_getElemSize(DB_BOOT_MAJ), me->errorCode
                    );
                    status_ = Q_TRAN(&SysMgr_SetBootLdrMajVer);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMajVerChe~::I2C1_DEV_READ_DO~::[else]} */
            else {
                ERR_printf("DB access resulted in error 0x%08x, aborting attempt to validating the DB\n", me->errorCode);
                status_ = Q_TRAN(&SysMgr_SetBootLdrMajVer);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief    Check bootloader minor version and fix it if it doesn't match.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~} .........*/
static QState SysMgr_BootLdrMinVerCheck(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~} */
        case Q_ENTRY_SIG: {
            /* Post to SysMgr to get the build datetime first since it's the one most likely to
             * be incorrect */
            DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_BOOT_MIN;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                    WRN_printf("Read Bootloader minor version and it's longer than max size\n");
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[NoError?]} */
            if (me->errorCode == ERR_NONE) {
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]} */
                if (((I2CReadDoneEvt const *)e)->bytes == DB_getElemSize(DB_BOOT_MIN)) {
                    /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]::[MinVerDiff?]} */
                    if (((I2CReadDoneEvt const *) e)->dataBuf[0] != FW_VER_MINOR) {
                        WRN_printf("Bootloader minor version mismatch. DB: %d, Compiled: %d\n",
                            ((I2CReadDoneEvt const *) e)->dataBuf[0], FW_VER_MINOR
                        );
                        status_ = Q_TRAN(&SysMgr_SetBootLdrMinVer);
                    }
                    /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[ValidLength?]::[else]} */
                    else {
                        DBG_printf("Bootloader major version match\n");
                        status_ = Q_TRAN(&SysMgr_Idle);
                    }
                }
                /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[NoError?]::[else]} */
                else {
                    me->errorCode = ERR_DB_INVALID_MIN_VER_LENGTH;
                    ERR_printf(
                        "Bootloader minor version length (%d) invalid. EXpected %d. Error 0x%08x, aborting attempt to validating the DB\n",
                        ((DBReadDoneEvt const *)e)->dataLen,  DB_getElemSize(DB_BOOT_MIN), me->errorCode
                    );
                    status_ = Q_TRAN(&SysMgr_SetBootLdrMinVer);
                }
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::BootLdrMinVerChe~::I2C1_DEV_READ_DO~::[else]} */
            else {
                ERR_printf("DB access resulted in error 0x%08x, aborting attempt to validating the DB\n", me->errorCode);
                status_ = Q_TRAN(&SysMgr_SetBootLdrMinVer);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}

/**
 * @brief   Reset the bootloader minor version.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer} ..........*/
static QState SysMgr_SetBootLdrMinVer(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer} */
        case Q_ENTRY_SIG: {
            WRN_printf("Setting bootloader minor version in DB to %d.\n", FW_VER_MINOR);

            /* Post to SysMgr to set the major version since we no longer trust it */
            DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
            evt->accessType = ACCESS_QPC;
            evt->dbElem = DB_BOOT_MIN;
            evt->dataLen =  DB_getElemSize(DB_BOOT_MIN);
            evt->dataBuf[0] = FW_VER_MINOR;
            QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            me->currRetry++;
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer::DB_OP_DONE::[Retry?]} */
            if (me->currRetry < MAX_RETRIES) {
                status_ = Q_TRAN(&SysMgr_Wait);
            }
            /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::SetBootLdrMinVer::DB_OP_DONE::[else]} */
            else {
                me->errorCode = ERR_DB_NOT_INIT;
                ERR_printf("Out of retries when attempting to reset DB to a valid state. Error: 0x%08x\n", me->errorCode);
                status_ = Q_TRAN(&SysMgr_Idle);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait} ......................*/
static QState SysMgr_Wait(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait} */
        case Q_ENTRY_SIG: {
            QTimeEvt_rearm(                                       /* Re-arm timer on entry */
                &me->dbTimerEvt,
                SEC_TO_TICKS( LL_MAX_TIME_SEC_BETWEEN_RETRIES )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::Wait::DB_ACCESS_TIMEOU~} */
        case DB_ACCESS_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_BootLdrBuildDTCheck);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_AccessingDB);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupSys
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
