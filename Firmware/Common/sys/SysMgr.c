/*****************************************************************************
* Model: SysMgr.qm
* File:  ./SysMgr_gen.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::SysMgr_gen.c} .......................................................*/
/**
 * @file    SysMgr.c
 * Declarations for functions for the SysMgr AO.  This state
 * machine handles various system level requests.
 *
 * Note: If editing this file, please make sure to update the SysMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/13/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupSys
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "SysMgr.h"
#include "project_includes.h"           /* Includes common to entire project. */
#include "bsp_defs.h"     /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include "I2C1DevMgr.h"                         /* For accessing I2C1 devices */
#include "Shared.h"
#include "i2c_dev.h"
#if CPLR_APP
#include "cplr.h"
#elif CPLR_BOOT

#else
    #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
#endif

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DBG_MODL_SYS ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/

/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
typedef struct {
/* protected: */
    QActive super;

    /**< Keep track of errors that may occur in the AO */
    CBErrorCode errorCode;

    /**< Native QF queue for deferred request events. */
    QEQueue deferredEvtQueue;

    /**< Storage for deferred event queue. */
    QTimeEvt const * deferredEvtQSto[10];

    /**< QPC timer Used to timeout overall SysMgr interactions. */
    QTimeEvt sysTimerEvt;

    /**< QPC timer Used to timeout DB accesses. */
    QTimeEvt dbTimerEvt;

    /**< Access type of current request (used for DB access) */
    AccessType_t accessType;

    /**< DB command of current request (used for DB access to guarantee a reply) */
    DB_Operation_t dbCmd;

    /**< Buffer that holds the data for read results from any device we have to wait for */
    uint8_t dataBuf[MAX_DB_ELEM_SIZE];

    /**< Length of data in dataBuf */
    uint8_t dataLen;

    /**< DB element to get or set with the current request (used for DB access to guarantee a reply) */
    DB_Elem_t dbElem;
} SysMgr;

/* protected: */
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e);

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e);

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e);

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e);


/* Private defines -----------------------------------------------------------*/
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static SysMgr l_SysMgr;          /* the single instance of the Active object */

/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_SysMgr = (QActive *)&l_SysMgr;      /* "opaque" AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/

/**
 * @brief C "constructor" for SysMgr "class".
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */
/*${AOs::SysMgr_ctor} ......................................................*/
void SysMgr_ctor(void) {
    SysMgr *me = &l_SysMgr;
    QActive_ctor(&me->super, (QStateHandler)&SysMgr_initial);

    /* Initialize the deferred event queue and storage for it */
    QEQueue_init(
        &me->deferredEvtQueue,
        (QEvt const **)( me->deferredEvtQSto ),
        Q_DIM(me->deferredEvtQSto)
    );

    QTimeEvt_ctor( &me->sysTimerEvt, SYS_MGR_TIMEOUT_SIG );
    QTimeEvt_ctor( &me->dbTimerEvt, DB_ACCESS_TIMEOUT_SIG );
}


/**
 * \brief SysMgr "class"
 */
/*${AOs::SysMgr} ...........................................................*/
/*${AOs::SysMgr::SM} .......................................................*/
static QState SysMgr_initial(SysMgr * const me, QEvt const * const e) {
    /* ${AOs::SysMgr::SM::initial} */
    (void)e;        /* suppress the compiler warning about unused parameter */

    QS_OBJ_DICTIONARY(&l_CommMgr);
    QS_FUN_DICTIONARY(&QHsm_top);
    QS_FUN_DICTIONARY(&CommMgr_initial);
    QS_FUN_DICTIONARY(&CommMgr_Active);

    /* Subscribe to I2C read and write done signals since it will be publishing them */
    QActive_subscribe((QActive *)me, I2C1_DEV_READ_DONE_SIG);
    QActive_subscribe((QActive *)me, I2C1_DEV_WRITE_DONE_SIG);
    QActive_subscribe((QActive *)me, DB_GET_ELEM_SIG);
    QActive_subscribe((QActive *)me, DB_SET_ELEM_SIG);
    return Q_TRAN(&SysMgr_Idle);
}

/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active} ...............................................*/
static QState SysMgr_Active(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Post and disarm all the timer events so they can be rearmed at any time */
            QTimeEvt_postIn(
                &me->sysTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->sysTimerEvt);

            QTimeEvt_postIn(
                &me->dbTimerEvt,
                (QActive *)me,
                SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
            );
            QTimeEvt_disarm(&me->dbTimerEvt);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Idle} .........................................*/
static QState SysMgr_Idle(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Idle} */
        case Q_ENTRY_SIG: {
            /* Clear out all the variables on entry to Idle state.  By this point, any error
             * feedback should have already happened. */
            me->errorCode       = ERR_NONE;
            me->accessType      = ACCESS_NONE;
            me->dbCmd           = DB_OP_NONE;
            me->dataLen         = 0;
            memset(me->dataBuf, 0, sizeof(me->dataBuf));

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_GET_ELEM} */
        case DB_GET_ELEM_SIG: {
            DBG_printf("DB_GET_ELEM, posting DB_READ\n");

            me->dbCmd = DB_OP_READ;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;
            me->dbElem = ((DBReadReqEvt const *)e)->dbElem;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBReadReqEvt *)e)->super.sig = DB_READ_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Idle::DB_SET_ELEM} */
        case DB_SET_ELEM_SIG: {
            DBG_printf("DB_SET_ELEM, posting DB_WRITE\n");

            me->dbCmd = DB_OP_WRITE;
            me->accessType = ((DBReadReqEvt const *)e)->accessType;
            me->dbElem = ((DBReadReqEvt const *)e)->dbElem;

            /* Change the signal associated with event and re post to self so it gets handled
             * in the AccessingDB state without having to recopy all the data in the event. */
            ((DBWriteReqEvt *)e)->super.sig = DB_WRITE_SIG;
            QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);
            status_ = Q_TRAN(&SysMgr_AccessingDB);
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy} .........................................*/
static QState SysMgr_Busy(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_ENTRY_SIG: {
            /* Arm the timer so if the message can't be processed for some reason, we can get
             * back to idle state.  This timer may be re-armed if some messages require more
             * time to process than others. */
            QTimeEvt_rearm(
                &me->sysTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->sysTimerEvt);                 /* Disarm timer on exit */

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::SYS_MGR_TIMEOUT} */
        case SYS_MGR_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::DB_SET_ELEM, DB_~} */
        case DB_SET_ELEM_SIG: /* intentionally fall through */
        case DB_GET_ELEM_SIG: {
            if (QEQueue_getNFree(&me->deferredEvtQueue) > 0) {
               /* defer the request - this event will be handled
                * when the state machine goes back to Idle state */
               QActive_defer((QActive *)me, &me->deferredEvtQueue, e);
               DBG_printf("Deferring DB request until current is done\n");
            } else {
               /* notify the request sender that the request was ignored.. */
               ERR_printf("Unable to defer DB request\n");
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Active);
            break;
        }
    }
    return status_;
}

/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */
/*${AOs::SysMgr::SM::Active::Busy::AccessingDB} ............................*/
static QState SysMgr_AccessingDB(SysMgr * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_ENTRY_SIG: {
            /* Set the error code in case of timeout */
            me->errorCode = ERR_DB_ACCESS_TIMEOUT;

            /* Arm the timer so if DB access is broken, the system can properly return an error */
            QTimeEvt_rearm(
                &me->dbTimerEvt,
                SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
            );

            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->dbTimerEvt);                 /* Disarm timer on exit */

            if ( me->dbCmd == DB_OP_READ ) {
                DBReadDoneEvt *evt = Q_NEW(DBReadDoneEvt, DB_GET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;
                evt->dataLen = me->dataLen;
                MEMCPY(evt->dataBuf, me->dataBuf, evt->dataLen);
                DBG_printf("Publishing DB_GET_ELEM_DONE_SIG with %d len and error 0x%08x\n",evt->dataLen, evt->status);

                if ( ACCESS_FREERTOS == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }

            } else if ( me->dbCmd == DB_OP_WRITE ) {
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_SET_ELEM_DONE_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( ACCESS_FREERTOS == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif

                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }
            } else {
                me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                ERR_printf("Invalid DB operation (%d) specified somehow\n", me->dbCmd);
                DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_ERROR_SIG);
                evt->status = me->errorCode;
                evt->dbElem  = me->dbElem;

                if ( ACCESS_FREERTOS == me->accessType ) {
            #if CPLR_APP
                    /* Post directly to the "raw" queue for FreeRTOS task to read */
                    QEQueue_postFIFO(&CPLR_evtQueue, (QEvt *)evt);
                    vTaskResume( xHandle_CPLR );
            #elif CPLR_BOOT
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
            #else
                #error "Invalid build.  CPLR_APP or CPLR_BOOT must be specified"
            #endif
                } else {
                    /* Publish the event so other AOs can get it if they want */
                    QF_PUBLISH((QEvt *)evt, AO_SysMgr);
                }

            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_ACCESS_TIMEOU~} */
        case DB_ACCESS_TIMEOUT_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_READ} */
        case DB_READ_SIG: {
            DBG_printf("DB_READ with accType %d and dbElem %d\n",
                ((DBReadReqEvt const *)e)->accessType,
                ((DBReadReqEvt const *)e)->dbElem
            );

            /* Find where the element lives */
            DB_ElemLoc_t loc = DB_getElemLoc( ((DBReadReqEvt const *)e)->dbElem );

               /* 3. Call the location dependent functions to retrieve the data from DB */
            switch( loc ) {
                case DB_EEPROM:                           /* Intentionally fall through */
                case DB_SN_ROM:                           /* Intentionally fall through */
                case DB_UI_ROM:
                    ;
                    /* Create the event and directly post it to the right AO. */
                    I2CReadReqEvt *i2cReadReqEvt  = Q_NEW(I2CReadReqEvt, I2C1_DEV_RAW_MEM_READ_SIG);
                    i2cReadReqEvt->i2cDev         = DB_getI2CDev(loc);
                    i2cReadReqEvt->addr           = I2C_getMemAddr( i2cReadReqEvt->i2cDev ) + DB_getElemOffset(((DBReadReqEvt const *)e)->dbElem);
                    i2cReadReqEvt->bytes          = DB_getElemSize(((DBReadReqEvt const *)e)->dbElem);
                    i2cReadReqEvt->accessType     = me->accessType;
                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cReadReqEvt), me);
                    DBG_printf("Posting a read req to I2C1DevMgr\n");
                    break;
                case DB_GPIO:
                    me->errorCode = ERR_UNIMPLEMENTED;
                    QEvt *evtGPIO = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtGPIO, me);
                    break;
                case DB_FLASH:
                    ;
                    me->errorCode = DB_readEEPROM(
                        ((DBReadReqEvt const *)e)->dbElem,
                        MAX_DB_ELEM_SIZE,
                        me->dataBuf,
                        &(me->dataLen)
                    );
                    QEvt *evtFlash = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtFlash, me);
                    break;
                    /* Add more locations here. Anything that fails will go to the default
                     * case and get logged as an error. */
                default:
                    me->errorCode  = ERR_DB_ELEM_NOT_FOUND;
                    QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtNotFound, me);
                    break;
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_WRITE} */
        case DB_WRITE_SIG: {
            DBG_printf("DB_WRITE with accType %d and dbElem %d\n",
                ((DBWriteReqEvt const *)e)->accessType,
                ((DBWriteReqEvt const *)e)->dbElem
            );

            /* Find where the element lives */
            DB_ElemLoc_t loc = DB_getElemLoc( ((DBWriteReqEvt const *)e)->dbElem );

               /* 3. Call the location dependent functions to retrieve the data from DB */
            switch( loc ) {
                case DB_EEPROM:
                    ;
                    /* Create the event and directly post it to the right AO. */
                    I2CWriteReqEvt *i2cWriteReqEvt  = Q_NEW(I2CWriteReqEvt, I2C1_DEV_RAW_MEM_WRITE_SIG);
                    i2cWriteReqEvt->i2cDev         = DB_getI2CDev(loc);
                    i2cWriteReqEvt->addr           = I2C_getMemAddr( i2cWriteReqEvt->i2cDev ) + DB_getElemOffset(((DBWriteReqEvt const *)e)->dbElem);
                    i2cWriteReqEvt->bytes          = DB_getElemSize(((DBWriteReqEvt const *)e)->dbElem);
                    i2cWriteReqEvt->accessType     = me->accessType;
                    QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cWriteReqEvt), me);
                    DBG_printf("Posting a write req to I2C1DevMgr\n");
                    break;
                case DB_GPIO:                             /* Intentionally fall through */
                case DB_SN_ROM:                           /* Intentionally fall through */
                case DB_UI_ROM:                           /* Intentionally fall through */
                case DB_FLASH:
                    me->errorCode = ERR_DB_ELEM_IS_READ_ONLY;
                    QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evt, me);
                    break;
                    /* Add more locations here. Anything that fails will go to the default
                     * case and get logged as an error. */
                default:
                    me->errorCode  = ERR_DB_ELEM_NOT_FOUND;
                    QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
                    QACTIVE_POST(AO_SysMgr, evtNotFound, me);
                    break;
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::DB_OP_DONE} */
        case DB_OP_DONE_SIG: {
            status_ = Q_TRAN(&SysMgr_Idle);
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_READ_DO~} */
        case I2C1_DEV_READ_DONE_SIG: {
            DBG_printf("Got a read done from I2C1DevMgr\n");

            me->errorCode = ((I2CReadDoneEvt const *) e)->status;
            if ( ERR_NONE == me->errorCode ) {
                me->dataLen = ((I2CReadDoneEvt const *) e)->bytes;
                if ( me->dataLen > MAX_DB_ELEM_SIZE ) {
                    me->errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
                } else {
                    MEMCPY(me->dataBuf, ((I2CReadDoneEvt const *) e)->dataBuf, me->dataLen);
                }
            }

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::SysMgr::SM::Active::Busy::AccessingDB::I2C1_DEV_WRITE_D~} */
        case I2C1_DEV_WRITE_DONE_SIG: {
            DBG_printf("Got a write done from I2C1DevMgr\n");

            me->errorCode = ((I2CWriteDoneEvt const *) e)->status;

            /* Self post to let the exit condition handle the sending back to requester */
            QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
            QACTIVE_POST(AO_SysMgr, evt, me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&SysMgr_Busy);
            break;
        }
    }
    return status_;
}


/**
 * @} end addtogroup groupSys
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/
