<?xml version="1.0" encoding="UTF-8"?>
<model version="3.2.2">
 <documentation>/**
 * CommStackMgr Active Object which.  This AO handles all communications work.
 */</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="DBReadReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a DB read request.
 */</documentation>
   <attribute name="accessType" type="DC3AccessType_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies whether the request came from FreeRTOS thread or another AO */</documentation>
   </attribute>
   <attribute name="dbElem" type="DC3DBElem_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; DB element */</documentation>
   </attribute>
  </class>
  <class name="DBWriteReqEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a DB read request.
 */</documentation>
   <attribute name="accessType" type="DC3AccessType_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Specifies whether the request came from FreeRTOS thread or another AO */</documentation>
   </attribute>
   <attribute name="dbElem" type="DC3DBElem_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; DB element */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_DB_ELEM_SIZE]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data to write */</documentation>
   </attribute>
   <attribute name="dataLen" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in dataBuf */</documentation>
   </attribute>
  </class>
  <class name="DBReadDoneEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a DB read request.
 */</documentation>
   <attribute name="dbElem" type="DC3DBElem_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; DB element */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_DB_ELEM_SIZE]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data read from DB */</documentation>
   </attribute>
   <attribute name="dataLen" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in dataBuf */</documentation>
   </attribute>
   <attribute name="status" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the operation */</documentation>
   </attribute>
  </class>
  <class name="DBWriteDoneEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a DB read request.
 */</documentation>
   <attribute name="dbElem" type="DC3DBElem_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; DB element */</documentation>
   </attribute>
   <attribute name="status" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Status of the operation */</documentation>
   </attribute>
  </class>
  <class name="DBCheckSetElemEvt" superclass="qpc::QEvt">
   <documentation>/**
 * @brief Event struct type for specifying a DB read, check, and possibly 
 * set new value event
 */</documentation>
   <attribute name="dbElem" type="DC3DBElem_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; DB element */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_DB_ELEM_SIZE]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data read from DB */</documentation>
   </attribute>
   <attribute name="dataLen" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in dataBuf */</documentation>
   </attribute>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="SysMgr" superclass="qpc::QActive">
   <documentation>/**
 * \brief SysMgr &quot;class&quot;
 */</documentation>
   <attribute name="errorCode" type="DC3Error_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Keep track of errors that may occur in the AO */</documentation>
   </attribute>
   <attribute name="deferredEvtQueue" type="QEQueue" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Native QF queue for deferred request events. */</documentation>
   </attribute>
   <attribute name="deferredEvtQSto[20]" type="QTimeEvt const *" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Storage for deferred event queue. */</documentation>
   </attribute>
   <attribute name="sysTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout overall SysMgr interactions. */</documentation>
   </attribute>
   <attribute name="dbTimerEvt" type="QTimeEvt" visibility="0x01" properties="0x00">
    <documentation>/**&lt; QPC timer Used to timeout DB accesses. */</documentation>
   </attribute>
   <attribute name="accessType" type="DC3AccessType_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Access type of current request (used for DB access) */</documentation>
   </attribute>
   <attribute name="dbCmd" type="DB_Operation_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; DB command of current request (used for DB access to guarantee a reply) */</documentation>
   </attribute>
   <attribute name="dataBuf[MAX_DB_ELEM_SIZE]" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Buffer that holds the data for read results from any device we have to wait for */</documentation>
   </attribute>
   <attribute name="dataLen" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Length of data in dataBuf */</documentation>
   </attribute>
   <attribute name="dbElem" type="DC3DBElem_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; DB element to get or set with the current request (used for DB access to guarantee a reply) */</documentation>
   </attribute>
   <attribute name="isDBValid" type="bool" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Flag that keeps track of whether DB is valid.  Starts out false but gets set to
 * true after checking. */</documentation>
   </attribute>
   <attribute name="currRetry" type="uint8_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Current retry number. Used throughout the state machine to make sure we don't 
 * get stuck in an inf loop when retrying */</documentation>
   </attribute>
   <attribute name="dbVersionDef" type="uint16_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Compiled in version of the DB. This is set only once at the beginning and used for
 * verification and validation of the DB on startup */</documentation>
   </attribute>
   <attribute name="dbMagicWordDef" type="uint32_t" visibility="0x01" properties="0x00">
    <documentation>/**&lt; Compiled in magic word that specifies if the DB is intact. This is set only once
 * at the beginning and used for verification and validation of the DB on startup */</documentation>
   </attribute>
   <statechart>
    <initial target="../1/0">
     <action>(void)e;        /* suppress the compiler warning about unused parameter */

QS_OBJ_DICTIONARY(&amp;l_CommMgr);
QS_FUN_DICTIONARY(&amp;QHsm_top);
QS_FUN_DICTIONARY(&amp;CommMgr_initial);
QS_FUN_DICTIONARY(&amp;CommMgr_Active);

/* Subscribe to I2C read and write done signals since it will be publishing them */
QActive_subscribe((QActive *)me, I2C1_DEV_READ_DONE_SIG);
QActive_subscribe((QActive *)me, I2C1_DEV_WRITE_DONE_SIG);
QActive_subscribe((QActive *)me, DB_GET_ELEM_SIG);
QActive_subscribe((QActive *)me, DB_SET_ELEM_SIG);
QActive_subscribe((QActive *)me, DB_FULL_RESET_SIG);

me-&gt;isDBValid = false;
me-&gt;dbVersionDef = DB_VERSION_DEF;
me-&gt;dbMagicWordDef = DB_MAGIC_WORD_DEF;

/* Post to self to validate DB on startup */
QEvt *evt = Q_NEW(QEvt, DB_INTRNL_CHECK_SETTINGS_SIG);
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);

#if CPLR_BOOT
/* If this is the bootloader, also validate the bootloader build datetime 
 * and version in the DB. */
QEvt *evt1 = Q_NEW(QEvt, DB_INTRNL_CHECK_BOOTLDR_VER_SIG);
QACTIVE_POST(AO_SysMgr, (QEvt *)evt1, me);
#endif</action>
     <initial_glyph conn="1,2,4,3,9,5">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="Active">
     <documentation>/**
 * This state is a catch-all Active state.  If any signals need
 * to be handled that do not cause state transitions and are
 * common to the entire AO, they should be handled here.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
     <entry>/* Post and disarm all the timer events so they can be rearmed at any time */
QTimeEvt_postIn(
    &amp;me-&gt;sysTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
);
QTimeEvt_disarm(&amp;me-&gt;sysTimerEvt);

QTimeEvt_postIn(
    &amp;me-&gt;dbTimerEvt,
    (QActive *)me,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_SYS_MGR )
);
QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);</entry>
     <state name="Idle">
      <documentation>/**
 * @brief	Idle state that allows new messages to be received.
 * The Idle state allows for handling of new incoming msgs. Msgs in other states
 * will be either deferred or ignored.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Clear out all the variables on entry to Idle state.  By this point, any error
 * feedback should have already happened. */
me-&gt;errorCode       = ERR_NONE;
me-&gt;accessType      = _DC3_ACCESS_NONE;
me-&gt;dbCmd           = DB_OP_NONE;
me-&gt;dataLen         = 0;
me-&gt;currRetry       = 0;
memset(me-&gt;dataBuf, 0, sizeof(me-&gt;dataBuf));

/* recall the request from the private requestQueue */
QActive_recall(
    (QActive *)me,
    &amp;me-&gt;deferredEvtQueue
);
</entry>
      <tran trig="DB_GET_ELEM" target="../../1/2">
       <action>DBG_printf(&quot;DB_GET_ELEM, posting DB_READ\n&quot;);

me-&gt;dbElem = ((DBReadReqEvt const *)e)-&gt;dbElem;
me-&gt;dbCmd = DB_OP_READ;
me-&gt;accessType = ((DBReadReqEvt const *)e)-&gt;accessType;

/* Change the signal associated with event and re post to self so it gets handled
 * in the AccessingDB state without having to recopy all the data in the event. */
((DBReadReqEvt *)e)-&gt;super.sig = DB_READ_SIG;
QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);</action>
       <tran_glyph conn="6,18,3,3,33">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DB_SET_ELEM" target="../../1/2">
       <action>DBG_printf(&quot;DB_SET_ELEM, posting DB_WRITE\n&quot;);

me-&gt;dbElem = ((DBReadReqEvt const *)e)-&gt;dbElem;
me-&gt;dbCmd = DB_OP_WRITE;
me-&gt;accessType = ((DBReadReqEvt const *)e)-&gt;accessType;

/* Change the signal associated with event and re post to self so it gets handled
 * in the AccessingDB state without having to recopy all the data in the event. */
((DBWriteReqEvt *)e)-&gt;super.sig = DB_WRITE_SIG;
QACTIVE_POST(AO_SysMgr, (QEvt *)e, me);</action>
       <tran_glyph conn="6,21,3,3,33">
        <action box="0,-2,10,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DB_INTRNL_CHECK_SETTINGS" target="../../1/2/6">
       <action>me-&gt;dbCmd = DB_OP_INTERNAL;</action>
       <tran_glyph conn="6,34,3,3,35">
        <action box="0,-2,21,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DB_INTRNL_CHECK_BOOTLDR_VER" target="../../1/2/9">
       <action>me-&gt;dbCmd = DB_OP_INTERNAL;</action>
       <tran_glyph conn="6,104,3,3,76,-76,7">
        <action box="0,-2,25,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DB_FULL_RESET" target="../../1/2/22">
       <action>/* Need to set some DB element since the reply carries this back.  This is technically
 * the first and most important field being written so this seems like a safe choice.
 * Realistically, the reply shouldn't even include this info so it technically doesn't
 * matter. */
me-&gt;dbElem = _DC3_DB_MAGIC_WORD;
me-&gt;dbCmd = DB_OP_WRITE;
me-&gt;accessType = _DC3_ACCESS_QPC;
</action>
       <tran_glyph conn="6,96,3,3,38">
        <action box="0,-2,12,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DB_INTRNL_FULL_RESET" target="../../1/2/22">
       <action>me-&gt;dbCmd = DB_OP_INTERNAL;
me-&gt;accessType = _DC3_ACCESS_QPC;</action>
       <tran_glyph conn="6,93,3,3,38">
        <action box="0,-2,19,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="6,8,14,113">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Busy">
      <documentation>/**
 * @brief	Busy state for msg processing.
 * This state handles msg processing and indicates that the system is busy and
 * cannot process another msg at this time.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
      <entry>/* Arm the timer so if the message can't be processed for some reason, we can get
 * back to idle state.  This timer may be re-armed if some messages require more 
 * time to process than others. */
QTimeEvt_rearm(
    &amp;me-&gt;sysTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
);
</entry>
      <exit>QTimeEvt_disarm(&amp;me-&gt;sysTimerEvt);                 /* Disarm timer on exit */
</exit>
      <tran trig="SYS_MGR_TIMEOUT" target="../../0">
       <tran_glyph conn="37,118,3,1,-17">
        <action box="-15,-2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DB_SET_ELEM, DB_GET_ELEM, DB_INTRNL_CHECK_SETTINGS, DB_INTRNL_CHECK_BOOTLDR_VER">
       <action>if (QEQueue_getNFree(&amp;me-&gt;deferredEvtQueue) &gt; 0) {
   /* defer the request - this event will be handled
    * when the state machine goes back to Idle state */
   QActive_defer((QActive *)me, &amp;me-&gt;deferredEvtQueue, e);
} else {
   /* notify the request sender that the request was ignored.. */
   ERR_printf(&quot;Unable to defer DB request\n&quot;);
}</action>
       <tran_glyph conn="37,116,3,-1,34">
        <action box="1,-6,25,6"/>
       </tran_glyph>
      </tran>
      <state name="AccessingDB">
       <documentation>/**
 * @brief    State that waits for DB access to complete.
 * This state handles DB access requests and indicates that the system is busy and
 * cannot process another msg at this time.  It is also used to timeout requests that
 * may have hung.
 *
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
       <entry>/* Set the error code in case of timeout */
me-&gt;errorCode = ERR_DB_ACCESS_TIMEOUT;

/* Arm the timer so if DB access is broken, the system can properly return an error */
QTimeEvt_rearm(
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( LL_MAX_TOUT_SEC_DB_ACCESS )
);
</entry>
       <exit>QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);                 /* Disarm timer on exit */

if ( me-&gt;dbCmd == DB_OP_READ ) {
    DBReadDoneEvt *evt = Q_NEW(DBReadDoneEvt, DB_GET_ELEM_DONE_SIG);
    evt-&gt;status = me-&gt;errorCode;
    evt-&gt;dbElem  = me-&gt;dbElem;
    evt-&gt;dataLen = me-&gt;dataLen;
    MEMCPY(evt-&gt;dataBuf, me-&gt;dataBuf, evt-&gt;dataLen);
    DBG_printf(&quot;Publishing DB_GET_ELEM_DONE_SIG with %d len and error 0x%08x\n&quot;,evt-&gt;dataLen, evt-&gt;status);

    if ( _DC3_ACCESS_FRT == me-&gt;accessType ) {
#if CPLR_APP
        /* Post directly to the &quot;raw&quot; queue for FreeRTOS task to read */
        QEQueue_postFIFO(&amp;CPLR_evtQueue, (QEvt *)evt);
        vTaskResume( xHandle_CPLR );
#elif CPLR_BOOT
        /* Publish the event so other AOs can get it if they want */
        QF_PUBLISH((QEvt *)evt, AO_SysMgr);
#else
    #error &quot;Invalid build.  CPLR_APP or CPLR_BOOT must be specified&quot;
#endif

    } else {
        /* Publish the event so other AOs can get it if they want */
        QF_PUBLISH((QEvt *)evt, AO_SysMgr);
    }

} else if ( me-&gt;dbCmd == DB_OP_WRITE ) {
    DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_SET_ELEM_DONE_SIG);
    evt-&gt;status = me-&gt;errorCode;
    evt-&gt;dbElem  = me-&gt;dbElem;

    if ( _DC3_ACCESS_FRT == me-&gt;accessType ) {
#if CPLR_APP
        /* Post directly to the &quot;raw&quot; queue for FreeRTOS task to read */
        QEQueue_postFIFO(&amp;CPLR_evtQueue, (QEvt *)evt);
        vTaskResume( xHandle_CPLR );
#elif CPLR_BOOT
        /* Publish the event so other AOs can get it if they want */
        QF_PUBLISH((QEvt *)evt, AO_SysMgr);
#else
    #error &quot;Invalid build.  CPLR_APP or CPLR_BOOT must be specified&quot;
#endif

    } else {
        /* Publish the event so other AOs can get it if they want */
        QF_PUBLISH((QEvt *)evt, AO_SysMgr);
    }
} else if ( me-&gt;dbCmd == DB_OP_INTERNAL ) {
    /* Do nothing in this case.  Internal operations are for DB
     * validation and similar actions and are initiated intenally so
     * so nobody is expecting a response */
    if ( ERR_NONE != me-&gt;errorCode ) {
        ERR_printf(&quot;Internal DB op failed with error code: 0x%08x\n&quot;, me-&gt;errorCode);
    }
} else {
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    ERR_printf(&quot;Invalid DB operation (%d) specified somehow\n&quot;, me-&gt;dbCmd);
    DBWriteDoneEvt *evt = Q_NEW(DBWriteDoneEvt, DB_ERROR_SIG);
    evt-&gt;status = me-&gt;errorCode;
    evt-&gt;dbElem  = me-&gt;dbElem;

    if ( _DC3_ACCESS_FRT == me-&gt;accessType ) {
#if CPLR_APP
        /* Post directly to the &quot;raw&quot; queue for FreeRTOS task to read */
        QEQueue_postFIFO(&amp;CPLR_evtQueue, (QEvt *)evt);
        vTaskResume( xHandle_CPLR );
#elif CPLR_BOOT
        /* Publish the event so other AOs can get it if they want */
        QF_PUBLISH((QEvt *)evt, AO_SysMgr);
#else
    #error &quot;Invalid build.  CPLR_APP or CPLR_BOOT must be specified&quot;
#endif
    } else {
        /* Publish the event so other AOs can get it if they want */
        QF_PUBLISH((QEvt *)evt, AO_SysMgr);
    }
}</exit>
       <tran trig="DB_ACCESS_TIMEOUT" target="../../../0">
        <tran_glyph conn="39,31,3,1,-19">
         <action box="-17,-2,15,2"/>
        </tran_glyph>
       </tran>
       <tran trig="DB_READ">
        <action>LOG_printf(&quot;DB_READ via %s access to read: %s (%d)\n&quot;,
    CON_accessToStr( ((DBReadReqEvt const *)e)-&gt;accessType ),
    CON_dbElemToStr( ((DBReadReqEvt const *)e)-&gt;dbElem ),
    ((DBReadReqEvt const *)e)-&gt;dbElem
);

/* Find where the element lives */
DB_ElemLoc_t loc = DB_getElemLoc( ((DBReadReqEvt const *)e)-&gt;dbElem );

   /* 3. Call the location dependent functions to retrieve the data from DB */
switch( loc ) {
    case DB_EEPROM:                           /* Intentionally fall through */
    case DB_SN_ROM:                           /* Intentionally fall through */
    case DB_UI_ROM:
        ;
        /* Create the event and directly post it to the right AO. */
        I2CReadReqEvt *i2cReadReqEvt  = Q_NEW(I2CReadReqEvt, I2C1_DEV_RAW_MEM_READ_SIG);
        i2cReadReqEvt-&gt;i2cDev         = DB_getI2CDev(loc);
        i2cReadReqEvt-&gt;start          = DB_getElemOffset(((DBReadReqEvt const *)e)-&gt;dbElem);
        i2cReadReqEvt-&gt;bytes          = DB_getElemSize(((DBReadReqEvt const *)e)-&gt;dbElem);
        i2cReadReqEvt-&gt;accessType     = me-&gt;accessType;
        QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cReadReqEvt), me);
        break;
    case DB_GPIO:
        me-&gt;errorCode = ERR_UNIMPLEMENTED;
        QEvt *evtGPIO = Q_NEW(QEvt, DB_OP_DONE_SIG);
        QACTIVE_POST(AO_SysMgr, evtGPIO, me);
        break;
    case DB_FLASH:
        ;
        me-&gt;errorCode = DB_readEEPROM(
            ((DBReadReqEvt const *)e)-&gt;dbElem,
            MAX_DB_ELEM_SIZE,
            me-&gt;dataBuf,
            &amp;(me-&gt;dataLen)
        );
        QEvt *evtFlash = Q_NEW(QEvt, DB_OP_DONE_SIG);
        QACTIVE_POST(AO_SysMgr, evtFlash, me);
        break;
        /* Add more locations here. Anything that fails will go to the default
         * case and get logged as an error. */
    default:
        me-&gt;errorCode  = ERR_DB_ELEM_NOT_FOUND;
        QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
        QACTIVE_POST(AO_SysMgr, evtNotFound, me);
        break;
}</action>
        <tran_glyph conn="39,24,3,-1,12">
         <action box="0,-2,8,2"/>
        </tran_glyph>
       </tran>
       <tran trig="DB_WRITE">
        <action>LOG_printf(&quot;DB_WRITE via %s access to write: %s (%d)\n&quot;,
    CON_accessToStr( ((DBWriteReqEvt const *)e)-&gt;accessType ),
    CON_dbElemToStr( ((DBWriteReqEvt const *)e)-&gt;dbElem ),
    ((DBWriteReqEvt const *)e)-&gt;dbElem
);

/* Find where the element lives */
DB_ElemLoc_t loc = DB_getElemLoc( ((DBWriteReqEvt const *)e)-&gt;dbElem );

   /* 3. Call the location dependent functions to retrieve the data from DB */
switch( loc ) {
    case DB_EEPROM:
        ;
        /* Create the event and directly post it to the right AO. */
        I2CWriteReqEvt *i2cWriteReqEvt  = Q_NEW(I2CWriteReqEvt, I2C1_DEV_RAW_MEM_WRITE_SIG);
        i2cWriteReqEvt-&gt;i2cDev         = DB_getI2CDev(loc);
        i2cWriteReqEvt-&gt;start          = DB_getElemOffset(((DBWriteReqEvt const *)e)-&gt;dbElem);
        i2cWriteReqEvt-&gt;bytes          = DB_getElemSize(((DBWriteReqEvt const *)e)-&gt;dbElem);
        i2cWriteReqEvt-&gt;accessType     = me-&gt;accessType;
        MEMCPY(i2cWriteReqEvt-&gt;dataBuf, ((DBWriteReqEvt const *)e)-&gt;dataBuf, i2cWriteReqEvt-&gt;bytes);
        QACTIVE_POST(AO_I2C1DevMgr, (QEvt *)(i2cWriteReqEvt), me);
        DBG_printf(&quot;Posting a write req to I2C1DevMgr\n&quot;);
        break;
    case DB_GPIO:                             /* Intentionally fall through */
    case DB_SN_ROM:                           /* Intentionally fall through */
    case DB_UI_ROM:                           /* Intentionally fall through */
    case DB_FLASH:
        me-&gt;errorCode = ERR_DB_ELEM_IS_READ_ONLY;
        QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
        QACTIVE_POST(AO_SysMgr, evt, me);
        break;
        /* Add more locations here. Anything that fails will go to the default
         * case and get logged as an error. */
    default:
        me-&gt;errorCode  = ERR_DB_ELEM_NOT_FOUND;
        QEvt *evtNotFound = Q_NEW(QEvt, DB_OP_DONE_SIG);
        QACTIVE_POST(AO_SysMgr, evtNotFound, me);
        break;
}</action>
        <tran_glyph conn="39,27,3,-1,12">
         <action box="0,-2,8,2"/>
        </tran_glyph>
       </tran>
       <tran trig="DB_OP_DONE" target="../../../0">
        <tran_glyph conn="39,29,3,1,-19">
         <action box="-13,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="I2C1_DEV_READ_DONE">
        <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;
if ( ERR_NONE == me-&gt;errorCode ) {
    me-&gt;dataLen = ((I2CReadDoneEvt const *) e)-&gt;bytes;
    if ( me-&gt;dataLen &gt; MAX_DB_ELEM_SIZE ) {
        me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    } else {
        MEMCPY(me-&gt;dataBuf, ((I2CReadDoneEvt const *) e)-&gt;dataBuf, me-&gt;dataLen);
    }
}

/* Self post to let the exit condition handle the sending back to requester */
QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
QACTIVE_POST(AO_SysMgr, evt, me);</action>
        <tran_glyph conn="138,18,1,-1,-23">
         <action box="-20,-2,18,2"/>
        </tran_glyph>
       </tran>
       <tran trig="I2C1_DEV_WRITE_DONE">
        <action>me-&gt;errorCode = ((I2CWriteDoneEvt const *) e)-&gt;status;

/* Self post to let the exit condition handle the sending back to requester */
QEvt *evt = Q_NEW(QEvt, DB_OP_DONE_SIG);
QACTIVE_POST(AO_SysMgr, evt, me);</action>
        <tran_glyph conn="138,21,1,-1,-23">
         <action box="-20,-2,18,2"/>
        </tran_glyph>
       </tran>
       <state name="DBMagicWordCheck">
        <documentation>/**
 * @brief    Check DB magic number and reset DB to default values if invalid.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
);

/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_MAGIC_WORD;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);                  /* Disarm timer on exit */</exit>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

if( !DB_isArraysMatch(
    ((I2CReadDoneEvt const *) e)-&gt;dataBuf,
    (uint8_t *)&amp;(me-&gt;dbMagicWordDef),
    ((I2CReadDoneEvt const *) e)-&gt;bytes ) ) {
    /* If the check fails, set the error code */
    me-&gt;errorCode = ERR_DB_NOT_INIT;

    WRN_printf(&quot;Invalid DB magic word. Error 0x%08x\n&quot;, me-&gt;errorCode);
    WRN_printf(&quot;Compiled: bytes: %x\n&quot;, me-&gt;dbMagicWordDef );

    CON_hexToStr(
        ((I2CReadDoneEvt const *) e)-&gt;dataBuf, // data to convert
        ((I2CReadDoneEvt const *) e)-&gt;bytes, // length of data to convert
        (char *)me-&gt;dataBuf,                 // where to write output
        sizeof(me-&gt;dataBuf),                 // max size of output buffer
        &amp;(me-&gt;dataLen),                      // size of the resulting output
        0,                                   // no columns
        ' ',                                 // separator
        false                                // bPrintX
    );

    WRN_printf(&quot;In DB   : bytes: %s\n&quot;, me-&gt;dataBuf );

    goto END_ERROR_CHECK;
}

/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_MAGIC_WORD),
    _DC3_DB_MAGIC_WORD
);</action>
         <choice target="../../../8">
          <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
          <choice_glyph conn="43,40,4,0,4">
           <action box="-7,1,7,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../7">
          <guard>else</guard>
          <choice_glyph conn="43,40,5,3,16,-6,3">
           <action box="2,0,5,3"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="43,37,2,-1,3">
          <action box="0,0,16,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="41,30,15,7">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="ResetDBMagicWord">
        <documentation>/**
 * @brief   Reset the DB magic word to default values.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Resetting %s to default...\n&quot;, CON_dbElemToStr(_DC3_DB_MAGIC_WORD));

uint32_t dbMagicWord = DB_MAGIC_WORD_DEF;

/* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_MAGIC_WORD;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_MAGIC_WORD);
MEMCPY(evt-&gt;dataBuf, (uint8_t *)&amp;dbMagicWord, evt-&gt;dataLen);
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE" target="../../10">
         <tran_glyph conn="64,37,2,0,7">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="62,30,14,7">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="DBVersionCheck">
        <documentation>/**
 * @brief    Check DB version and reset DB to default values if invalid.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
);

/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_VERSION;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);                  /* Disarm timer on exit */</exit>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

if( !DB_isArraysMatch(
    ((I2CReadDoneEvt const *) e)-&gt;dataBuf,
    (uint8_t *)&amp;(me-&gt;dbVersionDef),
    ((I2CReadDoneEvt const *) e)-&gt;bytes ) ) {
    /* If the check fails, set the error code */
    me-&gt;errorCode = ERR_DB_NOT_INIT;

    WRN_printf(&quot;Invalid DB version. Error 0x%08x\n&quot;, me-&gt;errorCode);
    WRN_printf(&quot;Compiled: bytes: %x\n&quot;, me-&gt;dbVersionDef );

    CON_hexToStr(
        ((I2CReadDoneEvt const *) e)-&gt;dataBuf, // data to convert
        ((I2CReadDoneEvt const *) e)-&gt;bytes, // length of data to convert
        (char *)me-&gt;dataBuf,                 // where to write output
        sizeof(me-&gt;dataBuf),                 // max size of output buffer
        &amp;(me-&gt;dataLen),                      // size of the resulting output
        0,                                   // no columns
        ' ',                                 // separator
        false                                // bPrintX
    );

    WRN_printf(&quot;In DB   : bytes: %s\n&quot;, me-&gt;dataBuf );

    goto END_ERROR_CHECK;
}

/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_VERSION),
    _DC3_DB_VERSION
);</action>
         <choice target="../../../18">
          <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
          <choice_glyph conn="43,55,4,0,3">
           <action box="-7,-2,7,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../10">
          <guard>else</guard>
          <choice_glyph conn="43,55,5,3,17,-8,2">
           <action box="3,-2,5,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="43,51,2,-1,4">
          <action box="0,0,18,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="41,44,15,7">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="BootLdrBuildDTCheck">
        <documentation>/**
 * @brief    Check bootloader build datetime and fix it if it doesn't match.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>#if CPLR_BOOT                         /* Only compile this if this is the Bootloader */
DBG_printf(&quot;Validating %s (%d)...\n&quot;,
    CON_dbElemToStr(_DC3_DB_BOOT_BUILD_DATETIME),
    _DC3_DB_BOOT_BUILD_DATETIME);

/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_BOOT_BUILD_DATETIME;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);
#else                                /* Only compile this if this is the Application */
me-&gt;errorCode = ERR_MSG_UNSUPPORTED_IN_APPLICATION;
ERR_printf(&quot;Attempting to validate/set Bootloader info in Application. Error: 0x%08x\n&quot;, me-&gt;errorCode);

#endif</entry>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

if( !DB_isArraysMatch(
    ((I2CReadDoneEvt const *) e)-&gt;dataBuf,
    (uint8_t *)BUILD_DATE,
    ((I2CReadDoneEvt const *) e)-&gt;bytes ) ) {
    /* If the check fails, set the error code */
    me-&gt;errorCode = ERR_DB_DATETIME_MISMATCH;

    WRN_printf(&quot;Bootloader datetime mismatch. Error 0x%08x\n&quot;, me-&gt;errorCode);
    LOG_printf(&quot;Note, this error is expected on first boot after a new bootloader was just flashed\n&quot;);

    CON_hexToStr(
        ((I2CReadDoneEvt const *) e)-&gt;dataBuf, // data to convert
        ((I2CReadDoneEvt const *) e)-&gt;bytes, // length of data to convert
        (char *)me-&gt;dataBuf,                 // where to write output
        sizeof(me-&gt;dataBuf),                 // max size of output buffer
        &amp;me-&gt;dataLen,                        // size of the resulting output
        0,                                   // no columns
        ' ',                                 // separator
        false                                // bPrintX
    );

    WRN_printf(&quot;In DB:    bytes: %s, string: %s\n&quot;,
        me-&gt;dataBuf, ((I2CReadDoneEvt const *) e)-&gt;dataBuf
    );

    CON_hexToStr(
        (uint8_t *)BUILD_DATE,               // data to convert
        strlen(BUILD_DATE),                  // length of data to convert
        (char *)me-&gt;dataBuf,                 // where to write output
        sizeof(me-&gt;dataBuf),                 // max size of output buffer
        &amp;me-&gt;dataLen,                        // size of the resulting output
        0,                                   // no columns
        ' ',                                 // separator
        false                                 // bPrintX
    );

    WRN_printf(&quot;Compiled: bytes: %s, string: %s\n&quot;,
        me-&gt;dataBuf, BUILD_DATE
    );

    goto END_ERROR_CHECK;
}

/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_BOOT_BUILD_DATETIME),
    _DC3_DB_BOOT_BUILD_DATETIME
);</action>
         <choice target="../../../13">
          <guard brief="NoError?">me-&gt;errorCode == ERR_NONE</guard>
          <action>//me-&gt;errorCode = DB_checkDTMatch( ((I2CReadDoneEvt const *) e)-&gt;dataBuf, (uint8_t *)BUILD_DATE );

DBG_printf(&quot;Bootloader datetime match\n&quot;);</action>
          <choice_glyph conn="91,34,4,0,3">
           <action box="-7,0,9,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../11">
          <guard>else</guard>
          <choice_glyph conn="91,34,5,3,16,-6,2">
           <action box="1,0,10,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="91,31,2,-1,3">
          <action box="0,0,15,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="89,25,14,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="ResetDBVersion">
        <documentation>/**
 * @brief   Reset the DB version to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Resetting %s to default...\n&quot;, CON_dbElemToStr(_DC3_DB_VERSION));

/* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_VERSION;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_VERSION);
uint16_t dbVersion = DB_VERSION_DEF;
MEMCPY(evt-&gt;dataBuf, (uint8_t *)&amp;dbVersion, evt-&gt;dataLen);
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE" target="../../19">
         <action>me-&gt;currRetry++;</action>
         <tran_glyph conn="64,51,2,0,7">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="62,44,14,7">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="SetBootLdrDatetime">
        <documentation>/**
 * @brief   Reset the bootloader build datetime.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Setting %s (%d) in DB to %s.\n&quot;,
    CON_dbElemToStr(_DC3_DB_BOOT_BUILD_DATETIME),
    _DC3_DB_BOOT_BUILD_DATETIME, BUILD_DATE);

/* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_BOOT_BUILD_DATETIME;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_BOOT_BUILD_DATETIME);
MEMCPY(evt-&gt;dataBuf, (uint8_t *)BUILD_DATE, evt-&gt;dataLen);
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE" target="../../12">
         <tran_glyph conn="112,31,2,0,6">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="109,25,14,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="SetBootLdrMajVer">
        <documentation>/**
 * @brief   Reset the bootloader major version.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Setting %s (%d) in DB to %s.\n&quot;,
    CON_dbElemToStr(_DC3_DB_BOOT_MAJ),
    _DC3_DB_BOOT_MAJ, FW_VER_MAJOR);

/* Post to SysMgr to set the major version since we no longer trust it */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_BOOT_MAJ;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_BOOT_MAJ);
evt-&gt;dataBuf[0] = FW_VER_MAJOR;

QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE" target="../../15">
         <tran_glyph conn="112,43,2,0,6">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="109,37,14,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="BootLdrMajVerCheck">
        <documentation>/**
 * @brief    Check bootloader major version and fix it if it doesn't match.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_BOOT_MAJ;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

if( ((I2CReadDoneEvt const *) e)-&gt;dataBuf[0] != FW_VER_MAJOR ) {
    me-&gt;errorCode = ERR_DB_INVALID_MAJ_VER_MISMATCH;
    WRN_printf(&quot;Bootloader %s mismatch. DB: %d, Compiled: %d\n&quot;,
        CON_dbElemToStr(_DC3_DB_BOOT_MAJ),
        ((I2CReadDoneEvt const *) e)-&gt;dataBuf[0], FW_VER_MAJOR
    );
    goto END_ERROR_CHECK;
}


/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_BOOT_MAJ),
    _DC3_DB_BOOT_MAJ
);</action>
         <choice target="../../../14">
          <guard brief="NoError?">me-&gt;errorCode == ERR_NONE</guard>
          <choice_glyph conn="91,46,4,0,3">
           <action box="-7,0,9,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../12">
          <guard>else</guard>
          <choice_glyph conn="91,46,5,3,16,-6,2">
           <action box="2,0,4,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="91,43,2,-1,3">
          <action box="0,0,15,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="89,37,14,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="BootLdrMinVerCheck">
        <documentation>/**
 * @brief    Check bootloader minor version and fix it if it doesn't match.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_BOOT_MIN;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

if( ((I2CReadDoneEvt const *) e)-&gt;dataBuf[0] != FW_VER_MINOR ) {
    me-&gt;errorCode = ERR_DB_INVALID_MIN_VER_MISMATCH;
    WRN_printf(&quot;Bootloader %s mismatch. DB: %d, Compiled: %d\n&quot;,
        CON_dbElemToStr(_DC3_DB_BOOT_MIN),
        ((I2CReadDoneEvt const *) e)-&gt;dataBuf[0], FW_VER_MINOR
    );
    goto END_ERROR_CHECK;
}


/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_BOOT_MIN),
    _DC3_DB_BOOT_MIN
);</action>
         <choice target="../../../../../0">
          <guard brief="NoError?">me-&gt;errorCode == ERR_NONE</guard>
          <action>LOG_printf(&quot;Bootloader version and build datetime validation complete\n&quot;);</action>
          <choice_glyph conn="91,59,4,1,46,-71">
           <action box="-7,0,9,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../15">
          <guard>else</guard>
          <choice_glyph conn="91,59,5,3,15,-8,3">
           <action box="2,-2,4,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="91,55,2,-1,4">
          <action box="0,0,15,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="89,49,15,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="SetBootLdrMinVer">
        <documentation>/**
 * @brief   Reset the bootloader minor version.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Setting %s (%d) in DB to %s.\n&quot;,
    CON_dbElemToStr(_DC3_DB_BOOT_MIN),
    _DC3_DB_BOOT_MIN, FW_VER_MINOR);

/* Post to SysMgr to set the major version since we no longer trust it */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_BOOT_MIN;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_BOOT_MIN);
evt-&gt;dataBuf[0] = FW_VER_MINOR;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE">
         <action>me-&gt;currRetry++;</action>
         <choice target="../../../16">
          <guard brief="Retry?">me-&gt;currRetry &lt; MAX_RETRIES</guard>
          <choice_glyph conn="112,60,5,2,15,-30">
           <action box="1,0,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_DB_NOT_INIT;
ERR_printf(&quot;Out of retries when attempting to reset DB to a valid state. Error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
          <choice_glyph conn="112,60,4,1,46,-92">
           <action box="0,3,10,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="112,55,2,-1,5">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="109,49,14,6">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="Wait2">
        <documentation>/**
 * @brief   Small timeout to make sure that retries don't overwhelm the logging 
 * system.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIME_SEC_BETWEEN_RETRIES )
);
</entry>
        <tran trig="DB_ACCESS_TIMEOUT" target="../../9">
         <tran_glyph conn="126,25,0,0,-1,-28,1">
          <action box="-8,-3,15,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="125,25,10,5">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="Wait1">
        <documentation>/**
 * @brief   Small timeout to make sure that retries don't overwhelm the logging 
 * system.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( LL_MAX_TIME_SEC_BETWEEN_RETRIES )
);
</entry>
        <tran trig="DB_ACCESS_TIMEOUT" target="../../6">
         <tran_glyph conn="72,26,3,0,-17,4">
          <action box="-16,-2,15,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="72,23,7,5">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="DBGetDebugModules">
        <documentation>/**
 * @brief    Check DB debug modules and reset DB to default values if invalid.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
);

/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_DBG_MODULES;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);                  /* Disarm timer on exit */</exit>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_DBG_MODULES),
    _DC3_DB_DBG_MODULES
);</action>
         <choice target="../../../20">
          <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
          <choice_glyph conn="43,69,4,0,3">
           <action box="-7,-2,7,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../19">
          <guard>else</guard>
          <choice_glyph conn="43,69,5,3,17,-8,2">
           <action box="3,-2,5,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="43,65,2,-1,4">
          <action box="0,0,18,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="41,58,15,7">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="ResetDBDbgModules">
        <documentation>/**
 * @brief   Reset the DB debug modules to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Resetting %s to default...\n&quot;, CON_dbElemToStr(_DC3_DB_DBG_MODULES));

/* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_DBG_MODULES;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_DBG_MODULES);
uint32_t dbDbgModules = DB_DBG_MODULES_DEF;
MEMCPY(evt-&gt;dataBuf, (uint8_t *)&amp;dbDbgModules, evt-&gt;dataLen);
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE" target="../../21">
         <action>me-&gt;currRetry++;</action>
         <tran_glyph conn="64,65,2,0,7">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="62,58,14,7">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="DBGetDebugDevices">
        <documentation>/**
 * @brief    Check DB debug modules and reset DB to default values if invalid.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
);

/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_DBG_DEVICES;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);                  /* Disarm timer on exit */</exit>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_DBG_DEVICES),
    _DC3_DB_DBG_DEVICES
);</action>
         <choice target="../../../../../0">
          <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
          <action>LOG_printf(&quot;DB integrity and version validation complete.\n&quot;);
me-&gt;isDBValid = true;</action>
          <choice_glyph conn="43,83,5,1,-23">
           <action box="-7,-2,7,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../21">
          <guard>else</guard>
          <choice_glyph conn="43,83,5,3,17,-8,2">
           <action box="3,-2,5,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="43,79,2,-1,4">
          <action box="0,0,18,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="41,72,15,7">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="ResetDBDbgDevices">
        <documentation>/**
 * @brief   Reset the DB debug Devices to default value.
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Resetting %s to default...\n&quot;, CON_dbElemToStr(_DC3_DB_DBG_DEVICES));

/* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_DBG_DEVICES;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_DBG_DEVICES);
uint8_t dbgDevices = DB_DBG_DEVICES_DEF;
MEMCPY(evt-&gt;dataBuf, (uint8_t *)&amp;dbgDevices, evt-&gt;dataLen);
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE">
         <action>me-&gt;currRetry++;</action>
         <choice target="../../../17">
          <guard brief="Retry?">me-&gt;currRetry &lt; MAX_RETRIES</guard>
          <choice_glyph conn="64,83,5,2,14,-55">
           <action box="2,0,10,2"/>
          </choice_glyph>
         </choice>
         <choice target="../../../../../0">
          <guard>else</guard>
          <action>me-&gt;errorCode = ERR_DB_NOT_INIT;
ERR_printf(&quot;Out of retries when attempting to reset DB to a valid state. Error: 0x%08x\n&quot;, me-&gt;errorCode);</action>
          <choice_glyph conn="64,83,4,1,4,-44">
           <action box="-4,0,6,2"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="64,79,2,-1,4">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="62,72,14,7">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state name="DBFullReset">
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
);


/* This function will fill out the appropriate data and post the event to reset the DB */
me-&gt;errorCode = DB_initToDefault( me-&gt;accessType );</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);                  /* Disarm timer on exit */</exit>
        <tran trig="DB_OP_DONE" target="../../../../0">
         <tran_glyph conn="44,100,3,1,-24">
          <action box="-17,-2,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="44,91,15,12">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="DBCheckElem">
        <documentation>/**
 * @brief    Check DB element
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>QTimeEvt_rearm(                                       /* Re-arm timer on entry */
    &amp;me-&gt;dbTimerEvt,
    SEC_TO_TICKS( HL_MAX_TOUT_SEC_COMM_DB_VALIDATE )
);

/* Post to SysMgr to get the build datetime first since it's the one most likely to
 * be incorrect */
DBReadReqEvt *evt = Q_NEW(DBReadReqEvt, DB_READ_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_MAGIC_WORD;
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), AO_SysMgr);</entry>
        <exit>QTimeEvt_disarm(&amp;me-&gt;dbTimerEvt);                  /* Disarm timer on exit */</exit>
        <tran trig="I2C1_DEV_READ_DONE">
         <action>me-&gt;errorCode = ((I2CReadDoneEvt const *) e)-&gt;status;

if ( ERR_NONE != me-&gt;errorCode ) {
    goto END_ERROR_CHECK;
}

if ( ((I2CReadDoneEvt const *) e)-&gt;bytes &gt; MAX_DB_ELEM_SIZE ) {
    /* This should be considered a pretty critical error. */
    me-&gt;errorCode = ERR_DB_ELEM_SIZE_OVERFLOW;
    goto END_ERROR_CHECK;
}

if( !DB_isArraysMatch(
    ((I2CReadDoneEvt const *) e)-&gt;dataBuf,
    (uint8_t *)&amp;(me-&gt;dbMagicWordDef),
    ((I2CReadDoneEvt const *) e)-&gt;bytes ) ) {
    /* If the check fails, set the error code */
    me-&gt;errorCode = ERR_DB_NOT_INIT;

    WRN_printf(&quot;Invalid DB magic word. Error 0x%08x\n&quot;, me-&gt;errorCode);
    WRN_printf(&quot;Compiled: bytes: %x\n&quot;, me-&gt;dbMagicWordDef );

    CON_hexToStr(
        ((I2CReadDoneEvt const *) e)-&gt;dataBuf, // data to convert
        ((I2CReadDoneEvt const *) e)-&gt;bytes, // length of data to convert
        (char *)me-&gt;dataBuf,                 // where to write output
        sizeof(me-&gt;dataBuf),                 // max size of output buffer
        &amp;(me-&gt;dataLen),                      // size of the resulting output
        0,                                   // no columns
        ' ',                                 // separator
        false                                // bPrintX
    );

    WRN_printf(&quot;In DB   : bytes: %s\n&quot;, me-&gt;dataBuf );

    goto END_ERROR_CHECK;
}

/* Local tag to jump to if an error is found or to reach naturally 
 * once all the checks are complete */
END_ERROR_CHECK:
ERR_COND_OUTPUT(
    me-&gt;errorCode,
    me-&gt;accessType,
    &quot;Error 0x%08x reading DB elem %s (%d)\n&quot;,
    me-&gt;errorCode,
    CON_dbElemToStr(_DC3_DB_MAGIC_WORD),
    _DC3_DB_MAGIC_WORD
);</action>
         <choice>
          <guard brief="NoError?">ERR_NONE == me-&gt;errorCode</guard>
          <choice_glyph conn="88,92,4,-1,4">
           <action box="-7,1,7,2"/>
          </choice_glyph>
         </choice>
         <choice>
          <guard>else</guard>
          <choice_glyph conn="88,92,5,-1,16,-6,3">
           <action box="2,0,5,3"/>
          </choice_glyph>
         </choice>
         <tran_glyph conn="88,89,2,-1,3">
          <action box="0,0,16,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="86,82,15,7">
         <entry box="1,2,6,2"/>
         <exit box="1,4,6,2"/>
        </state_glyph>
       </state>
       <state name="DBSetElem">
        <documentation>/**
 * @brief   Set the DB element to a specified value.
 * 
 * @param  [in|out] me: Pointer to the state machine
 * @param  [in|out]  e:  Pointer to the event being processed.
 * @return status: QState type that specifies where the state
 * machine is going next.
 */</documentation>
        <entry>WRN_printf(&quot;Resetting %s to default...\n&quot;, CON_dbElemToStr(_DC3_DB_MAGIC_WORD));

uint32_t dbMagicWord = DB_MAGIC_WORD_DEF;

/* Post to SysMgr to set the build datetime since it doesn't match the compiled one */
DBWriteReqEvt *evt = Q_NEW(DBWriteReqEvt, DB_WRITE_SIG);
evt-&gt;accessType = _DC3_ACCESS_QPC;
evt-&gt;dbElem = _DC3_DB_MAGIC_WORD;
evt-&gt;dataLen =  DB_getElemSize(_DC3_DB_MAGIC_WORD);
MEMCPY(evt-&gt;dataBuf, (uint8_t *)&amp;dbMagicWord, evt-&gt;dataLen);
QACTIVE_POST(AO_SysMgr, (QEvt *)(evt), me);</entry>
        <tran trig="DB_OP_DONE">
         <tran_glyph conn="110,89,2,-1,7">
          <action box="0,0,10,2"/>
         </tran_glyph>
        </tran>
        <state_glyph node="108,82,14,7">
         <entry box="1,2,6,2"/>
        </state_glyph>
       </state>
       <state_glyph node="39,14,99,94">
        <entry box="1,2,6,2"/>
        <exit box="1,4,6,2"/>
       </state_glyph>
      </state>
      <state_glyph node="37,8,102,112">
       <entry box="1,2,6,2"/>
       <exit box="1,4,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="3,3,137,121">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="142,126"/>
   </statechart>
  </class>
  <attribute name="AO_SysMgr" type="QActive * const" visibility="0x00" properties="0x00">
   <documentation>/**&lt; &quot;opaque&quot; pointer to the Active Object */</documentation>
  </attribute>
  <operation name="SysMgr_ctor" type="void" visibility="0x00" properties="0x00">
   <documentation>/**
 * @brief C &quot;constructor&quot; for SysMgr &quot;class&quot;.
 * Initializes all the timers and queues used by the AO and sets of the
 * first state.
 * @param  None
 * @param  None
 * @retval None
 */</documentation>
   <code>SysMgr *me = &amp;l_SysMgr;
QActive_ctor(&amp;me-&gt;super, (QStateHandler)&amp;SysMgr_initial);

/* Initialize the deferred event queue and storage for it */
QEQueue_init(
    &amp;me-&gt;deferredEvtQueue,
    (QEvt const **)( me-&gt;deferredEvtQSto ),
    Q_DIM(me-&gt;deferredEvtQSto)
);

QTimeEvt_ctor( &amp;me-&gt;sysTimerEvt, SYS_MGR_TIMEOUT_SIG );
QTimeEvt_ctor( &amp;me-&gt;dbTimerEvt, DB_ACCESS_TIMEOUT_SIG );</code>
  </operation>
 </package>
 <directory name=".">
  <file name="SysMgr_gen.c">
   <text>/**
 * @file    SysMgr.c
 * Declarations for functions for the SysMgr AO.  This state
 * machine handles various system level requests.
 *
 * Note: If editing this file, please make sure to update the SysMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/13/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupSys
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include &quot;SysMgr.h&quot;
#include &quot;project_includes.h&quot;           /* Includes common to entire project. */
#include &quot;bsp_defs.h&quot;     /* For seconds to bsp tick conversion (SEC_TO_TICK) */
#include &quot;I2C1DevMgr.h&quot;                         /* For accessing I2C1 devices */
#include &quot;Shared.h&quot;
#include &quot;i2c_dev.h&quot;
#include &quot;version.h&quot;
#if CPLR_APP
#include &quot;cplr.h&quot;
#elif CPLR_BOOT

#else
    #error &quot;Invalid build.  CPLR_APP or CPLR_BOOT must be specified&quot;
#endif

/* Compile-time called macros ------------------------------------------------*/
Q_DEFINE_THIS_FILE;                 /* For QSPY to know the name of this file */
DBG_DEFINE_THIS_MODULE( DC3_DBG_MODL_SYS ); /* For debug system to ID this module */

/* Private typedefs ----------------------------------------------------------*/
$declare(AOs::SysMgr)

/* Private defines -----------------------------------------------------------*/
#define MAX_RETRIES     5       /**&lt; Max number of times to retry operations. */
/* Private macros ------------------------------------------------------------*/
/* Private variables and Local objects ---------------------------------------*/
static SysMgr l_SysMgr;          /* the single instance of the Active object */

/* Global-scope objects ------------------------------------------------------*/
QActive * const AO_SysMgr = (QActive *)&amp;l_SysMgr;      /* &quot;opaque&quot; AO pointer */

/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
$define(AOs::SysMgr_ctor)

$define(AOs::SysMgr)

/**
 * @} end addtogroup groupSys
 */

/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
  <file name="SysMgr_gen.h">
   <text>/**
 * @file    SysMgr.h
 * Declarations for functions for the SysMgr AO.  This state
 * machine handles various system level requests.
 *
 * Note: If editing this file, please make sure to update the SysMgr.qm
 * model.  The generated code from that model should be very similar to the
 * code in this file.
 *
 * @date    05/13/2015
 * @author  Harry Rostovtsev
 * @email   harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 *
 * @addtogroup groupSys
 * @{
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef SYSMGR_H_
#define SYSMGR_H_

/* Includes ------------------------------------------------------------------*/
#include &quot;qp_port.h&quot;                                        /* for QP support */
#include &quot;DC3CommApi.h&quot;              /* For API for communicating with client */
#include &quot;DC3Signals.h&quot;             /* For QP signals available to the system */
#include &quot;db.h&quot;                                    /* For DB access and types */

/* Exported defines ----------------------------------------------------------*/
/* Exported macros -----------------------------------------------------------*/
/* Exported types ------------------------------------------------------------*/
$declare(Events)

/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
$declare(AOs::SysMgr_ctor)

$declare(AOs::AO_SysMgr)

/**
 * @} end addtogroup groupSys
 */

#endif                                                           /* SYSMGR_H_ */
/******** Copyright (C) 2015 Datacard. All rights reserved *****END OF FILE****/</text>
  </file>
 </directory>
</model>
