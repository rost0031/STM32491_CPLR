/******************************************************************************* 
 * File generated by Protoc for Embedded C and split by protobuf_lib_splitter.py
 * This file contains only the core functionality of protobuf-c so that it can 
 * be compiled into a separate library to prevent symbol crashes between 
 * multiple different protobuf generated libraries.
 *                                                   
 * Copyright (c) 2009-2012
 * Technische Universitaet Muenchen
 * http://www4.in.tum.de/
 * Copyright (c) 2013
 * Datacard Group
 *                                                                                                                                  
 * Do not edit.                                                                
 ******************************************************************************/
/******************************************************************* 
 * Header file generated by Protoc for Embedded C.                 *
 * Version 0.2 (2012-01-31)                                        *
 *                                                                 *
 * Copyright (c) 2009-2012                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : DC3Msgs.proto
 * Package: 
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/


/*******************************************************************
 * General functions
 *******************************************************************/

void _memset(void *msg_ptr, char init_val, unsigned int size);
int varint_packed_size(unsigned long value);
int write_raw_byte(char value, void *_buffer, int offset);
int write_raw_little_endian32(unsigned long value, void *_buffer, int offset);
int write_raw_little_endian64(unsigned long long value, void *_buffer, int offset);
int write_raw_varint32(unsigned long value, void *_buffer, int offset);
int write_raw_varint64(unsigned long long value, void *_buffer, int offset);
int write_raw_bytes(char *bytes, int bytes_size, void *_buffer, int offset);
unsigned long encode_zig_zag32(signed long n);
unsigned long long encode_zig_zag64(signed long long n);
signed long decode_zig_zag32(unsigned long n);
signed long long decode_zig_zag64(unsigned long long n);
int read_raw_byte(char *tag, void *_buffer, int offset);
int read_raw_little_endian32(unsigned long *tag, void *_buffer, int offset);
int read_raw_little_endian64(unsigned long long *tag, void *_buffer, int offset);
int read_raw_varint32(unsigned long *tag, void *_buffer, int offset);
int read_raw_varint64(unsigned long long *tag, void *_buffer, int offset);
int can_read_raw_varint32(void *_buffer, int offset, int length);
int can_read_raw_varint64(void *_buffer, int offset, int length);

/*
 * returns the size of a length delimited message which also 
 * contains the first bytes for the length encoding.
 */
unsigned long Message_get_delimited_size(void *_buffer, int offset);

/*
 * Tests whether a message can be completely read from the given buffer at
 * the offset. The bytes [offset..offset+length-1] are interpreted.
 *
 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
 * message or 0 (false) otherwise.
 */
int Message_can_read_delimited_from(void *_buffer, int offset, int length);


