/**
 * @file     DC3CommApi.h
 *
 * DC3 Communications API typedefs and enum defs that are related to the
 * generated messages.  This file should be included by any project that wants
 * to communicate with the DC3 board via the debug channel. It includes all the
 * error definitions, timeouts, and messages.
 *
 * @date       03/19/2015
 * @author     Harry Rostovtsev
 * @email      harry_rostovtsev@datacard.com
 * Copyright (C) 2015 Datacard. All rights reserved.
 */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef DC3COMMAPI_H_
#define DC3COMMAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#ifndef DC3MSGS_H_
#define DC3MSGS_H_
#include "DC3Msgs.h"
#endif

#include "DC3Errors.h"
#include "DC3Timeouts.h"
#include "dfuse.h"
#include "util.h"

/* Exported defines ----------------------------------------------------------*/
/**
 * @brief   Max buffer length for communications between client and DC3
 * This is the MAX length of msgs in bytes that can be sent over serial (base64
 * encoded) or UDP from the client. */
#define DC3_MAX_MSG_LEN 300

/**
 * @brief   Length of a datetime string
 * The format of this string is always:
 * YYYYMMDDhhmmss
 */
#define DC3_DATETIME_LEN 14

/**
 * @brief   Max size of a memory block that can be gotten from QMPool
 * This is the MAX length of memory in a block that can be gotten from QMPool. */
#define DC3_MAX_MEM_BLK_SIZE 256U

/* Exported macros -----------------------------------------------------------*/

/**
 * @brief   Macro to determine if an I2C device is defined in the system
 * @param [in] DEV:  DC3I2CDevice_t type I2C device specifier.
 * @retval
 *    1: Device exists and is valid
 *    0: Device doesn't exist or isn't defined
 */
#define IS_I2C_DEVICE( DEV )                                                  \
(                                                                             \
   (DEV) == _DC3_EEPROM ||                                                    \
   (DEV) == _DC3_SNROM ||                                                     \
   (DEV) == _DC3_EUIROM                                                       \
)

/**
 * @brief   Macro to determine if an I2C device is writable
 * @param [in] DEV:  DC3I2CDevice_t type I2C device specifier.
 * @retval
 *    1: Device writable
 *    0: Device is read only
 */
#define IS_I2C_DEVICE_RW( DEV )                                               \
(                                                                             \
   (DEV) == _DC3_EEPROM                                                       \
)

/* Exported types ------------------------------------------------------------*/
/**
 * \addtogroup autogenerated_enumerations
 * These typedefs allow the project to use the enums defined in the
 * autogenerated protobuf files.
 * @note: The actual enumerations are generated in the
 * DC3Msgs.h file.
 * @note: To edit the enumerations, edit the DC3Msgs.proto file.
 *
 * @{ */

/*! \enum DC3MsgName_t
 * All the different message names available in the DC3 API.
 */
typedef enum DC3MsgName_t        DC3MsgName_t;

/*! \enum DC3MsgType_t
 * All the different message types available in the DC3 API.
 */
typedef enum DC3MsgType_t        DC3MsgType_t;

/*! \enum DC3MsgRoute_t
 * All the different message routes (sources and destinations) available in the
 * DC3 API.
 */
typedef enum DC3MsgRoute_t       DC3MsgRoute_t;

/*! \enum DC3MsgType_t
 * All the different boot modes available in the DC3 API.  Also used to
 * describe FW image types.
 */
typedef enum DC3BootMode_t       DC3BootMode_t;

/*! \enum DC3I2CDevice_t
 * All the different I2C devices available on the DC3 board and exposed through
 * the DC3 API.
 */
typedef enum DC3I2CDevice_t      DC3I2CDevice_t;

/*! \enum DC3AccessType_t
 * All the different access types available on the DC3 board and exposed through
 * the DC3 API.
 * Some functions allow user to specify whether access is performed via event
 * driven (QP) or via direct access to HW using slow, blocking function calls.
 *
 * @note: Once the threads/Active Objects (AOs) have been started (end of main),
 * access should be limited to event driven interface.  In the event of a major
 * crash, and before all the threads/AOs have been started, access should be
 * the blocking kind.
 */
typedef enum DC3AccessType_t     DC3AccessType_t;

/*! \enum DC3RamTest_t
 * These are the various RAM memory tests that are available on the system.
 */
typedef enum DC3RamTest_t        DC3RamTest_t;

/*! \enum DC3DbgLevel_t
 * These are the various levels of debug that are available on the system.
 */
typedef enum DC3DbgLevel_t       DC3DbgLevel_t;


/*! \enum DC3DBElem_t
 * These are the various database elements used by the DC3 DB system that are
 * exposed through the DC3 API.
 */
typedef enum DC3DBElem_t         DC3DBElem_t;

/**@} end of autogenerated_enumerations group*/

/*! \enum DC3DbgModule_t
 * These are the various system modules for which debugging can be
 * enabled/disabled.
 *
 * These are limited to 32 bit and must be maskable.  These enum masks will be
 * used for both naming the various modules and for checking whether their
 * debug capabilities have been enabled.
 *
 * @note: these enums can't be autogenerated by the DC3_API since they have
 * values greater than 127 (yeah, it's a dumb limitation of the protobuf lib).
 * Note the lack _ in front of the enums.  This will indicate that they were
 * NOT AUTOGENERATED but are still part of the same API.
 */
typedef enum DBG_MODULES {
   DC3_DBG_MODL_GEN      = 0x00000001, /**< General module debugging (main, bsp, etc) */
   DC3_DBG_MODL_SER      = 0x00000002, /**< Serial module debugging. */
   DC3_DBG_MODL_TIME     = 0x00000004, /**< Time module debugging. */
   DC3_DBG_MODL_ETH      = 0x00000008, /**< Ethernet module debugging. */
   DC3_DBG_MODL_I2C      = 0x00000010, /**< I2C module debugging. */
   DC3_DBG_MODL_I2C_DEV  = 0x00000020, /**< I2C module debugging. */
   DC3_DBG_MODL_NOR      = 0x00000040, /**< NOR Flash module debugging. */
   DC3_DBG_MODL_SDRAM    = 0x00000080, /**< SDRAM module debugging. */
   DC3_DBG_MODL_DBG      = 0x00000100, /**< MENU module debugging. */
   DC3_DBG_MODL_COMM     = 0x00000200, /**< COMM module debugging. */
   DC3_DBG_MODL_CPLR     = 0x00000400, /**< Coupler module debugging. */
   DC3_DBG_MODL_DB       = 0x00000800, /**< Database module debugging. */
   DC3_DBG_MODL_FLASH    = 0x00001000, /**< Flash module debugging (only in bootloader) */
   DC3_DBG_MODL_SYS      = 0x00002000, /**< System module debugging */
} DC3DbgModule_t;


/*! \enum DC3DbgDeviceSetting_t
 * These are the devices which can have debugging output over them enabled/disabled.
 *
 * These are limited to 8 bit and must be maskable.  These enum masks will be
 * used for both naming the debug output devices and for checking whether their
 * debug capabilities have been enabled.
 *
 * @note: these enums can't be autogenerated by the DC3_API since they have
 * values greater than 127 (yeah, it's a dumb limitation of the protobuf lib).
 * Note the lack _ in front of the enums.  This will indicate that they were
 * NOT AUTOGENERATED but are still part of the same API.
 */
//typedef enum DBG_DEVICE_SETTINGS {
//   DC3_DBG_DEV_SER       = 0x01, /**< Debug output over serial is enabled */
//   DC3_DBG_DEV_ETH       = 0x02, /**< Debug output over ethernet is enabled */
//} DC3DbgDeviceSetting_t;
typedef enum DC3DbgDeviceSetting_t       DC3DbgDeviceSetting_t;
/**
 * @brief   A Union of all the payload structs.
 * This union allows for some fairly significant space savings in FW since only
 * one payload msg will ever be handled at a time, there's no reason to not
 * allow them to share the space.
 */
typedef union DC3PayloadMsgs {
   struct DC3StatusPayloadMsg    statusPayload;
   struct DC3VersionPayloadMsg   versionPayload;
   struct DC3BootModePayloadMsg  bootmodePayload;
   struct DC3FlashMetaPayloadMsg flashMetaPayload;
   struct DC3FlashDataPayloadMsg flashDataPayload;
   struct DC3I2CDataPayloadMsg   i2cDataPayload;
   struct DC3RamTestPayloadMsg   ramTestPayload;
   struct DC3DbgPayloadMsg       dbgPayload;
   struct DC3DBDataPayloadMsg    dbDataPayload;
} DC3PayloadMsgUnion_t;


/* Exported constants --------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/


#ifdef __cplusplus
}
#endif

#endif                                                       /* DC3COMMAPI_H_ */
/******** Copyright (C) 2013 Datacard. All rights reserved *****END OF FILE****/
