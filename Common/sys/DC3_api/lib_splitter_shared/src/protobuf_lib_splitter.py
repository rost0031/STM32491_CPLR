#!/usr/bin/env python 
# encoding: utf-8
'''
protobuf_lib_splitter -- This python script will split protobuf generated *.c 
and *.h files in order to prevent symbol collision when linking multiple 
different protobuf libraries.  It will also generate declarations for the 
private functions which currently don't exist in the default generation.  For
example, for a generated file pair test.c and test.h, this script will strip out
the core functions from test.c and test.h and create new files called 
protobuf_core.c and protobuf_core.h.  The C file (protobuf_core.c) will simply 
contain the core functions that the user generated ones that stay in test.c will
call.  The original header file doesn't contain definitions for them so this 
script will create them.  

@author:     Harry Rostovtsev
            
@copyright:  2013 Datacard Group. All rights reserved.
            
@license:    Proprietary

@contact:    harry_rostovtsev@datacard.com
'''

import sys
import os
import re

from optparse import OptionParser
import logging 

__all__ = []
__version__ = 0.1
__date__ = '2013-05-14'
__updated__ = '2013-05-14'

DEBUG = 0
TESTRUN = 0
PROFILE = 0
debug_level = logging.ERROR

core_header_text = '''/******************************************************************************* 
 * File generated by Protoc for Embedded C and split by protobuf_lib_splitter.py
 * This file contains only the core functionality of protobuf-c so that it can 
 * be compiled into a separate library to prevent symbol crashes between 
 * multiple different protobuf generated libraries.
 *                                                   
 * Copyright (c) 2009-2012
 * Technische Universitaet Muenchen
 * http://www4.in.tum.de/
 * Copyright (c) 2013
 * Datacard Group
 *                                                                                                                                  
 * Do not edit.                                                                
 ******************************************************************************/
'''
protocol_header_text = '''/******************************************************************************* 
 * File generated by Protoc for Embedded C and split by protobuf_lib_splitter.py
 * This file contains only the functionality of protobuf-c so that is specific
 * to the protocol.  It can  be compiled into a separate library from the core 
 * to prevent symbol crashes between multiple different protobuf generated 
 * libraries.
 *                                                   
 * Copyright (c) 2009-2012
 * Technische Universitaet Muenchen
 * http://www4.in.tum.de/
 * Copyright (c) 2013
 * Datacard Group
 *                                                                                                                                  
 * Do not edit.                                                                
 ******************************************************************************/
'''

def main():
    '''Command line options.'''
    
    logging.basicConfig(stream=sys.stderr, 
                        level=debug_level, 
                        format=('%(filename)s: '    
                                '%(levelname)s: '
                                '%(funcName)s(): '
                                '%(lineno)d:\t'
                                '%(message)s'))
    logging.debug('A debug message!')
    
    program_name = os.path.basename(sys.argv[0])
    program_version = __version__
    program_build_date = "%s" % __updated__
 
    program_version_string = '%%prog %s (%s)' % (program_version, program_build_date)
    program_longdesc = '''''' # optional - give further explanation about what the program does
    program_license = "Copyright 2013 Harry Rostovtsev (Datacard Group)"
    
    try:
        # setup option parser
        parser = OptionParser(version=program_version_string, epilog=program_longdesc, description=program_license, usage="Usage: %prog -i input.c or %prog --in=../somefile.c")
        parser.add_option("-i", "--in", dest="infile", action="store", help="set input filename", metavar="FILE")
        parser.add_option("-v", "--verbose", dest="verbose", action="count", help="set verbosity level [default: %default]")
        
        # process options
        ( opts, args ) = parser.parse_args( sys.argv )

        if opts.verbose > 0:
            logging.debug("verbosity level = %d" % opts.verbose)
        
        if opts.infile:
            logging.debug("infile = %s" % opts.infile)
        else:
            logging.error("No input file specified")
            exit(1)
               
        if ( opts.infile.endswith('.c') ):
            in_c_filename = opts.infile
            in_h_filename = os.path.splitext(opts.infile)[0] + ".h"
            logging.debug( "Input file %s is a *.c file.  Using %s as an *.h file" % (in_c_filename, in_h_filename) )
        elif ( opts.infile.endswith('.h') ):
            in_h_filename = opts.infile
            in_c_filename = os.path.splitext(opts.infile)[0] + ".c"
            logging.debug( "Input file %s is a *.h file.  Using %s as an *.c file" % (in_h_filename, in_c_filename) )
        else:
            logging.error( "Invalid file extension specified for input file %s" %opts.infile)
            exit(1)
            
         
        # MAIN BODY #
        
        ''' Open and read the original C file '''
        try:
            with open(in_c_filename) as f_orig_c: 
                orig_c_content = f_orig_c.readlines()
        except IOError, e:
            logging.error(e.errno)
            logging.error(e)
            logging.error("Unable to open file %s" % in_c_filename)
            exit(1)
        finally:
            f_orig_c.close()
            
        logging.debug("Successfully opened and read %s" % in_c_filename)
        
        ''' Open and read the original H file '''
        try:
            with open(in_h_filename) as f_orig_h_file:
                orig_h_content = f_orig_h_file.readlines()
        except IOError, e:
            logging.error(e.errno)
            logging.error(e)
            logging.error("Unable to open file %s" % in_h_filename)
            exit(1)
        finally:
            f_orig_h_file.close()
         
        logging.debug("Successfully opened and read %s" % in_h_filename)
        
        
        ''' output c and h files '''
        ( path, filename ) = os.path.split(in_c_filename)
        
        out_c_protoc_filename = path + "/" + filename
        logging.debug("Output c core file %s" % out_c_protoc_filename)
        
        out_c_core_filename = path + "/protobuf_core.c"
        logging.debug("Output c core file %s" % out_c_core_filename)
        
        out_h_protoc_filename = path + "/" + filename
        out_h_protoc_filename = os.path.splitext(out_h_protoc_filename)[0] + ".h"
        logging.debug("Output c core file %s" % out_h_protoc_filename)
        
        out_h_core_filename = path + "/protobuf_core.h"
        logging.debug("Output c core file %s" % out_h_core_filename)
        
        ''' These are the buffers that will hold lines to be written to files '''
        lines_to_write_to_c_proto = []
        lines_to_write_to_h_proto = []
        lines_to_write_to_c_core = []
        lines_to_write_to_h_core = []
        function_declarations_to_h_core = []
        ''' Flag so we know where in the file we are '''
        c_content_loc = "beginning"
        
        try:
            ''' Open c and h files for writing, overwriting old contents '''
            f_protoc_c_file = open(out_c_protoc_filename, "w")
            f_core_c_file   = open(out_c_core_filename, "w")
            
            ''' Write the protocol specific headers '''
            f_protoc_c_file.write(protocol_header_text)
            logging.debug("Wrote protocol c headers")
            
            ''' Write the core headers '''
            f_core_c_file.write(core_header_text)
            logging.debug("Wrote core c headers")
            
            for line in orig_c_content:
                if c_content_loc == "beginning":
                    if line.startswith("/***"):
                        ''' This is the beginning of the file and we are in the
                        text header.  This needs to go to both'''
                        c_content_loc = "header_comment"
                        lines_to_write_to_c_proto.append(line)
                        lines_to_write_to_c_core.append(line)
                        continue
                    
                elif c_content_loc == "header_comment":
                    if line.startswith(" *"):
                        ''' Still in the header comment. '''
                        lines_to_write_to_c_proto.append(line)
                        lines_to_write_to_c_core.append(line)
                        continue
                    
                    elif line.startswith("#include"):
                        '''This line only goes to the protoc file'''
                        lines_to_write_to_c_proto.append(line)
                        ''' Add the new include to protobuf_core.h to both files'''
                        lines_to_write_to_c_proto.append('#include "protobuf_core.h"\n')
                        lines_to_write_to_c_core.append('#include "protobuf_core.h"\n')
                        ''' Should be entering the General functions section'''
                        c_content_loc = "general_functions_comment"
                        continue
                    
                    else:
                        ''' As long as we are in this section everything goes to
                        both files '''
                        lines_to_write_to_c_proto.append(line)
                        lines_to_write_to_c_core.append(line)
                        continue
                    
                elif c_content_loc == "general_functions_comment":
                    if line.startswith("/***"):
                        ''' This is the beginning of the "General functions" 
                        comment.  Everything from here to the next comment goes
                        to the core file only'''
                        lines_to_write_to_c_core.append(line)                        
                        continue
                    elif line.startswith(" * General"):
                        ''' Still in the General functions comment '''
                        lines_to_write_to_c_core.append(line) 
                        continue
                    elif line.startswith(" ****"):
                        ''' End of the "General functions" comment '''
                        lines_to_write_to_c_core.append(line)
                        c_content_loc = "general_functions" 
                        continue
                    
                elif c_content_loc == "general_functions":
                    if line.startswith("/*****"):
                        ''' This is the beginning of an "Enum" comment which 
                        means we have reached the end of the general functions'''
                        lines_to_write_to_c_proto.append(line)
                        c_content_loc = "protocol_functions"
                        continue
                    else:
                        ''' Check if this is the beginning of a function so we
                        can form a function declaration to put into the h core 
                        file''' 
                        if (line.startswith("int") or 
                            line.startswith("signed") or
                            line.startswith("void") or
                            line.startswith("unsigned") ):
                            if not "Message_" in line:
                                ''' Declarations for Message_ functions already
                                live in the header file.  We don't need them from
                                here '''
                                func_decl_line = line
                                ''' Make sure to strip off the right most " {" and 
                                replace it with ";" '''
                                func_decl_line = re.sub(r"\ \{",";", func_decl_line)
                                function_declarations_to_h_core.append(func_decl_line)
                                logging.debug("Added line %s to func decl" % func_decl_line)
                            
                        ''' Throw everything in the core section ''' 
                        lines_to_write_to_c_core.append(line)
                        continue
                    
                elif c_content_loc == "protocol_functions":
                    ''' Throw everything in the protocol section ''' 
                    lines_to_write_to_c_proto.append(line)
                    continue
                
                else:
                    pass
                    logging.error("Unknown section for line %s\n" % line)
            ''' End of the for loop '''
            
            ''' Write the protocol specific file '''
            for line in lines_to_write_to_c_proto:
                f_protoc_c_file.write(line)
            logging.debug("Wrote protocol c file")
            
            ''' Write the core file '''
            for line in lines_to_write_to_c_core:
                f_core_c_file.write(line)
            logging.debug("Wrote core c file")
            
            
            
            ''' Now let's to do the header files '''
            
            ''' Open h files for writing, overwriting old contents '''
            f_protoc_h_file = open(out_h_protoc_filename, "w")
            f_core_h_file   = open(out_h_core_filename, "w")
            
            ''' Write the protocol specific headers '''
            f_protoc_h_file.write(protocol_header_text)
            logging.debug("Wrote protocol h headers")
            
            ''' Write the core headers '''
            f_core_h_file.write(core_header_text)
            logging.debug("Wrote core h headers")
            
            ''' Flag so we know where in the file we are '''
            h_content_loc = "beginning"
            
            for line in orig_h_content:
                if h_content_loc == "beginning":
                    if line.startswith("/***"):
                        ''' This is the beginning of the file and we are in the
                        text header.  This needs to go to both'''
                        h_content_loc = "header_comment"
                        lines_to_write_to_h_proto.append(line)
                        lines_to_write_to_h_core.append(line)
                        continue
                    
                elif h_content_loc == "header_comment":
                    if line.startswith(" *"):
                        ''' Still in the header comment. '''
                        lines_to_write_to_h_proto.append(line)
                        lines_to_write_to_h_core.append(line)
                        continue
                    
                    elif line.startswith("#define"):
                        '''This line only goes to the protoc file'''
                        lines_to_write_to_h_proto.append(line)
                        ''' Should be entering the General functions section'''
                        h_content_loc = "defines_section"
                        continue
                    
                    else:
                        ''' As long as we are in this section everything goes to
                        both files '''
                        lines_to_write_to_h_proto.append(line)
                        lines_to_write_to_h_core.append(line)
                        continue
                elif h_content_loc == "defines_section":
                    if line.startswith("#define"):
                        '''This line only goes to the protoc file'''
                        lines_to_write_to_h_proto.append(line)
                        ''' Should be entering the General functions section'''
                        h_content_loc = "defines_section"
                        continue
                    else:
                        ''' Reached the end of the defines.  Next is "General
                        functions comment '''
                        lines_to_write_to_h_proto.append(line)
                        h_content_loc = "general_functions_comment"
                        continue
                    
                elif h_content_loc == "general_functions_comment":
                    if line.startswith("/***"):
                        ''' This is the beginning of the "General functions" 
                        comment.  Everything from here to the next comment goes
                        to the core file only'''
                        lines_to_write_to_h_core.append(line)                        
                        continue
                    elif line.startswith(" * General"):
                        ''' Still in the General functions comment '''
                        lines_to_write_to_h_core.append(line) 
                        continue
                    elif line.startswith(" ****"):
                        ''' End of the "General functions" comment '''
                        lines_to_write_to_h_core.append(line)
                        
                        ''' Append the core function declarations we created
                        when parsing the original c file '''
                        lines_to_write_to_h_core.append("\n")
                        lines_to_write_to_h_core = lines_to_write_to_h_core + function_declarations_to_h_core 
                        h_content_loc = "general_functions" 
                        continue
                    
                elif h_content_loc == "general_functions":
                    if line.startswith("/*****"):
                        ''' This is the beginning of an "Enum" comment which 
                        means we have reached the end of the general functions'''
                        lines_to_write_to_h_proto.append(line)
                        h_content_loc = "protocol_functions"
                        continue
                    else:
                        ''' Throw everything in the core section ''' 
                        lines_to_write_to_h_core.append(line)
                        continue
                    
                elif h_content_loc == "protocol_functions":
                    ''' Throw everything in the protocol section ''' 
                    lines_to_write_to_h_proto.append(line)
                    continue
                
                else:
                    pass
                    logging.error("Unknown section for line %s\n" % line)
                    
            
            ''' End of the for loop '''
            
            ''' Write the protocol specific file '''
            for line in lines_to_write_to_h_proto:
                f_protoc_h_file.write(line)
            logging.debug("Wrote protocol h file")
            
            ''' Write the core file '''
            for line in lines_to_write_to_h_core:
                f_core_h_file.write(line)
            logging.debug("Wrote core h file")
            
        except IOError, e:
            logging.error("IOError during file operations")
            logging.error(e.errno)
            logging.error(e)
            exit(1)
            
        print("Successfully split core functions from %s into %s and %s" % (in_c_filename, out_c_protoc_filename, out_c_core_filename) )
        print("Successfully split core functions from %s into %s and %s" % (in_h_filename, out_h_protoc_filename, out_h_core_filename) )
        
    except Exception, e:
        print("Caught exception")
        indent = len(program_name) * " "
        sys.stderr.write(program_name + ": " + repr(e) + "\n")
        sys.stderr.write(indent + "  for help use --help")
        return 2


if __name__ == "__main__":
    if DEBUG:
        debug_level = logging.DEBUG
    if TESTRUN:
        import doctest
        doctest.testmod()
    if PROFILE:
        import cProfile
        import pstats
        profile_filename = 'protobuf_lib_splitter_profile.txt'
        cProfile.run('main()', profile_filename)
        statsfile = open("profile_stats.txt", "wb")
        p = pstats.Stats(profile_filename, stream=statsfile)
        stats = p.strip_dirs().sort_stats('cumulative')
        stats.print_stats()
        statsfile.close()
        sys.exit(0)
    sys.exit(main())