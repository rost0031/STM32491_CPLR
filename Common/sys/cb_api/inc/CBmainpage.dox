/**
	\mainpage RFID Board API Documentation

This library contains (almost) all the necessary functionality to access the
RFID Board via its serial (SYSTEM) interface from ARM Cortex M3, PowerPC, or
IA32/64 architectures.

There are 2 modes that the RFID Board operates in:

SYSTEM_BOOT mode and FLASH_BOOT mode.

SYSTEM_BOOT mode is used to upgrade the FW on the RFID board via the USART and
it is accessed by holding the BOOT0 line high and toggling the Reset line.  See
STM32 AN2606 document for more details on this.  AN3155 Describes the protocol
used to transfer data over the USART in order to upgrade the FW.

FLASH_BOOT mode is the mode used most often and it is the mode used to do basic
RFID read/write commands and other non fw upgrade tasks.  The FLASH_BOOT mode
is accessed by simply letting the system boot naturally without touching the
BOOT0 line.

Communication to/from the RFID board is done via auto generated messages.  This
allows for much easier generation of messages and allows them to be compiler,
endian, and architecture independent.

All messages have to be base64 encoded before being sent to the RFID board and
any return messages have to be base64 decoded.  This is due to newlines ("\n")
being a message termination character, allowing RFID board not to have to know
the length of each message in advance.  Since newline is a special character,
using base64 encoding ensure that no newlines will accidentally appear as part
of the message.

If your project is not already using base64 encoding, make sure that libb64 is
part of your project and is being compiled.  This board code used a slightly
modified libb64 library (found at http://libb64.sourceforge.net/) which can be
found on Datacard's internal repository server.

For examples of how to use this library, see the Redwood Laminator (Bootloader
and Application) code.

How messages are generated:

In the proto folder, there is a proto file that is used to define binary msgs
and automatically generating C code to be used by either intel, arm, and powerpc
processors.  See http://code.google.com/p/protobuf-embedded-c/
for detail of how this is done.

See https://developers.google.com/protocol-buffers/docs/proto#simple for
how to specify messages in the proto language of Protocol Buffers but keep
in mind that the "Protobuf-Embedded-C" is more limited than the Google version.

Rules for messages:
1). RFIDDescMsg - All messages must be sent with a prepended RFIDDescMsg message.
This is done in order to identify which message is actually being sent.  The
reason for this is a limitation of this messaging protocol: it unfortunately
offers no way to identify the messages before parsing them.  Prepending the
RFIDDescMsg to the beginning guarantees that the receiver can always figure
out what message is being sent and guarantees that it will be parsable by
allowing the receiver to know exactly which structure is serialized into that
message.

2). RFIDAckMsg Message - This is a general Acknowledgement message, sent as a
reply to any Req msg as soon as a Req is received and processed.  This is
optional in some cases and the handling is up to the user.  For critical
applications (such as the RFID board itself), this should be the norm.  This
Ack msg will always be sent after receiving a Req msg and attempting to
decrypt/decompress/parse the entire message.

3). General Message Types:
Synchronous - These messages exist as groups of messages:
 A. Req  - Request, specifies a request for something
 B. Resp - Response, can by one of the following subtypes:
     i. Prog - Progress, sent after the Ack but before Done. These can specify
               completion of steps in a multistep request.  For example, if a
               client requests a kick off of a test that sends the motor through
               acceleration, deceleration, and finally a stop, Prog msgs can be
               sent after the completion of each of these steps.  These msgs are
               optional and are application specific. Their msgId should
               match the msgId of the Req msg they are associated with.
     ii. Done - Done, sent as a reply to Req msg after the Ack msg and should be
               sent only as soon as a request has completed.  These are required.
Asynchronous - These messages are free form and application specific.  It's
              up to the user (on both sides) to decide when and if these should
              be sent.  An example of this message would be a regular heart
              beat or a status sent without being requested by the client.


4). All RFIDDescMsg must have a msg ID as part of the message.

5). Message naming convention - Message names should follow the following format:
RFIDSensorStatusReqMsg
[ 0][-----1----][2][3]
where
field 0: This should always be "RFID".  It acts as a namespace and prevents
         the possibility that another project is using this name for its msgs.
field 1: Who/what is being referenced
field 2: Should be "Req" or "Resp", depending if the message is a
            request or a response.
field 3: Should always be "Msg".  This is primarily to differentiate them in
         the code from other similarly named things like events and the
         structures used to extract the info from the messages.

Example msg exchange:

Client                                               RFID Board
  |
*Send* [[RFIDDescMsg][RFIDCommTestReqMsg]] >>>>>>>>>>>>*Receive*
                                                         |
*Receive* [[RFIDDescMsg][RFIDAckMsg]] <<<<<<<<<<<<<<<<<*Send*
                                                         |
                                                       *Process*
                                                         |
*Receive* [[RFIDDescMsg][RFIDCommTestRespMsg]] <<<<<<<<*Send*


@author: Harry Rostovtsev
@email : harry_rostovtsev@datacard.com

*/
