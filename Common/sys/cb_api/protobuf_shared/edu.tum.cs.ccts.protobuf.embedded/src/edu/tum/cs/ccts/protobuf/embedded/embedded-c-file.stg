/*--------------------------------------------------------------------------+
|                                                                          |
| Copyright 2008-2012 Technische Universitaet Muenchen                     |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+--------------------------------------------------------------------------*/

group embedded-cfile;

/* Type definitions from Proto.g
 * TYPE
 *  : 'double' | 'float' | 'int32' | 'int64' | 'uint32' | 'uint64' | 'sint32' | 'sint64'
 *  | 'fixed32' | 'fixed64' | 'sfixed32' | 'sfixed64' | 'bool' | 'string' | 'bytes'
 *  ;
 */

typeMap ::= [
  "double":"double",
  "float":"float",
  "int32":"signed long",
  "int64":"signed long long",
  "uint32":"unsigned long",
  "uint64":"unsigned long long",
  "sint32":"signed long",
  "sint64":"signed long long",
  "fixed32":"unsigned long",
  "fixed64":"unsigned long long",
  "sfixed32":"signed long",
  "sfixed64":"signed long long",
  "bool":"char",
  "string":"char",
  "bytes":"char"]
 
wireTypeMap ::= ["int32":"0", "int64":"0", "sint32":"0", "sint64":"0", "uint32":"0",
                     "uint64":"0", "string":"2", "bool":"0", "float":"5", "double":"1",
                        "fixed32":"5", "fixed64":"1", "sfixed32":"5", "sfixed64":"1", "bytes":"2"]

int32Map ::= ["int32":"true"] 
int64Map ::= ["int64":"true"]
sint32Map ::= ["sint32":"true"] 
sint64Map ::= ["sint64":"true"] 
uint32Map ::= ["uint32":"true"] 
uint64Map ::= ["uint64":"true"] 
fixed32Map ::= ["fixed32":"true"] 
fixed64Map ::= ["fixed64":"true"] 
sfixed32Map ::= ["sfixed32":"true"] 
sfixed64Map ::= ["sfixed64":"true"] 
stringMap ::= ["string":"true"] 
boolMap ::= ["bool":"true"]
bytesMap ::= ["bytes":"true"]
floatMap ::= ["float":"true"]
doubleMap ::= ["double":"true"]
enumMap ::= ["enum":"true"]
messageMap ::= ["message":"true"]

arrayTypes ::= ["string":"true", "bytes":"true"]
fixedSizeMap ::= ["double":"8", "float":"4", "fixed64":"8", "fixed32":"4", "sfixed64":"8", "sfixed32":"4", "bool":"1"]
arrayModifiers ::= ["repeated":"true"]

proto(packageDecl, importDecls, declarations, filename, max_repeated_length, max_string_length, max_bytes_length) ::= <<
/******************************************************************* 
 * C-file generated by Protoc for Embedded C.                      *
 * Version 0.2 (2012-01-31)                                        *
 *                                                                 *
 * Copyright (c) 2009-2012                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : $filename$.proto
 * Package: $packageDecl$
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#include "$filename$.h"
$importDecls; separator="\n"$

/*******************************************************************
 * General functions
 *******************************************************************/
 
void _memset(void *msg_ptr, char init_val, unsigned int size) {
    int i;
    for(i = 0; i < size; ++ i)
        *((char*)msg_ptr + i) = init_val;
}

int varint_packed_size(unsigned long value) {
    if ((value & (0xffffffff <<  7)) == 0) return 1;
    if ((value & (0xffffffff << 14)) == 0) return 2;
    if ((value & (0xffffffff << 21)) == 0) return 3;
    if ((value & (0xffffffff << 28)) == 0) return 4;
    return 5;  
}

int write_raw_byte(char value, void *_buffer, int offset) {
    *((char *)_buffer + offset) = value;
    return ++offset;
}

/** Write a little-endian 32-bit integer. */
int write_raw_little_endian32(unsigned long value, void *_buffer, int offset) {
    offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\>  8) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 16) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 24) & 0xFF), _buffer, offset);
    
    return offset;
}

/** Write a little-endian 64-bit integer. */
int write_raw_little_endian64(unsigned long long value, void *_buffer, int offset) {
    offset = write_raw_byte((char)((value      ) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\>  8) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 16) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 24) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 32) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 40) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 48) & 0xFF), _buffer, offset);
    offset = write_raw_byte((char)((value \>\> 56) & 0xFF), _buffer, offset);
    
    return offset;
}

int write_raw_varint32(unsigned long value, void *_buffer, int offset) {
    while (1) {
        if ((value & ~0x7F) == 0) {
            offset = write_raw_byte((char)value, _buffer, offset);
            return offset;
        } else {
            offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
            value = value \>\> 7;
        }
    }
    return offset;
}

int write_raw_varint64(unsigned long long value, void *_buffer, int offset) {
    while (1) {
        if ((value & ~0x7FL) == 0) {
            offset = write_raw_byte((char)value, _buffer, offset);
            return offset;
        } else {
            offset = write_raw_byte((char)((value & 0x7F) | 0x80), _buffer, offset);
            value = value \>\> 7;
        }
    }
    return offset;
}

int write_raw_bytes(char *bytes, int bytes_size, void *_buffer, int offset) {
    int i; 
    for(i = 0; i < bytes_size; ++ i) {
        offset = write_raw_byte((char)*(bytes + i), _buffer, offset);
    }
    
    return offset;   
}

unsigned long encode_zig_zag32(signed long n) {
    // Note:  the right-shift must be arithmetic
    return (n << 1) ^ (n \>\> 31);
}

unsigned long long encode_zig_zag64(signed long long n) {
    // Note:  the right-shift must be arithmetic
    return (n << 1) ^ (n \>\> 63);
} 

signed long decode_zig_zag32(unsigned long n) {
    return (n \>\> 1) ^ -(n & 1);
}

signed long long decode_zig_zag64(unsigned long long n) {
    return (n \>\> 1) ^ -(n & 1);
}

int read_raw_byte(char *tag, void *_buffer, int offset) {
    *tag = *((char *) _buffer + offset);
    
    return ++offset;
}

/** Read a 32-bit little-endian integer from the stream. */
int read_raw_little_endian32(unsigned long *tag, void *_buffer, int offset) {
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b1 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b2 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b3 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b4 = (char) *tag;
    
    *tag = (((unsigned long)b1 & 0xff)      ) |
           (((unsigned long)b2 & 0xff) <<  8) |
           (((unsigned long)b3 & 0xff) << 16) |
           (((unsigned long)b4 & 0xff) << 24);
           
    return offset;
}

/** Read a 64-bit little-endian integer from the stream. */
int read_raw_little_endian64(unsigned long long *tag, void *_buffer, int offset) {
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b1 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b2 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b3 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b4 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b5 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b6 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b7 = (char) *tag;
    offset = read_raw_byte((char *)tag, _buffer, offset);
    char b8 = (char) *tag;
    
    *tag = (((unsigned long long)b1 & 0xff)      ) |
           (((unsigned long long)b2 & 0xff) <<  8) |
           (((unsigned long long)b3 & 0xff) << 16) |
           (((unsigned long long)b4 & 0xff) << 24) |
           (((unsigned long long)b5 & 0xff) << 32) |
           (((unsigned long long)b6 & 0xff) << 40) |
           (((unsigned long long)b7 & 0xff) << 48) |
           (((unsigned long long)b8 & 0xff) << 56);
           
    return offset;
}

int read_raw_varint32(unsigned long *tag, void *_buffer, int offset) {
    signed char result;
    
    offset = read_raw_byte((char *)&result, _buffer, offset);
    if (result >= 0) {
        *tag = result;
        return offset;
    }
    *tag = result & 0x7f;
    offset = read_raw_byte((char *)&result, _buffer, offset);
    if (result >= 0) {
        *tag |= result << 7;
    } else {
        *tag |= (result & 0x7f) << 7;
        offset = read_raw_byte((char *)&result, _buffer, offset);
        if (result >= 0) {
            *tag |= result << 14;
        } else {
            *tag |= (result & 0x7f) << 14;
            offset = read_raw_byte((char *)&result, _buffer, offset);
            if (result >= 0) {
                *tag |= ((unsigned long)result) << 21;
            } else {
                *tag |= (((unsigned long)result) & 0x7f) << 21;
                offset = read_raw_byte((char *)&result, _buffer, offset);
                *tag |= ((unsigned long)result) << 28;
                if (result < 0) {
                    // Discard upper 32 bits.
                    int i;
                    for (i = 0; i < 5; ++ i) {
                        offset = read_raw_byte((char *)&result, _buffer, offset);
                        if (result >= 0) {
                            return offset;
                        }
                    }
                    //invalid state
                }
            }
        }
    }
    return offset;
}

int read_raw_varint64(unsigned long long *tag, void *_buffer, int offset) {
    short shift = 0;
    signed char b;
    *tag = 0;
    while (shift < 64) {
        offset = read_raw_byte((char *)&b, _buffer, offset);
        *tag |= (unsigned long long)(b & 0x7F) << shift;
        if ((b & 0x80) == 0) {
            return offset;
        }
        shift += 7;
    }
    //return error code.
    return -1;
}

int can_read_raw_varint32(void *_buffer, int offset, int length) {
    signed char c;
    
    // Bound length to valid range [0..5].
    if (length < 0) length = 0; else
    if (length > 5) length = 5;
    
    while (length > 0) {
        offset = read_raw_byte((char *)&c, _buffer, offset);
        if (c >= 0) {
            return 1; // Can read (1 == true).
        }
        length--;
    }
    
    return 0; // Cannot read (0 == false).
}

int can_read_raw_varint64(void *_buffer, int offset, int length) {
    signed char c;
    
    // Bound length to valid range [0..5].
    if (length < 0) length = 0; else
    if (length > 10) length = 10;
    
    while (length > 0) {
        offset = read_raw_byte((char *)&c, _buffer, offset);
        if (c >= 0) {
            return 1; // Can read (1 == true).
        }
        length--;
    }
    
    return 0; // Cannot read (0 == false).
}

int Message_can_read_delimited_from(void *_buffer, int offset, int length) {
    unsigned long size;
    int payload_offset;

    if (length <= 0) return 0; // Cannot read from empty or invalid message.

    if (!can_read_raw_varint32(_buffer, offset, length)) {
        return 0; // Could not even read the preceding size as varint32.
    }

    payload_offset = read_raw_varint32(&size, _buffer, offset);
    length = length - (payload_offset - offset);

    return (length >= size) ? 1 : 0;
}

unsigned long Message_get_delimited_size(void *_buffer, int offset) {
    unsigned long size = 0;
    int old_offset = offset;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    
    return size + offset - old_offset;
}


$declarations; separator="\n\n"$
>>

packageDecl(qualifiedID) ::= <<$qualifiedID$>>

importDecl(name) ::= <<
#include <$name$.h>
>>

enumDecl(name, elements, filename, line) ::= <<
/*******************************************************************
 * Enum: $filename$.proto, line $line$
 *******************************************************************/
int $name$_write_with_tag(enum $name$ *_$name$, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_$name$, _buffer, offset);
    
    return offset;
}
>>

enumElement(name, value) ::= <<>>

messageDecl(name, elements, filename, line, maxsize, empty, bigvalues) ::= <<
/*******************************************************************
 * Message: $filename$.proto, line $line$
 *******************************************************************/
int $name$_write($if(empty)$$else$struct $name$ *_$name$, $endif$void *_buffer, int offset) {
    /* Write content of each message element.*/
    $elements:messageElementWriteTo(element=it);separator="\n"$
    
    return offset;
}

int $name$_write_with_tag($if(empty)$$else$struct $name$ *_$name$, $endif$void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = $name$_write_delimited_to($if(empty)$$else$_$name$, $endif$_buffer, offset);
    
    return offset;
}

int $name$_write_delimited_to($if(empty)$$else$struct $name$ *_$name$, $endif$void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = $name$_write($if(empty)$$else$_$name$, $endif$_buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

$if(empty)$$else$void $name$_clear(struct $name$ *_$name$) {
    _memset(_$name$, 0, sizeof(struct $name$));
}$endif$

int $name$_read(void *_buffer, $if(empty)$$else$struct $name$ *_$name$, $endif$int offset, int limit) {
    int i = 0;
    unsigned long tag = i;
    $if(bigvalues)$    unsigned long long value = i;$endif$

    $if(empty)$$else$    /* Reset all attributes to 0 in advance. */
    $name$_clear(_$name$);$endif$

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        $readTag()$
        switch(tag){
            $elements:caseElementTag(element=it);separator="\n"$
        }
    }
    
    return offset;
}

int $name$_read_delimited_from(void *_buffer, $if(empty)$$else$struct $name$ *_$name$, $endif$int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    $name$_read(_buffer, $if(empty)$$else$_$name$, $endif$offset, size + offset);
    
    return offset + size;
}

>>

caseElementTag(element) ::= <<
//tag of: _$name$._$element.name$ 
case $element.tag$ :
    $readInt32(element)$
    $readInt64(element)$
    $readSInt32(element)$
    $readSInt64(element)$
    $readUInt32(element)$
    $readUInt64(element)$
    $readFixed32(element)$
    $readFixed64(element)$
    $readSFixed32(element)$
    $readSFixed64(element)$
    $readFloat(element)$
    $readDouble(element)$
    $readBool(element)$
    $readEnum(element)$
    $readString(element)$
    $readBytes(element)$
    $readMessage(element)$
    break;
>>

readInt64(element) ::= <<
$if(int64Map.(element.typeName))$
offset = read_raw_varint64(&value, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = (signed long long)value;
$else$
_$name$->_$element.name$ = (signed long long)value;
$endif$
$endif$
>>

readString(element) ::= <<
$if(stringMap.(element.typeName))$
 /* Re-use 'tag' to store string length. */
offset = read_raw_varint32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
/* Set length of current string. */
_$name$->_$element.name$_len[(int)_$name$->_$element.name$_repeated_len] = tag;
/* Copy raw bytes of current string. */
for(i = 0; i < tag; ++ i) {
    offset = read_raw_byte(&_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len][i], _buffer, offset);
}
/* Advance to next string. */
_$name$->_$element.name$_repeated_len++;    
$else$
_$name$->_$element.name$_len = tag;
for(i = 0; i < tag; ++ i) 
    offset = read_raw_byte((_$name$->_$element.name$ + i), _buffer, offset);
$endif$
$endif$
>>

readBytes(element) ::= <<
$if(bytesMap.(element.typeName))$
 /* Re-use 'tag' to store string length. */
offset = read_raw_varint32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
/* Set length of current string. */
_$name$->_$element.name$_len[(int)_$name$->_$element.name$_repeated_len] = tag;
/* Copy raw bytes of current string. */
for(i = 0; i < tag; ++ i) {
    offset = read_raw_byte(&_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len][i], _buffer, offset);
}
/* Advance to next string. */
_$name$->_$element.name$_repeated_len++;    
$else$
_$name$->_$element.name$_len = tag;
for(i = 0; i < tag; ++ i) 
    offset = read_raw_byte((_$name$->_$element.name$ + i), _buffer, offset);
$endif$
$endif$
>>

readEnum(element) ::= <<
$if(enumMap.(element.typeClass))$
offset = read_raw_varint32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = tag;
$else$
_$name$->_$element.name$ = tag;
$endif$
$endif$
>>

readMessage(element) ::= <<
$if(!enumMap.(element.typeClass))$$if(!typeMap.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
offset = $element.typeName$_read_delimited_from(_buffer, &_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++], offset);
$else$
offset = $element.typeName$_read_delimited_from(_buffer, &_$name$->_$element.name$, offset);
$endif$
$endif$
$endif$
>>

readBool(element) ::= <<
$if(boolMap.(element.typeName))$
offset = read_raw_varint32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = tag & 1;
$else$
_$name$->_$element.name$ = tag & 1;
$endif$
$endif$
>>

readFloat(element) ::= <<
$if(floatMap.(element.typeName))$
offset = read_raw_little_endian32(&tag, _buffer, offset);
float *$element.name$ = (float *)(&tag);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = *$element.name$;
$else$
_$name$->_$element.name$ = *$element.name$;
$endif$
$endif$
>>

readDouble(element) ::= <<
$if(doubleMap.(element.typeName))$
offset = read_raw_little_endian64(&value, _buffer, offset);
double *$element.name$ = (double *)(&value);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = *$element.name$;
$else$
_$name$->_$element.name$ = *$element.name$;
$endif$
$endif$
>>

readInt32(element) ::= <<
$if(int32Map.(element.typeName))$
offset = read_raw_varint32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = (signed long)tag;
$else$
_$name$->_$element.name$ = (signed long)tag;
$endif$
$endif$
>>

readSInt32(element) ::= <<
$if(sint32Map.(element.typeName))$
offset = read_raw_varint32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = decode_zig_zag32(tag);
$else$
_$name$->_$element.name$ = decode_zig_zag32(tag);
$endif$
$endif$
>>

readSInt64(element) ::= <<
$if(sint64Map.(element.typeName))$
offset = read_raw_varint64(&value, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = decode_zig_zag64(value);
$else$
_$name$->_$element.name$ = decode_zig_zag64(value);
$endif$
$endif$
>>

readUInt32(element) ::= <<
$if(uint32Map.(element.typeName))$
offset = read_raw_varint32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = tag;
$else$
_$name$->_$element.name$ = tag;
$endif$
$endif$
>>

readUInt64(element) ::= <<
$if(uint64Map.(element.typeName))$
offset = read_raw_varint64(&value, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = value;
$else$
_$name$->_$element.name$ = value;
$endif$
$endif$
>>

readFixed32(element) ::= <<
$if(fixed32Map.(element.typeName))$
offset = read_raw_little_endian32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = tag;
$else$
_$name$->_$element.name$ = tag;
$endif$
$endif$
>>

readFixed64(element) ::= <<
$if(fixed64Map.(element.typeName))$
offset = read_raw_little_endian64(&value, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = value;
$else$
_$name$->_$element.name$ = value;
$endif$
$endif$
>>

readSFixed32(element) ::= <<
$if(sfixed32Map.(element.typeName))$
offset = read_raw_little_endian32(&tag, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = (signed long)tag;
$else$
_$name$->_$element.name$ = (signed long)tag;
$endif$
$endif$
>>

readSFixed64(element) ::= <<
$if(sfixed64Map.(element.typeName))$
offset = read_raw_little_endian64(&value, _buffer, offset);
$if(arrayModifiers.(element.modifier))$
_$name$->_$element.name$[(int)_$name$->_$element.name$_repeated_len++] = (signed long long)value;
$else$
_$name$->_$element.name$ = (signed long long)value;
$endif$
$endif$
>>

readTag() ::= <<
offset = read_raw_varint32(&tag, _buffer, offset);
tag = tag\>\>3;
>>

messageElementWriteTo(element) ::= <<
$writeInt32(element)$
$writeInt64(element)$
$writeSInt32(element)$
$writeSInt64(element)$
$writeUInt32(element)$
$writeUInt64(element)$
$writeFixed32(element)$
$writeFixed64(element)$
$writeSFixed32(element)$
$writeSFixed64(element)$
$writeString(element)$
$writeByte(element)$
$writeBool(element)$
$writeFloat(element)$
$writeDouble(element)$
$writeMessageEnum(element)$
>>

writeMessageEnum(element) ::= <<
$if(!typeMap.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    offset = $element.typeName$_write_with_tag(&_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset, $element.tag$);
}
$else$
offset = $element.typeName$_write_with_tag(&_$name$-\>_$element.name$, _buffer, offset, $element.tag$);
$endif$
$endif$
>>

writeFloat(element) ::= <<
$if(floatMap.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    unsigned long *$element.name$_ptr = (unsigned long *)&_$name$-\>_$element.name$[$element.name$_cnt];
    offset = write_raw_little_endian32(*$element.name$_ptr, _buffer, offset);
}
$else$
$writeTag(element)$
$writeFloatNoTag(element)$
$endif$
$endif$
>>

writeFloatNoTag(element) ::= <<
unsigned long *$element.name$_ptr = (unsigned long *)&_$name$-\>_$element.name$;
offset = write_raw_little_endian32(*$element.name$_ptr, _buffer, offset);
>>

writeDouble(element) ::= <<
$if(doubleMap.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    unsigned long long *$element.name$_ptr = (unsigned long long*)&_$name$-\>_$element.name$[$element.name$_cnt];
    offset = write_raw_little_endian64(*$element.name$_ptr, _buffer, offset);
}
$else$
$writeTag(element)$
$writeDoubleNoTag(element)$
$endif$
$endif$
>>

writeDoubleNoTag(element) ::= <<
unsigned long long *$element.name$_ptr = (unsigned long long*)&_$name$-\>_$element.name$;
offset = write_raw_little_endian64(*$element.name$_ptr, _buffer, offset);
>>

writeBool(element) ::= <<
$if(boolMap.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_byte(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeBoolNoTag(element)$
$endif$
$endif$
>>

writeBoolNoTag(element) ::= <<
offset = write_raw_byte(_$name$-\>_$element.name$, _buffer, offset);
>>

writeString(element) ::= <<
$if(stringMap.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_varint32(_$name$-\>_$element.name$_len[$element.name$_cnt], _buffer, offset);
    offset = write_raw_bytes(_$name$-\>_$element.name$[$element.name$_cnt], _$name$-\>_$element.name$_len[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeStringNoTag(element)$
$endif$
$endif$
>>

writeStringNoTag(element) ::= <<
offset = write_raw_varint32(_$name$-\>_$element.name$_len, _buffer, offset);
offset = write_raw_bytes(_$name$-\>_$element.name$, _$name$-\>_$element.name$_len, _buffer, offset);
>>

writeByte(element) ::= <<
$if(bytesMap.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_varint32(_$name$-\>_$element.name$_len[$element.name$_cnt], _buffer, offset);
    offset = write_raw_bytes(_$name$-\>_$element.name$[$element.name$_cnt], _$name$-\>_$element.name$_len[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeByteNoTag(element)$
$endif$
$endif$
>>

writeByteNoTag(element) ::= <<
offset = write_raw_varint32(_$name$-\>_$element.name$_len, _buffer, offset);
offset = write_raw_bytes(_$name$-\>_$element.name$, _$name$-\>_$element.name$_len, _buffer, offset);
>>

writeInt32(element) ::= <<
$if(int32Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    if (_$name$-\>_$element.name$[$element.name$_cnt] >= 0)
        offset = write_raw_varint32(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
    else
        offset = write_raw_varint64(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeInt32NoTag(element)$
$endif$
$endif$
>>

writeInt32NoTag(element) ::= <<
if (_$name$-\>_$element.name$ >= 0)
    offset = write_raw_varint32(_$name$-\>_$element.name$, _buffer, offset);
else
    offset = write_raw_varint64(_$name$-\>_$element.name$, _buffer, offset);
>>

writeInt64(element) ::= <<
$if(int64Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_varint64(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeInt64NoTag(element)$
$endif$
$endif$
>>

writeInt64NoTag(element) ::= <<
offset = write_raw_varint64(_$name$-\>_$element.name$, _buffer, offset);
>>

writeSInt32(element) ::= <<
$if(sint32Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_varint32(encode_zig_zag32(_$name$-\>_$element.name$[$element.name$_cnt]), _buffer, offset);
}
$else$
$writeTag(element)$
$writeSInt32NoTag(element)$
$endif$
$endif$
>>

writeSInt32NoTag(element) ::= <<
offset = write_raw_varint32(encode_zig_zag32(_$name$-\>_$element.name$), _buffer, offset);
>>

writeSInt64(element) ::= <<
$if(sint64Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_varint64(encode_zig_zag64(_$name$-\>_$element.name$[$element.name$_cnt]), _buffer, offset);
}
$else$
$writeTag(element)$
$writeSInt64NoTag(element)$
$endif$
$endif$
>>

writeSInt64NoTag(element) ::= <<
offset = write_raw_varint64(encode_zig_zag64(_$name$-\>_$element.name$), _buffer, offset);
>>

writeUInt32(element) ::= <<
$if(uint32Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_varint32(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeUInt32NoTag(element)$
$endif$
$endif$
>>

writeUInt32NoTag(element) ::= <<
offset = write_raw_varint32(_$name$-\>_$element.name$, _buffer, offset);
>>

writeUInt64(element) ::= <<
$if(uint64Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_varint64(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeUInt64NoTag(element)$
$endif$
$endif$
>>

writeUInt64NoTag(element) ::= <<
offset = write_raw_varint64(_$name$-\>_$element.name$, _buffer, offset);
>>

writeFixed32(element) ::= <<
$if(fixed32Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_little_endian32(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeFixed32NoTag(element)$
$endif$
$endif$
>>

writeFixed32NoTag(element) ::= <<
offset = write_raw_little_endian32(_$name$-\>_$element.name$, _buffer, offset);
>>

writeFixed64(element) ::= <<
$if(fixed64Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_little_endian64(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeFixed64NoTag(element)$
$endif$
$endif$
>>

writeFixed64NoTag(element) ::= <<
offset = write_raw_little_endian64(_$name$-\>_$element.name$, _buffer, offset);
>>

writeSFixed32(element) ::= <<
$if(sfixed32Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_little_endian32(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeSFixed32NoTag(element)$
$endif$
$endif$
>>

writeSFixed32NoTag(element) ::= <<
offset = write_raw_little_endian32(_$name$-\>_$element.name$, _buffer, offset);
>>

writeSFixed64(element) ::= <<
$if(sfixed64Map.(element.typeName))$
$if(arrayModifiers.(element.modifier))$
int $element.name$_cnt;
for ($element.name$_cnt = 0; $element.name$_cnt < _$name$-\>_$element.name$_repeated_len; ++ $element.name$_cnt) {
    $writeTag(element)$
    offset = write_raw_little_endian64(_$name$-\>_$element.name$[$element.name$_cnt], _buffer, offset);
}
$else$
$writeTag(element)$
$writeSFixed64NoTag(element)$
$endif$
$endif$
>>

writeSFixed64NoTag(element) ::= <<
offset = write_raw_little_endian64(_$name$-\>_$element.name$, _buffer, offset);
>>


writeTag(element) ::= <<
offset = write_raw_varint32(($element.tag$<<3)+$wireTypeMap.(element.typeName)$, _buffer, offset);
>>

messageAttribute(modifier, typeName, typeClass, name, tag) ::= <<>>

qualifiedID(ids) ::= <<$ids; separator="."$>>

