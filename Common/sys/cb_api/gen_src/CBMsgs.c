/******************************************************************************* 
 * File generated by Protoc for Embedded C and split by protobuf_lib_splitter.py
 * This file contains only the functionality of protobuf-c so that is specific
 * to the protocol.  It can  be compiled into a separate library from the core 
 * to prevent symbol crashes between multiple different protobuf generated 
 * libraries.
 *                                                   
 * Copyright (c) 2009-2012
 * Technische Universitaet Muenchen
 * http://www4.in.tum.de/
 * Copyright (c) 2013
 * Datacard Group
 *                                                                                                                                  
 * Do not edit.                                                                
 ******************************************************************************/
/******************************************************************* 
 * C-file generated by Protoc for Embedded C.                      *
 * Version 0.2 (2012-01-31)                                        *
 *                                                                 *
 * Copyright (c) 2009-2012                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : CBMsgs.proto
 * Package: 
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#include "CBMsgs.h"
#include "protobuf_core.h"
/*******************************************************************
 * Enum: CBMsgs.proto, line 192
 *******************************************************************/
int CBMsgName_write_with_tag(enum CBMsgName *_CBMsgName, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_CBMsgName, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Enum: CBMsgs.proto, line 264
 *******************************************************************/
int CBMsgType_write_with_tag(enum CBMsgType *_CBMsgType, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_CBMsgType, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Enum: CBMsgs.proto, line 286
 *******************************************************************/
int CBMsgRoute_write_with_tag(enum CBMsgRoute *_CBMsgRoute, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_CBMsgRoute, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Enum: CBMsgs.proto, line 315
 *******************************************************************/
int CBBootMode_write_with_tag(enum CBBootMode *_CBBootMode, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_CBBootMode, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Message: CBMsgs.proto, line 377
 *******************************************************************/
int CBBasicMsg_write(struct CBBasicMsg *_CBBasicMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = CBMsgName_write_with_tag(&_CBBasicMsg->_msgName, _buffer, offset, 1);
    offset = CBMsgType_write_with_tag(&_CBBasicMsg->_msgType, _buffer, offset, 2);
    offset = CBMsgRoute_write_with_tag(&_CBBasicMsg->_msgRoute, _buffer, offset, 3);
    offset = write_raw_varint32((4<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBBasicMsg->_msgID, _buffer, offset);

    offset = write_raw_varint32((5<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBBasicMsg->_msgReqProg, _buffer, offset);

    offset = CBMsgName_write_with_tag(&_CBBasicMsg->_msgPayload, _buffer, offset, 6);
    
    return offset;
}

int CBBasicMsg_write_with_tag(struct CBBasicMsg *_CBBasicMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBBasicMsg_write_delimited_to(_CBBasicMsg, _buffer, offset);
    
    return offset;
}

int CBBasicMsg_write_delimited_to(struct CBBasicMsg *_CBBasicMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBBasicMsg_write(_CBBasicMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBBasicMsg_clear(struct CBBasicMsg *_CBBasicMsg) {
    _memset(_CBBasicMsg, 0, sizeof(struct CBBasicMsg));
}

int CBBasicMsg_read(void *_buffer, struct CBBasicMsg *_CBBasicMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBBasicMsg_clear(_CBBasicMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBBasicMsg._msgName 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBasicMsg->_msgName = tag;
                break;
            //tag of: _CBBasicMsg._msgType 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBasicMsg->_msgType = tag;
                break;
            //tag of: _CBBasicMsg._msgRoute 
            case 3 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBasicMsg->_msgRoute = tag;
                break;
            //tag of: _CBBasicMsg._msgID 
            case 4 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBasicMsg->_msgID = tag;
                break;
            //tag of: _CBBasicMsg._msgReqProg 
            case 5 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBasicMsg->_msgReqProg = tag;
                break;
            //tag of: _CBBasicMsg._msgPayload 
            case 6 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBasicMsg->_msgPayload = tag;
                break;
        }
    }
    
    return offset;
}

int CBBasicMsg_read_delimited_from(void *_buffer, struct CBBasicMsg *_CBBasicMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBBasicMsg_read(_buffer, _CBBasicMsg, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: CBMsgs.proto, line 402
 *******************************************************************/
int CBStatusPayloadMsg_write(struct CBStatusPayloadMsg *_CBStatusPayloadMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBStatusPayloadMsg->_errorCode, _buffer, offset);

    
    return offset;
}

int CBStatusPayloadMsg_write_with_tag(struct CBStatusPayloadMsg *_CBStatusPayloadMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBStatusPayloadMsg_write_delimited_to(_CBStatusPayloadMsg, _buffer, offset);
    
    return offset;
}

int CBStatusPayloadMsg_write_delimited_to(struct CBStatusPayloadMsg *_CBStatusPayloadMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBStatusPayloadMsg_write(_CBStatusPayloadMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBStatusPayloadMsg_clear(struct CBStatusPayloadMsg *_CBStatusPayloadMsg) {
    _memset(_CBStatusPayloadMsg, 0, sizeof(struct CBStatusPayloadMsg));
}

int CBStatusPayloadMsg_read(void *_buffer, struct CBStatusPayloadMsg *_CBStatusPayloadMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBStatusPayloadMsg_clear(_CBStatusPayloadMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBStatusPayloadMsg._errorCode 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBStatusPayloadMsg->_errorCode = tag;
                break;
        }
    }
    
    return offset;
}

int CBStatusPayloadMsg_read_delimited_from(void *_buffer, struct CBStatusPayloadMsg *_CBStatusPayloadMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBStatusPayloadMsg_read(_buffer, _CBStatusPayloadMsg, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: CBMsgs.proto, line 453
 *******************************************************************/
int CBVersionPayloadMsg_write(struct CBVersionPayloadMsg *_CBVersionPayloadMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBVersionPayloadMsg->_errorCode, _buffer, offset);

    offset = write_raw_varint32((2<<3)+2, _buffer, offset);
    offset = write_raw_varint32(_CBVersionPayloadMsg->_fwVerString_len, _buffer, offset);
    offset = write_raw_bytes(_CBVersionPayloadMsg->_fwVerString, _CBVersionPayloadMsg->_fwVerString_len, _buffer, offset);

    offset = write_raw_varint32((3<<3)+2, _buffer, offset);
    offset = write_raw_varint32(_CBVersionPayloadMsg->_fwDateString_len, _buffer, offset);
    offset = write_raw_bytes(_CBVersionPayloadMsg->_fwDateString, _CBVersionPayloadMsg->_fwDateString_len, _buffer, offset);

    offset = write_raw_varint32((4<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBVersionPayloadMsg->_dbVersion, _buffer, offset);

    
    return offset;
}

int CBVersionPayloadMsg_write_with_tag(struct CBVersionPayloadMsg *_CBVersionPayloadMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBVersionPayloadMsg_write_delimited_to(_CBVersionPayloadMsg, _buffer, offset);
    
    return offset;
}

int CBVersionPayloadMsg_write_delimited_to(struct CBVersionPayloadMsg *_CBVersionPayloadMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBVersionPayloadMsg_write(_CBVersionPayloadMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBVersionPayloadMsg_clear(struct CBVersionPayloadMsg *_CBVersionPayloadMsg) {
    _memset(_CBVersionPayloadMsg, 0, sizeof(struct CBVersionPayloadMsg));
}

int CBVersionPayloadMsg_read(void *_buffer, struct CBVersionPayloadMsg *_CBVersionPayloadMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBVersionPayloadMsg_clear(_CBVersionPayloadMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBVersionPayloadMsg._errorCode 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBVersionPayloadMsg->_errorCode = tag;
                break;
            //tag of: _CBVersionPayloadMsg._fwVerString 
            case 2 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBVersionPayloadMsg->_fwVerString_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_CBVersionPayloadMsg->_fwVerString + i), _buffer, offset);
                break;
            //tag of: _CBVersionPayloadMsg._fwDateString 
            case 3 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBVersionPayloadMsg->_fwDateString_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_CBVersionPayloadMsg->_fwDateString + i), _buffer, offset);
                break;
            //tag of: _CBVersionPayloadMsg._dbVersion 
            case 4 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBVersionPayloadMsg->_dbVersion = tag;
                break;
        }
    }
    
    return offset;
}

int CBVersionPayloadMsg_read_delimited_from(void *_buffer, struct CBVersionPayloadMsg *_CBVersionPayloadMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBVersionPayloadMsg_read(_buffer, _CBVersionPayloadMsg, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: CBMsgs.proto, line 543
 *******************************************************************/
int CBBootModePayloadMsg_write(struct CBBootModePayloadMsg *_CBBootModePayloadMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBBootModePayloadMsg->_errorCode, _buffer, offset);

    offset = CBBootMode_write_with_tag(&_CBBootModePayloadMsg->_bootMode, _buffer, offset, 2);
    
    return offset;
}

int CBBootModePayloadMsg_write_with_tag(struct CBBootModePayloadMsg *_CBBootModePayloadMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBBootModePayloadMsg_write_delimited_to(_CBBootModePayloadMsg, _buffer, offset);
    
    return offset;
}

int CBBootModePayloadMsg_write_delimited_to(struct CBBootModePayloadMsg *_CBBootModePayloadMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBBootModePayloadMsg_write(_CBBootModePayloadMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBBootModePayloadMsg_clear(struct CBBootModePayloadMsg *_CBBootModePayloadMsg) {
    _memset(_CBBootModePayloadMsg, 0, sizeof(struct CBBootModePayloadMsg));
}

int CBBootModePayloadMsg_read(void *_buffer, struct CBBootModePayloadMsg *_CBBootModePayloadMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBBootModePayloadMsg_clear(_CBBootModePayloadMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBBootModePayloadMsg._errorCode 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBootModePayloadMsg->_errorCode = tag;
                break;
            //tag of: _CBBootModePayloadMsg._bootMode 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBBootModePayloadMsg->_bootMode = tag;
                break;
        }
    }
    
    return offset;
}

int CBBootModePayloadMsg_read_delimited_from(void *_buffer, struct CBBootModePayloadMsg *_CBBootModePayloadMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBBootModePayloadMsg_read(_buffer, _CBBootModePayloadMsg, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: CBMsgs.proto, line 659
 *******************************************************************/
int CBFlashMetaPayloadMsg_write(struct CBFlashMetaPayloadMsg *_CBFlashMetaPayloadMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashMetaPayloadMsg->_errorCode, _buffer, offset);

    offset = write_raw_varint32((2<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashMetaPayloadMsg->_imageCrc, _buffer, offset);

    offset = write_raw_varint32((3<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashMetaPayloadMsg->_imageSize, _buffer, offset);

    offset = CBBootMode_write_with_tag(&_CBFlashMetaPayloadMsg->_imageType, _buffer, offset, 4);
    offset = write_raw_varint32((5<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashMetaPayloadMsg->_imageMaj, _buffer, offset);

    offset = write_raw_varint32((6<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashMetaPayloadMsg->_imageMin, _buffer, offset);

    offset = write_raw_varint32((7<<3)+2, _buffer, offset);
    offset = write_raw_varint32(_CBFlashMetaPayloadMsg->_imageDatetime_len, _buffer, offset);
    offset = write_raw_bytes(_CBFlashMetaPayloadMsg->_imageDatetime, _CBFlashMetaPayloadMsg->_imageDatetime_len, _buffer, offset);

    offset = write_raw_varint32((8<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashMetaPayloadMsg->_imageNumPackets, _buffer, offset);

    
    return offset;
}

int CBFlashMetaPayloadMsg_write_with_tag(struct CBFlashMetaPayloadMsg *_CBFlashMetaPayloadMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBFlashMetaPayloadMsg_write_delimited_to(_CBFlashMetaPayloadMsg, _buffer, offset);
    
    return offset;
}

int CBFlashMetaPayloadMsg_write_delimited_to(struct CBFlashMetaPayloadMsg *_CBFlashMetaPayloadMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBFlashMetaPayloadMsg_write(_CBFlashMetaPayloadMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBFlashMetaPayloadMsg_clear(struct CBFlashMetaPayloadMsg *_CBFlashMetaPayloadMsg) {
    _memset(_CBFlashMetaPayloadMsg, 0, sizeof(struct CBFlashMetaPayloadMsg));
}

int CBFlashMetaPayloadMsg_read(void *_buffer, struct CBFlashMetaPayloadMsg *_CBFlashMetaPayloadMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBFlashMetaPayloadMsg_clear(_CBFlashMetaPayloadMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBFlashMetaPayloadMsg._errorCode 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_errorCode = tag;
                break;
            //tag of: _CBFlashMetaPayloadMsg._imageCrc 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_imageCrc = tag;
                break;
            //tag of: _CBFlashMetaPayloadMsg._imageSize 
            case 3 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_imageSize = tag;
                break;
            //tag of: _CBFlashMetaPayloadMsg._imageType 
            case 4 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_imageType = tag;
                break;
            //tag of: _CBFlashMetaPayloadMsg._imageMaj 
            case 5 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_imageMaj = tag;
                break;
            //tag of: _CBFlashMetaPayloadMsg._imageMin 
            case 6 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_imageMin = tag;
                break;
            //tag of: _CBFlashMetaPayloadMsg._imageDatetime 
            case 7 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_imageDatetime_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_CBFlashMetaPayloadMsg->_imageDatetime + i), _buffer, offset);
                break;
            //tag of: _CBFlashMetaPayloadMsg._imageNumPackets 
            case 8 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashMetaPayloadMsg->_imageNumPackets = tag;
                break;
        }
    }
    
    return offset;
}

int CBFlashMetaPayloadMsg_read_delimited_from(void *_buffer, struct CBFlashMetaPayloadMsg *_CBFlashMetaPayloadMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBFlashMetaPayloadMsg_read(_buffer, _CBFlashMetaPayloadMsg, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Message: CBMsgs.proto, line 693
 *******************************************************************/
int CBFlashDataPayloadMsg_write(struct CBFlashDataPayloadMsg *_CBFlashDataPayloadMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashDataPayloadMsg->_dataCrc, _buffer, offset);

    offset = write_raw_varint32((2<<3)+2, _buffer, offset);
    offset = write_raw_varint32(_CBFlashDataPayloadMsg->_dataBuf_len, _buffer, offset);
    offset = write_raw_bytes(_CBFlashDataPayloadMsg->_dataBuf, _CBFlashDataPayloadMsg->_dataBuf_len, _buffer, offset);

    offset = write_raw_varint32((3<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBFlashDataPayloadMsg->_seqCurr, _buffer, offset);

    
    return offset;
}

int CBFlashDataPayloadMsg_write_with_tag(struct CBFlashDataPayloadMsg *_CBFlashDataPayloadMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBFlashDataPayloadMsg_write_delimited_to(_CBFlashDataPayloadMsg, _buffer, offset);
    
    return offset;
}

int CBFlashDataPayloadMsg_write_delimited_to(struct CBFlashDataPayloadMsg *_CBFlashDataPayloadMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBFlashDataPayloadMsg_write(_CBFlashDataPayloadMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBFlashDataPayloadMsg_clear(struct CBFlashDataPayloadMsg *_CBFlashDataPayloadMsg) {
    _memset(_CBFlashDataPayloadMsg, 0, sizeof(struct CBFlashDataPayloadMsg));
}

int CBFlashDataPayloadMsg_read(void *_buffer, struct CBFlashDataPayloadMsg *_CBFlashDataPayloadMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBFlashDataPayloadMsg_clear(_CBFlashDataPayloadMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBFlashDataPayloadMsg._dataCrc 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashDataPayloadMsg->_dataCrc = tag;
                break;
            //tag of: _CBFlashDataPayloadMsg._dataBuf 
            case 2 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashDataPayloadMsg->_dataBuf_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_CBFlashDataPayloadMsg->_dataBuf + i), _buffer, offset);
                break;
            //tag of: _CBFlashDataPayloadMsg._seqCurr 
            case 3 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBFlashDataPayloadMsg->_seqCurr = tag;
                break;
        }
    }
    
    return offset;
}

int CBFlashDataPayloadMsg_read_delimited_from(void *_buffer, struct CBFlashDataPayloadMsg *_CBFlashDataPayloadMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBFlashDataPayloadMsg_read(_buffer, _CBFlashDataPayloadMsg, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Enum: CBMsgs.proto, line 781
 *******************************************************************/
int CBI2CDevices_write_with_tag(enum CBI2CDevices *_CBI2CDevices, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_CBI2CDevices, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Enum: CBMsgs.proto, line 791
 *******************************************************************/
int CBAccessType_write_with_tag(enum CBAccessType *_CBAccessType, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_CBAccessType, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Message: CBMsgs.proto, line 815
 *******************************************************************/
int CBI2CDataPayloadMsg_write(struct CBI2CDataPayloadMsg *_CBI2CDataPayloadMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = CBI2CDevices_write_with_tag(&_CBI2CDataPayloadMsg->_i2cDev, _buffer, offset, 1);
    offset = write_raw_varint32((2<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBI2CDataPayloadMsg->_start, _buffer, offset);

    offset = write_raw_varint32((3<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBI2CDataPayloadMsg->_nBytes, _buffer, offset);

    offset = CBAccessType_write_with_tag(&_CBI2CDataPayloadMsg->_accType, _buffer, offset, 4);
    offset = write_raw_varint32((5<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBI2CDataPayloadMsg->_errorCode, _buffer, offset);

    offset = write_raw_varint32((6<<3)+2, _buffer, offset);
    offset = write_raw_varint32(_CBI2CDataPayloadMsg->_dataBuf_len, _buffer, offset);
    offset = write_raw_bytes(_CBI2CDataPayloadMsg->_dataBuf, _CBI2CDataPayloadMsg->_dataBuf_len, _buffer, offset);

    
    return offset;
}

int CBI2CDataPayloadMsg_write_with_tag(struct CBI2CDataPayloadMsg *_CBI2CDataPayloadMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBI2CDataPayloadMsg_write_delimited_to(_CBI2CDataPayloadMsg, _buffer, offset);
    
    return offset;
}

int CBI2CDataPayloadMsg_write_delimited_to(struct CBI2CDataPayloadMsg *_CBI2CDataPayloadMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBI2CDataPayloadMsg_write(_CBI2CDataPayloadMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBI2CDataPayloadMsg_clear(struct CBI2CDataPayloadMsg *_CBI2CDataPayloadMsg) {
    _memset(_CBI2CDataPayloadMsg, 0, sizeof(struct CBI2CDataPayloadMsg));
}

int CBI2CDataPayloadMsg_read(void *_buffer, struct CBI2CDataPayloadMsg *_CBI2CDataPayloadMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBI2CDataPayloadMsg_clear(_CBI2CDataPayloadMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBI2CDataPayloadMsg._i2cDev 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBI2CDataPayloadMsg->_i2cDev = tag;
                break;
            //tag of: _CBI2CDataPayloadMsg._start 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBI2CDataPayloadMsg->_start = tag;
                break;
            //tag of: _CBI2CDataPayloadMsg._nBytes 
            case 3 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBI2CDataPayloadMsg->_nBytes = tag;
                break;
            //tag of: _CBI2CDataPayloadMsg._accType 
            case 4 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBI2CDataPayloadMsg->_accType = tag;
                break;
            //tag of: _CBI2CDataPayloadMsg._errorCode 
            case 5 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBI2CDataPayloadMsg->_errorCode = tag;
                break;
            //tag of: _CBI2CDataPayloadMsg._dataBuf 
            case 6 :
                 /* Re-use 'tag' to store string length. */
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBI2CDataPayloadMsg->_dataBuf_len = tag;
                for(i = 0; i < tag; ++ i) 
                    offset = read_raw_byte((_CBI2CDataPayloadMsg->_dataBuf + i), _buffer, offset);
                break;
        }
    }
    
    return offset;
}

int CBI2CDataPayloadMsg_read_delimited_from(void *_buffer, struct CBI2CDataPayloadMsg *_CBI2CDataPayloadMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBI2CDataPayloadMsg_read(_buffer, _CBI2CDataPayloadMsg, offset, size + offset);
    
    return offset + size;
}


/*******************************************************************
 * Enum: CBMsgs.proto, line 832
 *******************************************************************/
int CBRamTest_t_write_with_tag(enum CBRamTest_t *_CBRamTest_t, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+0, _buffer, offset);
    /* Write content.*/
    offset = write_raw_varint32(*_CBRamTest_t, _buffer, offset);
    
    return offset;
}

/*******************************************************************
 * Message: CBMsgs.proto, line 897
 *******************************************************************/
int CBRamTestPayloadMsg_write(struct CBRamTestPayloadMsg *_CBRamTestPayloadMsg, void *_buffer, int offset) {
    /* Write content of each message element.*/
    offset = write_raw_varint32((1<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBRamTestPayloadMsg->_errorCode, _buffer, offset);

    offset = CBRamTest_t_write_with_tag(&_CBRamTestPayloadMsg->_test, _buffer, offset, 2);
    offset = write_raw_varint32((3<<3)+0, _buffer, offset);
    offset = write_raw_varint32(_CBRamTestPayloadMsg->_addr, _buffer, offset);

    
    return offset;
}

int CBRamTestPayloadMsg_write_with_tag(struct CBRamTestPayloadMsg *_CBRamTestPayloadMsg, void *_buffer, int offset, int tag) {
    /* Write tag.*/
    offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
    /* Write content.*/
    offset = CBRamTestPayloadMsg_write_delimited_to(_CBRamTestPayloadMsg, _buffer, offset);
    
    return offset;
}

int CBRamTestPayloadMsg_write_delimited_to(struct CBRamTestPayloadMsg *_CBRamTestPayloadMsg, void *_buffer, int offset) {
    int i, shift, new_offset, size;
    
    new_offset = CBRamTestPayloadMsg_write(_CBRamTestPayloadMsg, _buffer, offset);
    size = new_offset - offset;
    shift = (size > 127) ? 2 : 1;
    for (i = new_offset - 1; i >= offset; -- i)
        *((char *)_buffer + i + shift) = *((char *)_buffer + i);
    
    write_raw_varint32((unsigned long) size, _buffer, offset);         
        
    return new_offset + shift;
}

void CBRamTestPayloadMsg_clear(struct CBRamTestPayloadMsg *_CBRamTestPayloadMsg) {
    _memset(_CBRamTestPayloadMsg, 0, sizeof(struct CBRamTestPayloadMsg));
}

int CBRamTestPayloadMsg_read(void *_buffer, struct CBRamTestPayloadMsg *_CBRamTestPayloadMsg, int offset, int limit) {
    int i = 0;
    unsigned long tag = i;

    /* Reset all attributes to 0 in advance. */
    CBRamTestPayloadMsg_clear(_CBRamTestPayloadMsg);

    /* Read/interpret all attributes from buffer offset until upper limit is reached. */
    while(offset < limit) {
        offset = read_raw_varint32(&tag, _buffer, offset);
        tag = tag>>3;
        switch(tag){
            //tag of: _CBRamTestPayloadMsg._errorCode 
            case 1 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBRamTestPayloadMsg->_errorCode = tag;
                break;
            //tag of: _CBRamTestPayloadMsg._test 
            case 2 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBRamTestPayloadMsg->_test = tag;
                break;
            //tag of: _CBRamTestPayloadMsg._addr 
            case 3 :
                offset = read_raw_varint32(&tag, _buffer, offset);
                _CBRamTestPayloadMsg->_addr = tag;
                break;
        }
    }
    
    return offset;
}

int CBRamTestPayloadMsg_read_delimited_from(void *_buffer, struct CBRamTestPayloadMsg *_CBRamTestPayloadMsg, int offset) {
    unsigned long size;
    
    offset = read_raw_varint32(&size, _buffer, offset);
    CBRamTestPayloadMsg_read(_buffer, _CBRamTestPayloadMsg, offset, size + offset);
    
    return offset + size;
}
